(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function t(t){for(var r,o,s=t[0],c=t[1],l=t[2],p=0,d=[];p<s.length;p++)o=s[p],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&d.push(i[o][0]),i[o]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(u&&u(t);d.length;)d.shift()();return a.push.apply(a,l||[]),e()}function e(){for(var n,t=0;t<a.length;t++){for(var e=a[t],r=!0,s=1;s<e.length;s++){var c=e[s];0!==i[c]&&(r=!1)}r&&(a.splice(t--,1),n=o(o.s=e[0]))}return n}var r={},i={1:0},a=[];function o(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,o),e.l=!0,e.exports}o.e=function(n){var t=[],e=i[n];if(0!==e)if(e)t.push(e[2]);else{var r=new Promise((function(t,r){e=i[n]=[t,r]}));t.push(e[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"803b0d2b",3:"a34b78c4",4:"5c305dec",5:"2ad0f61b",6:"a7ef5206",7:"5a7ac743",8:"9fb37c50",9:"add552d6",10:"c6698d77",11:"c38f8b8a",12:"627adaa3",13:"f2b6b24a",14:"073a66cc",15:"4fe2673b",16:"01c406f5"}[n]+".js"}(n);var c=new Error;a=function(t){s.onerror=s.onload=null,clearTimeout(l);var e=i[n];if(0!==e){if(e){var r=t&&("load"===t.type?"missing":t.type),a=t&&t.target&&t.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",c.name="ChunkLoadError",c.type=r,c.request=a,e[1](c)}i[n]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(t)},o.m=n,o.c=r,o.d=function(n,t,e){o.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,t){if(1&t&&(n=o(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(o.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var r in n)o.d(e,r,function(t){return n[t]}.bind(null,r));return e},o.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(t,"a",t),t},o.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},o.p="/notes/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var l=0;l<s.length;l++)t(s[l]);var u=c;a.push([243,0]),e()}([function(n,t){var e=function(n){return n&&n.Math==Math&&n};n.exports=e("object"==typeof globalThis&&globalThis)||e("object"==typeof window&&window)||e("object"==typeof self&&self)||e("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,t,e){var r=e(0),i=e(40).f,a=e(29),o=e(15),s=e(120),c=e(124),l=e(112);n.exports=function(n,t){var e,u,p,d,f,h=n.target,m=n.global,v=n.stat;if(e=m?r:v?r[h]||s(h,{}):(r[h]||{}).prototype)for(u in t){if(d=t[u],p=n.dontCallGetSet?(f=i(e,u))&&f.value:e[u],!l(m?u:h+(v?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&a(d,"sham",!0),o(e,u,d,n)}}},function(n,t){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,t,e){var r=e(68),i=Function.prototype,a=i.bind,o=i.call,s=r&&a.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,t){n.exports=function(n){return"function"==typeof n}},function(n,t,e){var r=e(127),i=e(15),a=e(271);r||i(Object.prototype,"toString",a,{unsafe:!0})},function(n,t,e){var r=e(0),i=e(53),a=e(9),o=e(89),s=e(54),c=e(161),l=i("wks"),u=r.Symbol,p=u&&u.for,d=c?u:u&&u.withoutSetter||o;n.exports=function(n){if(!a(l,n)||!s&&"string"!=typeof l[n]){var t="Symbol."+n;s&&a(u,n)?l[n]=u[n]:l[n]=c&&p?p(t):d(t)}return l[n]}},function(n,t,e){var r=e(68),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,t,e){var r=e(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,t,e){var r=e(3),i=e(16),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,t){return a(i(n),t)}},function(n,t,e){var r=e(0),i=e(11),a=r.String,o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not an object")}},function(n,t,e){var r=e(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,t,e){var r=e(0),i=e(86),a=r.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,t,e){var r=e(0),i=e(8),a=e(163),o=e(162),s=e(10),c=e(91),l=r.TypeError,u=Object.defineProperty,p=Object.getOwnPropertyDescriptor;t.f=i?o?function(n,t,e){if(s(n),t=c(t),s(e),"function"==typeof n&&"prototype"===t&&"value"in e&&"writable"in e&&!e.writable){var r=p(n,t);r&&r.writable&&(n[t]=e.value,e={configurable:"configurable"in e?e.configurable:r.configurable,enumerable:"enumerable"in e?e.enumerable:r.enumerable,writable:!1})}return u(n,t,e)}:u:function(n,t,e){if(s(n),t=c(t),s(e),a)try{return u(n,t,e)}catch(n){}if("get"in e||"set"in e)throw l("Accessors not supported");return"value"in e&&(n[t]=e.value),n}},function(n,t,e){var r=e(0),i=e(4),a=function(n){return i(n)?n:void 0};n.exports=function(n,t){return arguments.length<2?a(r[n]):r[n]&&r[n][t]}},function(n,t,e){var r=e(4),i=e(29),a=e(168),o=e(120);n.exports=function(n,t,e,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:t;return r(e)&&a(e,l,s),s.global?c?n[t]=e:o(t,e):(s.unsafe?n[t]&&(c=!0):delete n[t],c?n[t]=e:i(n,t,e)),n}},function(n,t,e){var r=e(0),i=e(18),a=r.Object;n.exports=function(n){return a(i(n))}},function(n,t){n.exports=!1},function(n,t,e){var r=e(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,t,e){"use strict";var r=e(1),i=e(102);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,t,e){var r=e(56);n.exports=function(n){return r(n.length)}},function(n,t,e){var r=e(67),i=e(18);n.exports=function(n){return r(i(n))}},function(n,t,e){"use strict";var r=e(184).charAt,i=e(12),a=e(39),o=e(167),s=a.set,c=a.getterFor("String Iterator");o(String,"String",(function(n){s(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,t=c(this),e=t.string,i=t.index;return i>=e.length?{value:void 0,done:!0}:(n=r(e,i),t.index+=n.length,{value:n,done:!1})}))},function(n,t,e){var r=e(15),i=e(280),a=Error.prototype;a.toString!==i&&r(a,"toString",i)},function(n,t,e){var r=e(0),i=e(4),a=e(70),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a function")}},function(n,t,e){var r=e(0),i=e(185),a=e(186),o=e(150),s=e(29),c=e(6),l=c("iterator"),u=c("toStringTag"),p=o.values,d=function(n,t){if(n){if(n[l]!==p)try{s(n,l,p)}catch(t){n[l]=p}if(n[u]||s(n,u,t),i[t])for(var e in o)if(n[e]!==o[e])try{s(n,e,o[e])}catch(t){n[e]=o[e]}}};for(var f in i)d(r[f]&&r[f].prototype,f);d(a,"DOMTokenList")},function(n,t,e){"use strict";var r=e(1),i=e(188);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,t,e){var r=e(0),i=e(185),a=e(186),o=e(188),s=e(29),c=function(n){if(n&&n.forEach!==o)try{s(n,"forEach",o)}catch(t){n.forEach=o}};for(var l in i)i[l]&&c(r[l]&&r[l].prototype);c(a)},function(n,t,e){var r=e(3),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,t,e){var r=e(8),i=e(13),a=e(50);n.exports=r?function(n,t,e){return i.f(n,t,a(1,e))}:function(n,t,e){return n[t]=e,n}},function(n,t){var e=Array.isArray;n.exports=e},function(n,t,e){var r=e(14);n.exports=r("navigator","userAgent")||""},function(n,t,e){var r=e(195),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,t,e){"use strict";function r(n,t,e,r,i,a,o,s){var c,l="function"==typeof n?n.options:n;if(t&&(l.render=t,l.staticRenderFns=e,l._compiled=!0),r&&(l.functional=!0),a&&(l._scopeId="data-v-"+a),o?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},l._ssrRegister=c):i&&(c=s?function(){i.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,t){return c.call(t),u(n,t)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}e.d(t,"a",(function(){return r}))},function(n,t,e){"use strict";var r=e(1),i=e(63).filter;r({target:"Array",proto:!0,forced:!e(79)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){var r,i=e(10),a=e(151),o=e(122),s=e(71),c=e(166),l=e(90),u=e(94),p=u("IE_PROTO"),d=function(){},f=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(f("")),n.close();var t=n.parentWindow.Object;return n=null,t},m=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,t;m="undefined"!=typeof document?document.domain&&r?h(r):((t=l("iframe")).style.display="none",c.appendChild(t),t.src=String("javascript:"),(n=t.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):h(r);for(var e=o.length;e--;)delete m.prototype[o[e]];return m()};s[p]=!0,n.exports=Object.create||function(n,t){var e;return null!==n?(d.prototype=i(n),e=new d,d.prototype=null,e[p]=n):e=m(),void 0===t?e:a.f(e,t)}},function(n,t,e){var r=e(3);n.exports=r({}.isPrototypeOf)},function(n,t,e){var r=e(13).f,i=e(9),a=e(6)("toStringTag");n.exports=function(n,t,e){n&&!e&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:t})}},function(n,t,e){var r=e(1),i=e(0),a=e(41),o=e(276),s=i.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,t){var e={};e[n]=o(n,t,c),r({global:!0,constructor:!0,arity:1,forced:c},e)},u=function(n,t){if(s&&s[n]){var e={};e[n]=o("WebAssembly."+n,t,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},e)}};l("Error",(function(n){return function(t){return a(n,this,arguments)}})),l("EvalError",(function(n){return function(t){return a(n,this,arguments)}})),l("RangeError",(function(n){return function(t){return a(n,this,arguments)}})),l("ReferenceError",(function(n){return function(t){return a(n,this,arguments)}})),l("SyntaxError",(function(n){return function(t){return a(n,this,arguments)}})),l("TypeError",(function(n){return function(t){return a(n,this,arguments)}})),l("URIError",(function(n){return function(t){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(t){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(t){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(t){return a(n,this,arguments)}}))},function(n,t,e){var r,i,a,o=e(246),s=e(0),c=e(3),l=e(11),u=e(29),p=e(9),d=e(119),f=e(94),h=e(71),m=s.TypeError,v=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new v),b=c(g.get),y=c(g.has),w=c(g.set);r=function(n,t){if(y(g,n))throw new m("Object already initialized");return t.facade=n,w(g,n,t),t},i=function(n){return b(g,n)||{}},a=function(n){return y(g,n)}}else{var k=f("state");h[k]=!0,r=function(n,t){if(p(n,k))throw new m("Object already initialized");return t.facade=n,u(n,k,t),t},i=function(n){return p(n,k)?n[k]:{}},a=function(n){return p(n,k)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(t){var e;if(!l(t)||(e=i(t)).type!==n)throw m("Incompatible receiver, "+n+" required");return e}}}},function(n,t,e){var r=e(8),i=e(7),a=e(123),o=e(50),s=e(21),c=e(91),l=e(9),u=e(163),p=Object.getOwnPropertyDescriptor;t.f=r?p:function(n,t){if(n=s(n),t=c(t),u)try{return p(n,t)}catch(n){}if(l(n,t))return o(!i(a.f,n,t),n[t])}},function(n,t,e){var r=e(68),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,t,e){var r=e(310),i=e(313);n.exports=function(n,t){var e=i(n,t);return r(e)?e:void 0}},function(n,t,e){"use strict";var r=e(1),i=e(0),a=e(51),o=e(98),s=e(11),c=e(93),l=e(20),u=e(21),p=e(58),d=e(6),f=e(79),h=e(75),m=f("slice"),v=d("species"),g=i.Array,b=Math.max;r({target:"Array",proto:!0,forced:!m},{slice:function(n,t){var e,r,i,d=u(this),f=l(d),m=c(n,f),y=c(void 0===t?f:t,f);if(a(d)&&(e=d.constructor,(o(e)&&(e===g||a(e.prototype))||s(e)&&null===(e=e[v]))&&(e=void 0),e===g||void 0===e))return h(d,m,y);for(r=new(void 0===e?g:e)(b(y-m,0)),i=0;m<y;m++,i++)m in d&&p(r,i,d[m]);return r.length=i,r}})},function(n,t,e){"use strict";e.d(t,"e",(function(){return r})),e.d(t,"b",(function(){return a})),e.d(t,"j",(function(){return o})),e.d(t,"g",(function(){return c})),e.d(t,"h",(function(){return l})),e.d(t,"i",(function(){return u})),e.d(t,"c",(function(){return p})),e.d(t,"f",(function(){return d})),e.d(t,"l",(function(){return f})),e.d(t,"m",(function(){return h})),e.d(t,"d",(function(){return v})),e.d(t,"k",(function(){return g})),e.d(t,"n",(function(){return b})),e.d(t,"a",(function(){return w}));e(19),e(46),e(147),e(85),e(145),e(118),e(45),e(26),e(5),e(27),e(34),e(88),e(84),e(160),e(83),e(216),e(23),e(149);var r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function c(n){return o.test(n)}function l(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;if(!n)return"404";var t=n.match(r),e=t?t[0]:"",i=s(n);return a.test(i)?n:i+".html"+e}function d(n,t){var e=n.hash,i=function(n){var t=n&&n.match(r);if(t)return t[0]}(t);return(!i||e===i)&&s(n.path)===s(t)}function f(n,t,e){if(c(t))return{type:"external",path:t};e&&(t=function(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}""!==i[0]&&i.unshift("");return i.join("/")}(t,e));for(var r=s(t),i=0;i<n.length;i++)if(s(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:p(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(t,'"')),{}}function h(n,t,e,r){var i=e.pages,a=e.themeConfig,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return m(n);var s=o.sidebar||a.sidebar;if(s){var c=function(n,t){if(Array.isArray(t))return{base:"/",config:t};for(var e in t)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(e)))return{base:e,config:t[e]};var r;return{}}(t,s),l=c.base,u=c.config;return"auto"===u?m(n):u?u.map((function(n){return function n(t,e,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof t)return f(e,t,r);if(Array.isArray(t))return Object.assign(f(e,t[0],r),{title:t[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var a=t.children||[];return 0===a.length&&t.path?Object.assign(f(e,t.path,r),{title:t.title}):{type:"group",path:t.path,title:t.title,sidebarDepth:t.sidebarDepth,initialOpenGroupIndex:t.initialOpenGroupIndex,children:a.map((function(t){return n(t,e,r,i+1)})),collapsable:!1!==t.collapsable}}(n,i,l)})):[]}return[]}function m(n){var t=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:t.map((function(t){return{type:"auto",title:t.title,basePath:n.path,path:n.path+"#"+t.slug,children:t.children||[]}}))}]}function v(n){var t;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?t=n:t&&(t.children||(t.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var t=n.frontmatter.date||n.lastUpdated||new Date,e=new Date(t);return"Invalid Date"==e&&t&&(e=new Date(t.replace(/-/g,"/"))),e.getTime()}function w(n,t){return y(t)-y(n)}},function(n,t,e){"use strict";var r=e(1),i=e(63).map;r({target:"Array",proto:!0,forced:!e(79)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r=e(41),i=e(7),a=e(3),o=e(116),s=e(2),c=e(10),l=e(4),u=e(47),p=e(56),d=e(12),f=e(18),h=e(134),m=e(49),v=e(291),g=e(117),b=e(6)("replace"),y=Math.max,w=Math.min,k=a([].concat),x=a([].push),_=a("".indexOf),S=a("".slice),T="$0"==="a".replace(/./,"$0"),j=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,t,e){var a=j?"$":"$0";return[function(n,e){var r=f(this),a=null==n?void 0:m(n,b);return a?i(a,n,r,e):i(t,d(r),n,e)},function(n,i){var o=c(this),s=d(n);if("string"==typeof i&&-1===_(i,a)&&-1===_(i,"$<")){var f=e(t,o,s,i);if(f.done)return f.value}var m=l(i);m||(i=d(i));var b=o.global;if(b){var T=o.unicode;o.lastIndex=0}for(var j=[];;){var C=g(o,s);if(null===C)break;if(x(j,C),!b)break;""===d(C[0])&&(o.lastIndex=h(s,p(o.lastIndex),T))}for(var I,A="",O=0,E=0;E<j.length;E++){for(var L=d((C=j[E])[0]),z=y(w(u(C.index),s.length),0),M=[],R=1;R<C.length;R++)x(M,void 0===(I=C[R])?I:String(I));var P=C.groups;if(m){var B=k([L],M,z,s);void 0!==P&&x(B,P);var N=d(r(i,void 0,B))}else N=v(L,s,z,M,P,i);z>=O&&(A+=S(s,O,z)+N,O=z+L.length)}return A+S(s,O)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!T||j)},function(n,t,e){var r=e(245);n.exports=function(n){var t=+n;return t!=t||0===t?0:r(t)}},function(n,t,e){"use strict";var r=e(2);n.exports=function(n,t){var e=[][n];return!!e&&r((function(){e.call(null,t||function(){return 1},1)}))}},function(n,t,e){var r=e(24);n.exports=function(n,t){var e=n[t];return null==e?void 0:r(e)}},function(n,t){n.exports=function(n,t){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:t}}},function(n,t,e){var r=e(28);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,t){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,t,e){var r=e(17),i=e(119);(n.exports=function(n,t){return i[n]||(i[n]=void 0!==t?t:{})})("versions",[]).push({version:"3.22.7",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.7/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,t,e){var r=e(55),i=e(2);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,t,e){var r,i,a=e(0),o=e(31),s=a.process,c=a.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,t,e){var r=e(47),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,t,e){var r=e(0);n.exports=r.Promise},function(n,t,e){"use strict";var r=e(91),i=e(13),a=e(50);n.exports=function(n,t,e){var o=r(t);o in n?i.f(n,o,a(0,e)):n[o]=e}},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(65),e(78),e(5),e(100),e(22),e(25),e(272),e(273),e(274),e(275),e(111),e(131),e(38),e(23),e(132),e(26),e(27),e(87),e(133),e(281),e(43);var r=e(60);function i(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
i=function(){return n};var n={},t=Object.prototype,e=t.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",c=a.toStringTag||"@@toStringTag";function l(n,t,e){return Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}),n[t]}try{l({},"")}catch(n){l=function(n,t,e){return n[t]=e}}function u(n,t,e,r){var i=t&&t.prototype instanceof f?t:f,a=Object.create(i.prototype),o=new T(r||[]);return a._invoke=function(n,t,e){var r="suspendedStart";return function(i,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw a;return C()}for(e.method=i,e.arg=a;;){var o=e.delegate;if(o){var s=x(o,e);if(s){if(s===d)continue;return s}}if("next"===e.method)e.sent=e._sent=e.arg;else if("throw"===e.method){if("suspendedStart"===r)throw r="completed",e.arg;e.dispatchException(e.arg)}else"return"===e.method&&e.abrupt("return",e.arg);r="executing";var c=p(n,t,e);if("normal"===c.type){if(r=e.done?"completed":"suspendedYield",c.arg===d)continue;return{value:c.arg,done:e.done}}"throw"===c.type&&(r="completed",e.method="throw",e.arg=c.arg)}}}(n,e,o),a}function p(n,t,e){try{return{type:"normal",arg:n.call(t,e)}}catch(n){return{type:"throw",arg:n}}}n.wrap=u;var d={};function f(){}function h(){}function m(){}var v={};l(v,o,(function(){return this}));var g=Object.getPrototypeOf,b=g&&g(g(j([])));b&&b!==t&&e.call(b,o)&&(v=b);var y=m.prototype=f.prototype=Object.create(v);function w(n){["next","throw","return"].forEach((function(t){l(n,t,(function(n){return this._invoke(t,n)}))}))}function k(n,t){var i;this._invoke=function(a,o){function s(){return new t((function(i,s){!function i(a,o,s,c){var l=p(n[a],n,o);if("throw"!==l.type){var u=l.arg,d=u.value;return d&&"object"==Object(r.a)(d)&&e.call(d,"__await")?t.resolve(d.__await).then((function(n){i("next",n,s,c)}),(function(n){i("throw",n,s,c)})):t.resolve(d).then((function(n){u.value=n,s(u)}),(function(n){return i("throw",n,s,c)}))}c(l.arg)}(a,o,i,s)}))}return i=i?i.then(s,s):s()}}function x(n,t){var e=n.iterator[t.method];if(void 0===e){if(t.delegate=null,"throw"===t.method){if(n.iterator.return&&(t.method="return",t.arg=void 0,x(n,t),"throw"===t.method))return d;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=p(e,n.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,d;var i=r.arg;return i?i.done?(t[n.resultName]=i.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,d):i:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,d)}function _(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function S(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function T(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(_,this),this.reset(!0)}function j(n){if(n){var t=n[o];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,i=function t(){for(;++r<n.length;)if(e.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return i.next=i}}return{next:C}}function C(){return{value:void 0,done:!0}}return h.prototype=m,l(y,"constructor",m),l(m,"constructor",h),h.displayName=l(m,c,"GeneratorFunction"),n.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,c,"GeneratorFunction")),n.prototype=Object.create(y),n},n.awrap=function(n){return{__await:n}},w(k.prototype),l(k.prototype,s,(function(){return this})),n.AsyncIterator=k,n.async=function(t,e,r,i,a){void 0===a&&(a=Promise);var o=new k(u(t,e,r,i),a);return n.isGeneratorFunction(e)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},w(y),l(y,c,"Generator"),l(y,o,(function(){return this})),l(y,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var t=[];for(var e in n)t.push(e);return t.reverse(),function e(){for(;t.length;){var r=t.pop();if(r in n)return e.value=r,e.done=!1,e}return e.done=!0,e}},n.values=j,T.prototype={constructor:T,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(S),!n)for(var t in this)"t"===t.charAt(0)&&e.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function r(e,r){return o.type="throw",o.arg=n,t.next=e,r&&(t.method="next",t.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],o=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=e.call(a,"catchLoc"),c=e.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,t){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&e.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=n,o.arg=t,a?(this.method="next",this.next=a.finallyLoc,d):this.complete(o)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),d},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.finallyLoc===n)return this.complete(e.completion,e.afterLoc),S(e),d}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.tryLoc===n){var r=e.completion;if("throw"===r.type){var i=r.arg;S(e)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,e){return this.delegate={iterator:j(n),resultName:t,nextLoc:e},"next"===this.method&&(this.arg=void 0),d}},n}},function(n,t,e){"use strict";e.d(t,"a",(function(){return r}));e(65),e(78),e(5),e(100),e(22),e(25);function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}},function(n,t,e){e(386),e(387)},function(n,t,e){var r=e(3),i=e(24),a=e(68),o=r(r.bind);n.exports=function(n,t){return i(n),void 0===t?n:a?o(n,t):function(){return n.apply(t,arguments)}}},function(n,t,e){var r=e(62),i=e(3),a=e(67),o=e(16),s=e(20),c=e(114),l=i([].push),u=function(n){var t=1==n,e=2==n,i=3==n,u=4==n,p=6==n,d=7==n,f=5==n||p;return function(h,m,v,g){for(var b,y,w=o(h),k=a(w),x=r(m,v),_=s(k),S=0,T=g||c,j=t?T(h,_):e||d?T(h,0):void 0;_>S;S++)if((f||S in k)&&(y=x(b=k[S],S,w),n))if(t)j[S]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return S;case 2:l(j,b)}else switch(n){case 4:return!1;case 7:l(j,b)}return p?-1:i||u?u:j}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,t,e){var r=e(165),i=e(122).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,t,e){e(264),e(268),e(269),e(130),e(270)},function(n,t,e){var r=e(80),i=e(295),a=e(296),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,t,e){var r=e(0),i=e(3),a=e(2),o=e(28),s=r.Object,c=i("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?c(n,""):s(n)}:s},function(n,t,e){var r=e(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,t,e){var r=e(0),i=e(14),a=e(4),o=e(36),s=e(161),c=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var t=i("Symbol");return a(t)&&o(t.prototype,c(n))}},function(n,t,e){var r=e(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,t){n.exports={}},function(n,t){n.exports={}},function(n,t,e){var r=e(8),i=e(9),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,t,e){var r=e(3),i=e(10),a=e(247);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,t=!1,e={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(e,[]),t=e instanceof Array}catch(n){}return function(e,r){return i(e),a(r),t?n(e,r):e.__proto__=r,e}}():void 0)},function(n,t,e){var r=e(3);n.exports=r([].slice)},function(n,t,e){var r=e(0),i=e(57),a=e(4),o=e(112),s=e(95),c=e(6),l=e(255),u=e(17),p=e(55),d=i&&i.prototype,f=c("species"),h=!1,m=a(r.PromiseRejectionEvent),v=o("Promise",(function(){var n=s(i),t=n!==String(i);if(!t&&66===p)return!0;if(u&&(!d.catch||!d.finally))return!0;if(p>=51&&/native code/.test(n))return!1;var e=new i((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(e.constructor={})[f]=r,!(h=e.then((function(){}))instanceof r)||!t&&l&&!m}));n.exports={CONSTRUCTOR:v,REJECTION_EVENT:m,SUBCLASSING:h}},function(n,t,e){"use strict";var r=e(24),i=function(n){var t,e;this.promise=new n((function(n,r){if(void 0!==t||void 0!==e)throw TypeError("Bad Promise constructor");t=n,e=r})),this.resolve=r(t),this.reject=r(e)};n.exports.f=function(n){return new i(n)}},function(n,t,e){"use strict";var r=e(1),i=e(8),a=e(0),o=e(3),s=e(9),c=e(4),l=e(36),u=e(12),p=e(13).f,d=e(124),f=a.Symbol,h=f&&f.prototype;if(i&&c(f)&&(!("description"in h)||void 0!==f().description)){var m={},v=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),t=l(h,this)?new f(n):void 0===n?f():f(n);return""===n&&(m[t]=!0),t};d(v,f),v.prototype=h,h.constructor=v;var g="Symbol(test)"==String(f("test")),b=o(h.toString),y=o(h.valueOf),w=/^Symbol\((.*)\)[^)]+$/,k=o("".replace),x=o("".slice);p(h,"description",{configurable:!0,get:function(){var n=y(this),t=b(n);if(s(m,n))return"";var e=g?x(t,7,-1):k(t,w,"$1");return""===e?void 0:e}}),r({global:!0,constructor:!0,forced:!0},{Symbol:v})}},function(n,t,e){var r=e(2),i=e(6),a=e(55),o=i("species");n.exports=function(n){return a>=51||!r((function(){var t=[];return(t.constructor={})[o]=function(){return{foo:1}},1!==t[n](Boolean).foo}))}},function(n,t,e){var r=e(32).Symbol;n.exports=r},function(n,t,e){"use strict";e.d(t,"a",(function(){return a}));e(88);var r=e(82);e(65),e(78),e(5),e(100),e(22),e(25),e(192);var i=e(108);e(38),e(23);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,t,e){"use strict";function r(n,t){(null==t||t>n.length)&&(t=n.length);for(var e=0,r=new Array(t);e<t;e++)r[e]=n[e];return r}e.d(t,"a",(function(){return r}))},function(n,t,e){"use strict";var r=e(1),i=e(0),a=e(2),o=e(51),s=e(11),c=e(16),l=e(20),u=e(58),p=e(114),d=e(79),f=e(6),h=e(55),m=f("isConcatSpreadable"),v=i.TypeError,g=h>=51||!a((function(){var n=[];return n[m]=!1,n.concat()[0]!==n})),b=d("concat"),y=function(n){if(!s(n))return!1;var t=n[m];return void 0!==t?!!t:o(n)};r({target:"Array",proto:!0,arity:1,forced:!g||!b},{concat:function(n){var t,e,r,i,a,o=c(this),s=p(o,0),d=0;for(t=-1,r=arguments.length;t<r;t++)if(y(a=-1===t?o:arguments[t])){if(d+(i=l(a))>9007199254740991)throw v("Maximum allowed index exceeded");for(e=0;e<i;e++,d++)e in a&&u(s,d,a[e])}else{if(d>=9007199254740991)throw v("Maximum allowed index exceeded");u(s,d++,a)}return s.length=d,s}})},function(n,t,e){"use strict";var r=e(1),i=e(3),a=e(121).indexOf,o=e(48),s=i([].indexOf),c=!!s&&1/s([1],1,-0)<0,l=o("indexOf");r({target:"Array",proto:!0,forced:c||!l},{indexOf:function(n){var t=arguments.length>1?arguments[1]:void 0;return c?s(this,n,t)||0:a(this,n,t)}})},function(n,t,e){"use strict";e(19);var r,i,a=e(1),o=e(0),s=e(7),c=e(3),l=e(4),u=e(11),p=(r=!1,(i=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&r),d=o.Error,f=c(/./.test);a({target:"RegExp",proto:!0,forced:!p},{test:function(n){var t=this.exec;if(!l(t))return f(this,n);var e=s(t,this,n);if(null!==e&&!u(e))throw new d("RegExp exec method returned something other than an Object or null");return!!e}})},function(n,t,e){var r=e(0),i=e(127),a=e(4),o=e(28),s=e(6)("toStringTag"),c=r.Object,l="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var t,e,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(e=function(n,t){try{return n[t]}catch(n){}}(t=c(n),s))?e:l?o(t):"Object"==(r=o(t))&&a(t.callee)?"Arguments":r}},function(n,t,e){var r=e(8),i=e(73).EXISTS,a=e(3),o=e(13).f,s=Function.prototype,c=a(s.toString),l=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=a(l.exec);r&&!i&&o(s,"name",{configurable:!0,get:function(){try{return u(l,c(this))[1]}catch(n){return""}}})},function(n,t,e){e(1)({target:"Array",stat:!0},{isArray:e(51)})},function(n,t,e){var r=e(3),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,t,e){var r=e(0),i=e(11),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,t,e){var r=e(164),i=e(69);n.exports=function(n){var t=r(n,"string");return i(t)?t:t+""}},function(n,t,e){var r=e(165),i=e(122);n.exports=Object.keys||function(n){return r(n,i)}},function(n,t,e){var r=e(47),i=Math.max,a=Math.min;n.exports=function(n,t){var e=r(n);return e<0?i(e+t,0):a(e,t)}},function(n,t,e){var r=e(53),i=e(89),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,t,e){var r=e(3),i=e(4),a=e(119),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,t){t.f=Object.getOwnPropertySymbols},function(n,t,e){var r=e(28),i=e(0);n.exports="process"==r(i.process)},function(n,t,e){var r=e(3),i=e(2),a=e(4),o=e(86),s=e(14),c=e(95),l=function(){},u=[],p=s("Reflect","construct"),d=/^\s*(?:class|function)\b/,f=r(d.exec),h=!d.exec(l),m=function(n){if(!a(n))return!1;try{return p(l,u,n),!0}catch(n){return!1}},v=function(n){if(!a(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!f(d,c(n))}catch(n){return!0}};v.sham=!0,n.exports=!p||i((function(){var n;return m(m.call)||!m(Object)||!m((function(){n=!0}))||n}))?v:m},function(n,t,e){var r=e(265),i=e(9),a=e(182),o=e(13).f;n.exports=function(n){var t=r.Symbol||(r.Symbol={});i(t,n)||o(t,n,{value:a.f(n)})}},function(n,t,e){e(99)("iterator")},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(5);function r(n,t,e,r,i,a,o){try{var s=n[a](o),c=s.value}catch(n){return void e(n)}s.done?t(c):Promise.resolve(c).then(r,i)}function i(n){return function(){var t=this,e=arguments;return new Promise((function(i,a){var o=n.apply(t,e);function s(n){r(o,i,a,s,c,"next",n)}function c(n){r(o,i,a,s,c,"throw",n)}s(void 0)}))}}},function(n,t,e){"use strict";var r,i,a=e(7),o=e(3),s=e(12),c=e(193),l=e(115),u=e(53),p=e(35),d=e(39).get,f=e(228),h=e(234),m=u("native-string-replace",String.prototype.replace),v=RegExp.prototype.exec,g=v,b=o("".charAt),y=o("".indexOf),w=o("".replace),k=o("".slice),x=(i=/b*/g,a(v,r=/a/,"a"),a(v,i,"a"),0!==r.lastIndex||0!==i.lastIndex),_=l.BROKEN_CARET,S=void 0!==/()??/.exec("")[1];(x||S||_||f||h)&&(g=function(n){var t,e,r,i,o,l,u,f=this,h=d(f),T=s(n),j=h.raw;if(j)return j.lastIndex=f.lastIndex,t=a(g,j,T),f.lastIndex=j.lastIndex,t;var C=h.groups,I=_&&f.sticky,A=a(c,f),O=f.source,E=0,L=T;if(I&&(A=w(A,"y",""),-1===y(A,"g")&&(A+="g"),L=k(T,f.lastIndex),f.lastIndex>0&&(!f.multiline||f.multiline&&"\n"!==b(T,f.lastIndex-1))&&(O="(?: "+O+")",L=" "+L,E++),e=new RegExp("^(?:"+O+")",A)),S&&(e=new RegExp("^"+O+"$(?!\\s)",A)),x&&(r=f.lastIndex),i=a(v,I?e:f,L),I?i?(i.input=k(i.input,E),i[0]=k(i[0],E),i.index=f.lastIndex,f.lastIndex+=i[0].length):f.lastIndex=0:x&&i&&(f.lastIndex=f.global?i.index+i[0].length:r),S&&i&&i.length>1&&a(m,i[0],e,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&C)for(i.groups=l=p(null),o=0;o<C.length;o++)l[(u=C[o])[0]]=i[u[1]];return i}),n.exports=g},function(n,t,e){var r=e(300),i=e(301),a=e(302),o=e(303),s=e(304);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(197);n.exports=function(n,t){for(var e=n.length;e--;)if(r(n[e][0],t))return e;return-1}},function(n,t,e){var r=e(42)(Object,"create");n.exports=r},function(n,t,e){var r=e(322);n.exports=function(n,t){var e=n.__data__;return r(t)?e["string"==typeof t?"string":"hash"]:e.map}},function(n,t,e){var r=e(142);n.exports=function(n){if("string"==typeof n||r(n))return n;var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(43),e(5),e(87),e(192),e(22),e(19),e(85);var r=e(82);function i(n,t){if(n){if("string"==typeof n)return Object(r.a)(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(n):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?Object(r.a)(n,t):void 0}}},function(n,t,e){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,t,e={version:"0.2.0"},r=e.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,t,e){return n<t?t:n>e?e:n}function a(n){return 100*(-1+n)}e.configure=function(n){var t,e;for(t in n)void 0!==(e=n[t])&&n.hasOwnProperty(t)&&(r[t]=e);return this},e.status=null,e.set=function(n){var t=e.isStarted();n=i(n,r.minimum,1),e.status=1===n?null:n;var c=e.render(!t),l=c.querySelector(r.barSelector),u=r.speed,p=r.easing;return c.offsetWidth,o((function(t){""===r.positionUsing&&(r.positionUsing=e.getPositioningCSS()),s(l,function(n,t,e){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+t+"ms "+e,i}(n,u,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){e.remove(),t()}),u)}),u)):setTimeout(t,u)})),this},e.isStarted=function(){return"number"==typeof e.status},e.start=function(){e.status||e.set(0);var n=function(){setTimeout((function(){e.status&&(e.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},e.done=function(n){return n||e.status?e.inc(.3+.5*Math.random()).set(1):this},e.inc=function(n){var t=e.status;return t?("number"!=typeof n&&(n=(1-t)*i(Math.random()*t,.1,.95)),t=i(t+n,0,.994),e.set(t)):e.start()},e.trickle=function(){return e.inc(Math.random()*r.trickleRate)},n=0,t=0,e.promise=function(r){return r&&"resolved"!==r.state()?(0===t&&e.start(),n++,t++,r.always((function(){0==--t?(n=0,e.done()):e.set((n-t)/n)})),this):this},e.render=function(n){if(e.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=r.template;var i,o=t.querySelector(r.barSelector),c=n?"-100":a(e.status||0),u=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(i=t.querySelector(r.spinnerSelector))&&d(i),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(t),t},e.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},e.isRendered=function(){return!!document.getElementById("nprogress")},e.getPositioningCSS=function(){var n=document.body.style,t="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return t+"Perspective"in n?"translate3d":t+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function t(){var e=n.shift();e&&e(t)}return function(e){n.push(e),1==n.length&&t()}}(),s=function(){var n=["Webkit","O","Moz","ms"],t={};function e(e){return e=e.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,t){return t.toUpperCase()})),t[e]||(t[e]=function(t){var e=document.body.style;if(t in e)return t;for(var r,i=n.length,a=t.charAt(0).toUpperCase()+t.slice(1);i--;)if((r=n[i]+a)in e)return r;return t}(e))}function r(n,t,r){t=e(t),n.style[t]=r}return function(n,t){var e,i,a=arguments;if(2==a.length)for(e in t)void 0!==(i=t[e])&&t.hasOwnProperty(e)&&r(n,e,i);else r(n,a[1],a[2])}}();function c(n,t){return("string"==typeof n?n:p(n)).indexOf(" "+t+" ")>=0}function l(n,t){var e=p(n),r=e+t;c(e,t)||(n.className=r.substring(1))}function u(n,t){var e,r=p(n);c(n,t)&&(e=r.replace(" "+t+" "," "),n.className=e.substring(1,e.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return e})?r.call(t,e,t,n):r)||(n.exports=i)},function(n,t,e){var r=e(1),i=e(16),a=e(92);r({target:"Object",stat:!0,forced:e(2)((function(){a(1)}))},{keys:function(n){return a(i(n))}})},function(n,t,e){var r=e(1),i=e(8),a=e(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!i},{defineProperty:a})},function(n,t,e){var r=e(2),i=e(4),a=/#|\.prototype\./,o=function(n,t){var e=c[s(n)];return e==u||e!=l&&(i(t)?r(t):!!t)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},c=o.data={},l=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,t,e){var r=e(86),i=e(49),a=e(72),o=e(6)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||a[r(n)]}},function(n,t,e){var r=e(267);n.exports=function(n,t){return new(r(n))(0===t?0:t)}},function(n,t,e){var r=e(2),i=e(0).RegExp,a=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=a||r((function(){return!i("a","y").sticky})),s=a||r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:o,UNSUPPORTED_Y:a}},function(n,t,e){"use strict";e(19);var r=e(3),i=e(15),a=e(102),o=e(2),s=e(6),c=e(29),l=s("species"),u=RegExp.prototype;n.exports=function(n,t,e,p){var d=s(n),f=!o((function(){var t={};return t[d]=function(){return 7},7!=""[n](t)})),h=f&&!o((function(){var t=!1,e=/a/;return"split"===n&&((e={}).constructor={},e.constructor[l]=function(){return e},e.flags="",e[d]=/./[d]),e.exec=function(){return t=!0,null},e[d](""),!t}));if(!f||!h||e){var m=r(/./[d]),v=t(d,""[n],(function(n,t,e,i,o){var s=r(n),c=t.exec;return c===a||c===u.exec?f&&!o?{done:!0,value:m(t,e,i)}:{done:!0,value:s(e,t,i)}:{done:!1}}));i(String.prototype,n,v[0]),i(u,d,v[1])}p&&c(u[d],"sham",!0)}},function(n,t,e){var r=e(0),i=e(7),a=e(10),o=e(4),s=e(28),c=e(102),l=r.TypeError;n.exports=function(n,t){var e=n.exec;if(o(e)){var r=i(e,n,t);return null!==r&&a(r),r}if("RegExp"===s(n))return i(c,n,t);throw l("RegExp#exec called on incompatible receiver")}},function(n,t,e){"use strict";var r=e(1),i=e(3),a=e(67),o=e(21),s=e(48),c=i([].join),l=a!=Object,u=s("join",",");r({target:"Array",proto:!0,forced:l||!u},{join:function(n){return c(o(this),void 0===n?",":n)}})},function(n,t,e){var r=e(0),i=e(120),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,t,e){var r=e(0),i=Object.defineProperty;n.exports=function(n,t){try{i(r,n,{value:t,configurable:!0,writable:!0})}catch(e){r[n]=t}return t}},function(n,t,e){var r=e(21),i=e(93),a=e(20),o=function(n){return function(t,e,o){var s,c=r(t),l=a(c),u=i(o,l);if(n&&e!=e){for(;l>u;)if((s=c[u++])!=s)return!0}else for(;l>u;u++)if((n||u in c)&&c[u]===e)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,t){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,t,e){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);t.f=a?function(n){var t=i(this,n);return!!t&&t.enumerable}:r},function(n,t,e){var r=e(9),i=e(169),a=e(40),o=e(13);n.exports=function(n,t,e){for(var s=i(t),c=o.f,l=a.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||e&&r(e,p)||c(n,p,l(t,p))}}},function(n,t,e){var r=e(0),i=e(9),a=e(4),o=e(16),s=e(94),c=e(171),l=s("IE_PROTO"),u=r.Object,p=u.prototype;n.exports=c?u.getPrototypeOf:function(n){var t=o(n);if(i(t,l))return t[l];var e=t.constructor;return a(e)&&t instanceof e?e.prototype:t instanceof u?p:null}},function(n,t,e){var r=e(10),i=e(172),a=e(6)("species");n.exports=function(n,t){var e,o=r(n).constructor;return void 0===o||null==(e=r(o)[a])?t:i(e)}},function(n,t,e){var r={};r[e(6)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,t){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,t,e){var r=e(0),i=e(93),a=e(20),o=e(58),s=r.Array,c=Math.max;n.exports=function(n,t,e){for(var r=a(n),l=i(t,r),u=i(void 0===e?r:e,r),p=s(c(u-l,0)),d=0;l<u;l++,d++)o(p,d,n[l]);return p.length=d,p}},function(n,t,e){var r=e(1),i=e(14),a=e(41),o=e(7),s=e(3),c=e(2),l=e(51),u=e(4),p=e(11),d=e(69),f=e(75),h=e(54),m=i("JSON","stringify"),v=s(/./.exec),g=s("".charAt),b=s("".charCodeAt),y=s("".replace),w=s(1..toString),k=/[\uD800-\uDFFF]/g,x=/^[\uD800-\uDBFF]$/,_=/^[\uDC00-\uDFFF]$/,S=!h||c((function(){var n=i("Symbol")();return"[null]"!=m([n])||"{}"!=m({a:n})||"{}"!=m(Object(n))})),T=c((function(){return'"\\udf06\\ud834"'!==m("\udf06\ud834")||'"\\udead"'!==m("\udead")})),j=function(n,t){var e=f(arguments),r=t;if((p(t)||void 0!==n)&&!d(n))return l(t)||(t=function(n,t){if(u(r)&&(t=o(r,this,n,t)),!d(t))return t}),e[1]=t,a(m,null,e)},C=function(n,t,e){var r=g(e,t-1),i=g(e,t+1);return v(x,n)&&!v(_,i)||v(_,n)&&!v(x,r)?"\\u"+w(b(n,0),16):n};m&&r({target:"JSON",stat:!0,arity:3,forced:S||T},{stringify:function(n,t,e){var r=f(arguments),i=a(S?j:m,null,r);return T&&"string"==typeof i?y(i,k,C):i}})},function(n,t,e){e(1)({target:"Object",stat:!0,sham:!e(8)},{create:e(35)})},function(n,t,e){var r=e(1),i=e(2),a=e(16),o=e(125),s=e(171);r({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!s},{getPrototypeOf:function(n){return o(a(n))}})},function(n,t,e){e(1)({target:"Object",stat:!0},{setPrototypeOf:e(74)})},function(n,t,e){"use strict";var r=e(184).charAt;n.exports=function(n,t,e){return t+(e?r(n,t).length:1)}},function(n,t,e){var r=e(294),i=e(52),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,t,e){var r=e(42)(e(32),"Map");n.exports=r},function(n,t){n.exports=function(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}},function(n,t,e){var r=e(314),i=e(321),a=e(323),o=e(324),s=e(325);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n){e[++t]=n})),e}},function(n,t){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,t,e){var r=e(30),i=e(142),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,t){if(r(n))return!1;var e=typeof n;return!("number"!=e&&"symbol"!=e&&"boolean"!=e&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=t&&n in Object(t))}},function(n,t,e){var r=e(66),i=e(52);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,t){n.exports=function(n){return n}},function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));e(88);e(65),e(78),e(5),e(100),e(22),e(25);var r=e(108);e(38),e(23);function i(n,t){return function(n){if(Array.isArray(n))return n}(n)||function(n,t){var e=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=e){var r,i,a=[],o=!0,s=!1;try{for(e=e.call(n);!(o=(r=e.next()).done)&&(a.push(r.value),!t||a.length!==t);o=!0);}catch(n){s=!0,i=n}finally{try{o||null==e.return||e.return()}finally{if(s)throw i}}return a}}(n,t)||Object(r.a)(n,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,t,e){"use strict";var r=e(41),i=e(7),a=e(3),o=e(116),s=e(155),c=e(10),l=e(18),u=e(126),p=e(134),d=e(56),f=e(12),h=e(49),m=e(129),v=e(117),g=e(102),b=e(115),y=e(2),w=b.UNSUPPORTED_Y,k=Math.min,x=[].push,_=a(/./.exec),S=a(x),T=a("".slice);o("split",(function(n,t,e){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,e){var a=f(l(this)),o=void 0===e?4294967295:e>>>0;if(0===o)return[];if(void 0===n)return[a];if(!s(n))return i(t,a,n,o);for(var c,u,p,d=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),v=0,b=new RegExp(n.source,h+"g");(c=i(g,b,a))&&!((u=b.lastIndex)>v&&(S(d,T(a,v,c.index)),c.length>1&&c.index<a.length&&r(x,d,m(c,1)),p=c[0].length,v=u,d.length>=o));)b.lastIndex===c.index&&b.lastIndex++;return v===a.length?!p&&_(b,"")||S(d,""):S(d,T(a,v)),d.length>o?m(d,0,o):d}:"0".split(void 0,0).length?function(n,e){return void 0===n&&0===e?[]:i(t,this,n,e)}:t,[function(t,e){var r=l(this),o=null==t?void 0:h(t,n);return o?i(o,t,r,e):i(a,f(r),t,e)},function(n,r){var i=c(this),o=f(n),s=e(a,i,o,r,a!==t);if(s.done)return s.value;var l=u(i,RegExp),h=i.unicode,m=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(w?"g":"y"),g=new l(w?"^(?:"+i.source+")":i,m),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===o.length)return null===v(g,o)?[o]:[];for(var y=0,x=0,_=[];x<o.length;){g.lastIndex=w?0:x;var j,C=v(g,w?T(o,x):o);if(null===C||(j=k(d(g.lastIndex+(w?x:0)),o.length))===y)x=p(o,x,h);else{if(S(_,T(o,y,x)),_.length===b)return _;for(var I=1;I<=C.length-1;I++)if(S(_,C[I]),_.length===b)return _;x=y=j}}return S(_,T(o,y)),_}]}),!!y((function(){var n=/(?:)/,t=n.exec;n.exec=function(){return t.apply(this,arguments)};var e="ab".split(n);return 2!==e.length||"a"!==e[0]||"b"!==e[1]})),w)},function(n,t,e){"use strict";var r=e(1),i=e(63).some;r({target:"Array",proto:!0,forced:!e(48)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r=e(7),i=e(116),a=e(10),o=e(56),s=e(12),c=e(18),l=e(49),u=e(134),p=e(117);i("match",(function(n,t,e){return[function(t){var e=c(this),i=null==t?void 0:l(t,n);return i?r(i,t,e):new RegExp(t)[n](s(e))},function(n){var r=a(this),i=s(n),c=e(t,r,i);if(c.done)return c.value;if(!r.global)return p(r,i);var l=r.unicode;r.lastIndex=0;for(var d,f=[],h=0;null!==(d=p(r,i));){var m=s(d[0]);f[h]=m,""===m&&(r.lastIndex=u(i,o(r.lastIndex),l)),h++}return 0===h?null:f}]}))},function(n,t,e){var r=e(6),i=e(35),a=e(13).f,o=r("unscopables"),s=Array.prototype;null==s[o]&&a(s,o,{configurable:!0,value:i(null)}),n.exports=function(n){s[o][n]=!0}},function(n,t,e){"use strict";var r=e(73).PROPER,i=e(15),a=e(10),o=e(12),s=e(2),c=e(239),l=RegExp.prototype.toString,u=s((function(){return"/a/b"!=l.call({source:"a",flags:"b"})})),p=r&&"toString"!=l.name;(u||p)&&i(RegExp.prototype,"toString",(function(){var n=a(this);return"/"+o(n.source)+"/"+o(c(n))}),{unsafe:!0})},function(n,t,e){"use strict";var r=e(21),i=e(148),a=e(72),o=e(39),s=e(13).f,c=e(167),l=e(17),u=e(8),p=o.set,d=o.getterFor("Array Iterator");n.exports=c(Array,"Array",(function(n,t){p(this,{type:"Array Iterator",target:r(n),index:0,kind:t})}),(function(){var n=d(this),t=n.target,e=n.kind,r=n.index++;return!t||r>=t.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==e?{value:r,done:!1}:"values"==e?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");var f=a.Arguments=a.Array;if(i("keys"),i("values"),i("entries"),!l&&u&&"values"!==f.name)try{s(f,"name",{value:"values"})}catch(n){}},function(n,t,e){var r=e(8),i=e(162),a=e(13),o=e(10),s=e(21),c=e(92);t.f=r&&!i?Object.defineProperties:function(n,t){o(n);for(var e,r=s(t),i=c(t),l=i.length,u=0;l>u;)a.f(n,e=i[u++],r[e]);return n}},function(n,t,e){var r=e(0).TypeError;n.exports=function(n,t){if(n<t)throw r("Not enough arguments");return n}},function(n,t,e){var r=e(0),i=e(7),a=e(24),o=e(10),s=e(70),c=e(113),l=r.TypeError;n.exports=function(n,t){var e=arguments.length<2?c(n):t;if(a(e))return o(i(e,n));throw l(s(n)+" is not iterable")}},function(n,t,e){var r=e(4),i=e(11),a=e(74);n.exports=function(n,t,e){var o,s;return a&&r(o=t.constructor)&&o!==e&&i(s=o.prototype)&&s!==e.prototype&&a(n,s),n}},function(n,t,e){var r=e(11),i=e(28),a=e(6)("match");n.exports=function(n){var t;return r(n)&&(void 0!==(t=n[a])?!!t:"RegExp"==i(n))}},function(n,t){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,t){var e=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return l.Date.now()};function h(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=h(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(e,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,t,e){var r,i,a,o,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(t){var e=r,a=i;return r=i=void 0,l=t,o=n.apply(a,e)}function y(n){return l=n,s=setTimeout(k,t),u?b(n):o}function w(n){var e=n-c;return void 0===c||e>=t||e<0||v&&n-l>=a}function k(){var n=f();if(w(n))return x(n);s=setTimeout(k,function(n){var e=t-(n-c);return v?d(e,a-(n-l)):e}(n))}function x(n){return s=void 0,g&&r?b(n):(r=i=void 0,o)}function _(){var n=f(),e=w(n);if(r=arguments,i=this,c=n,e){if(void 0===s)return y(c);if(v)return s=setTimeout(k,t),b(c)}return void 0===s&&(s=setTimeout(k,t)),o}return t=m(t)||0,h(e)&&(u=!!e.leading,a=(v="maxWait"in e)?p(m(e.maxWait)||0,t):a,g="trailing"in e?!!e.trailing:g),_.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=i=s=void 0},_.flush=function(){return void 0===s?o:x(f())},_}},function(n,t,e){var r=e(3),i=e(18),a=e(12),o=e(159),s=r("".replace),c="["+o+"]",l=RegExp("^"+c+c+"*"),u=RegExp(c+c+"*$"),p=function(n){return function(t){var e=a(i(t));return 1&n&&(e=s(e,l,"")),2&n&&(e=s(e,u,"")),e}};n.exports={start:p(1),end:p(2),trim:p(3)}},function(n,t){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,t,e){var r=e(3),i=e(15),a=Date.prototype,o=r(a.toString),s=r(a.getTime);"Invalid Date"!=String(new Date(NaN))&&i(a,"toString",(function(){var n=s(this);return n==n?o(this):"Invalid Date"}))},function(n,t,e){var r=e(54);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,t,e){var r=e(8),i=e(2);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,t,e){var r=e(8),i=e(2),a=e(90);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,t,e){var r=e(0),i=e(7),a=e(11),o=e(69),s=e(49),c=e(244),l=e(6),u=r.TypeError,p=l("toPrimitive");n.exports=function(n,t){if(!a(n)||o(n))return n;var e,r=s(n,p);if(r){if(void 0===t&&(t="default"),e=i(r,n,t),!a(e)||o(e))return e;throw u("Can't convert object to primitive value")}return void 0===t&&(t="number"),c(n,t)}},function(n,t,e){var r=e(3),i=e(9),a=e(21),o=e(121).indexOf,s=e(71),c=r([].push);n.exports=function(n,t){var e,r=a(n),l=0,u=[];for(e in r)!i(s,e)&&i(r,e)&&c(u,e);for(;t.length>l;)i(r,e=t[l++])&&(~o(u,e)||c(u,e));return u}},function(n,t,e){var r=e(14);n.exports=r("document","documentElement")},function(n,t,e){"use strict";var r=e(1),i=e(7),a=e(17),o=e(73),s=e(4),c=e(229),l=e(125),u=e(74),p=e(37),d=e(29),f=e(15),h=e(6),m=e(72),v=e(170),g=o.PROPER,b=o.CONFIGURABLE,y=v.IteratorPrototype,w=v.BUGGY_SAFARI_ITERATORS,k=h("iterator"),x=function(){return this};n.exports=function(n,t,e,o,h,v,_){c(e,t,o);var S,T,j,C=function(n){if(n===h&&L)return L;if(!w&&n in O)return O[n];switch(n){case"keys":case"values":case"entries":return function(){return new e(this,n)}}return function(){return new e(this)}},I=t+" Iterator",A=!1,O=n.prototype,E=O[k]||O["@@iterator"]||h&&O[h],L=!w&&E||C(h),z="Array"==t&&O.entries||E;if(z&&(S=l(z.call(new n)))!==Object.prototype&&S.next&&(a||l(S)===y||(u?u(S,y):s(S[k])||f(S,k,x)),p(S,I,!0,!0),a&&(m[I]=x)),g&&"values"==h&&E&&"values"!==E.name&&(!a&&b?d(O,"name","values"):(A=!0,L=function(){return i(E,this)})),h)if(T={values:C("values"),keys:v?L:C("keys"),entries:C("entries")},_)for(j in T)(w||A||!(j in O))&&f(O,j,T[j]);else r({target:t,proto:!0,forced:w||A},T);return a&&!_||O[k]===L||f(O,k,L,{name:h}),m[t]=L,T}},function(n,t,e){var r=e(2),i=e(4),a=e(9),o=e(8),s=e(73).CONFIGURABLE,c=e(95),l=e(39),u=l.enforce,p=l.get,d=Object.defineProperty,f=o&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),h=String(String).split("String"),m=n.exports=function(n,t,e){"Symbol("===String(t).slice(0,7)&&(t="["+String(t).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),e&&e.getter&&(t="get "+t),e&&e.setter&&(t="set "+t),(!a(n,"name")||s&&n.name!==t)&&d(n,"name",{value:t,configurable:!0}),f&&e&&a(e,"arity")&&n.length!==e.arity&&d(n,"length",{value:e.arity});try{e&&a(e,"constructor")&&e.constructor?o&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return a(r,"source")||(r.source=h.join("string"==typeof t?t:"")),n};Function.prototype.toString=m((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(n,t,e){var r=e(14),i=e(3),a=e(64),o=e(96),s=e(10),c=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var t=a.f(s(n)),e=o.f;return e?c(t,e(n)):t}},function(n,t,e){"use strict";var r,i,a,o=e(2),s=e(4),c=e(35),l=e(125),u=e(15),p=e(6),d=e(17),f=p("iterator"),h=!1;[].keys&&("next"in(a=[].keys())?(i=l(l(a)))!==Object.prototype&&(r=i):h=!0),null==r||o((function(){var n={};return r[f].call(n)!==n}))?r={}:d&&(r=c(r)),s(r[f])||u(r,f,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,t,e){var r=e(2);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,t,e){var r=e(0),i=e(98),a=e(70),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a constructor")}},function(n,t,e){var r,i,a,o,s=e(0),c=e(41),l=e(62),u=e(4),p=e(9),d=e(2),f=e(166),h=e(75),m=e(90),v=e(152),g=e(174),b=e(97),y=s.setImmediate,w=s.clearImmediate,k=s.process,x=s.Dispatch,_=s.Function,S=s.MessageChannel,T=s.String,j=0,C={};try{r=s.location}catch(n){}var I=function(n){if(p(C,n)){var t=C[n];delete C[n],t()}},A=function(n){return function(){I(n)}},O=function(n){I(n.data)},E=function(n){s.postMessage(T(n),r.protocol+"//"+r.host)};y&&w||(y=function(n){v(arguments.length,1);var t=u(n)?n:_(n),e=h(arguments,1);return C[++j]=function(){c(t,void 0,e)},i(j),j},w=function(n){delete C[n]},b?i=function(n){k.nextTick(A(n))}:x&&x.now?i=function(n){x.now(A(n))}:S&&!g?(o=(a=new S).port2,a.port1.onmessage=O,i=l(o.postMessage,o)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!d(E)?(i=E,s.addEventListener("message",O,!1)):i="onreadystatechange"in m("script")?function(n){f.appendChild(m("script")).onreadystatechange=function(){f.removeChild(this),I(n)}}:function(n){setTimeout(A(n),0)}),n.exports={set:y,clear:w}},function(n,t,e){var r=e(31);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,t,e){var r=e(0),i=e(62),a=e(7),o=e(10),s=e(70),c=e(176),l=e(20),u=e(36),p=e(153),d=e(113),f=e(177),h=r.TypeError,m=function(n,t){this.stopped=n,this.result=t},v=m.prototype;n.exports=function(n,t,e){var r,g,b,y,w,k,x,_=e&&e.that,S=!(!e||!e.AS_ENTRIES),T=!(!e||!e.IS_ITERATOR),j=!(!e||!e.INTERRUPTED),C=i(t,_),I=function(n){return r&&f(r,"normal",n),new m(!0,n)},A=function(n){return S?(o(n),j?C(n[0],n[1],I):C(n[0],n[1])):j?C(n,I):C(n)};if(T)r=n;else{if(!(g=d(n)))throw h(s(n)+" is not iterable");if(c(g)){for(b=0,y=l(n);y>b;b++)if((w=A(n[b]))&&u(v,w))return w;return new m(!1)}r=p(n,g)}for(k=r.next;!(x=a(k,r)).done;){try{w=A(x.value)}catch(n){f(r,"throw",n)}if("object"==typeof w&&w&&u(v,w))return w}return new m(!1)}},function(n,t,e){var r=e(6),i=e(72),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,t,e){var r=e(7),i=e(10),a=e(49);n.exports=function(n,t,e){var o,s;i(n);try{if(!(o=a(n,"return"))){if("throw"===t)throw e;return e}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===t)throw e;if(s)throw o;return i(o),e}},function(n,t,e){var r=e(57),i=e(179),a=e(76).CONSTRUCTOR;n.exports=a||!i((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,t,e){var r=e(6)("iterator"),i=!1;try{var a=0,o={next:function(){return{done:!!a++}},return:function(){i=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,t){if(!t&&!i)return!1;var e=!1;try{var a={};a[r]=function(){return{next:function(){return{done:e=!0}}}},n(a)}catch(n){}return e}},function(n,t,e){var r=e(10),i=e(11),a=e(77);n.exports=function(n,t){if(r(n),i(t)&&t.constructor===n)return t;var e=a.f(n);return(0,e.resolve)(t),e.promise}},function(n,t,e){var r=e(28),i=e(21),a=e(64).f,o=e(129),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return a(n)}catch(n){return o(s)}}(n):a(i(n))}},function(n,t,e){var r=e(6);t.f=r},function(n,t,e){var r=e(54);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,t,e){var r=e(3),i=e(47),a=e(12),o=e(18),s=r("".charAt),c=r("".charCodeAt),l=r("".slice),u=function(n){return function(t,e){var r,u,p=a(o(t)),d=i(e),f=p.length;return d<0||d>=f?n?"":void 0:(r=c(p,d))<55296||r>56319||d+1===f||(u=c(p,d+1))<56320||u>57343?n?s(p,d):r:n?l(p,d,d+2):u-56320+(r-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,t){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,t,e){var r=e(90)("span").classList,i=r&&r.constructor&&r.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,t,e){var r=e(12);n.exports=function(n,t){return void 0===n?arguments.length<2?"":t:r(n)}},function(n,t,e){"use strict";var r=e(63).forEach,i=e(48)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,t,e){var r=e(0),i=e(155),a=r.TypeError;n.exports=function(n){if(i(n))throw a("The method doesn't accept regular expressions");return n}},function(n,t,e){var r=e(6)("match");n.exports=function(n){var t=/./;try{"/./"[n](t)}catch(e){try{return t[r]=!1,"/./"[n](t)}catch(n){}}return!1}},function(n,t,e){var r=e(2);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,t,e){var r=e(1),i=e(289);r({target:"Array",stat:!0,forced:!e(179)((function(n){Array.from(n)}))},{from:i})},function(n,t,e){"use strict";var r=e(10);n.exports=function(){var n=r(this),t="";return n.hasIndices&&(t+="d"),n.global&&(t+="g"),n.ignoreCase&&(t+="i"),n.multiline&&(t+="m"),n.dotAll&&(t+="s"),n.unicode&&(t+="u"),n.sticky&&(t+="y"),t}},function(n,t){n.exports=function(n,t){for(var e=-1,r=t.length,i=n.length;++e<r;)n[i+e]=t[e];return n}},function(n,t){var e="object"==typeof global&&global&&global.Object===Object&&global;n.exports=e},function(n,t,e){var r=e(103),i=e(305),a=e(306),o=e(307),s=e(308),c=e(309);function l(n){var t=this.__data__=new r(n);this.size=t.size}l.prototype.clear=i,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,t){n.exports=function(n,t){return n===t||n!=n&&t!=t}},function(n,t,e){var r=e(66),i=e(137);n.exports=function(n){if(!i(n))return!1;var t=r(n);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}},function(n,t){var e=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return e.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,t,e){var r=e(326),i=e(52);n.exports=function n(t,e,a,o,s){return t===e||(null==t||null==e||!i(t)&&!i(e)?t!=t&&e!=e:r(t,e,a,o,n,s))}},function(n,t,e){var r=e(202),i=e(329),a=e(203);n.exports=function(n,t,e,o,s,c){var l=1&e,u=n.length,p=t.length;if(u!=p&&!(l&&p>u))return!1;var d=c.get(n),f=c.get(t);if(d&&f)return d==t&&f==n;var h=-1,m=!0,v=2&e?new r:void 0;for(c.set(n,t),c.set(t,n);++h<u;){var g=n[h],b=t[h];if(o)var y=l?o(b,g,h,t,n,c):o(g,b,h,n,t,c);if(void 0!==y){if(y)continue;m=!1;break}if(v){if(!i(t,(function(n,t){if(!a(v,t)&&(g===n||s(g,n,e,o,c)))return v.push(t)}))){m=!1;break}}else if(g!==b&&!s(g,b,e,o,c)){m=!1;break}}return c.delete(n),c.delete(t),m}},function(n,t,e){var r=e(138),i=e(327),a=e(328);function o(n){var t=-1,e=null==n?0:n.length;for(this.__data__=new r;++t<e;)this.add(n[t])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,t){n.exports=function(n,t){return n.has(t)}},function(n,t,e){var r=e(339),i=e(345),a=e(208);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,t,e){(function(n){var r=e(32),i=e(341),a=t&&!t.nodeType&&t,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;n.exports=c}).call(this,e(156)(n))},function(n,t){var e=/^(?:0|[1-9]\d*)$/;n.exports=function(n,t){var r=typeof n;return!!(t=null==t?9007199254740991:t)&&("number"==r||"symbol"!=r&&e.test(n))&&n>-1&&n%1==0&&n<t}},function(n,t,e){var r=e(342),i=e(343),a=e(344),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,t,e){var r=e(198),i=e(140);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,t,e){var r=e(42)(e(32),"Set");n.exports=r},function(n,t,e){var r=e(137);n.exports=function(n){return n==n&&!r(n)}},function(n,t){n.exports=function(n,t){return function(e){return null!=e&&(e[n]===t&&(void 0!==t||n in Object(e)))}}},function(n,t,e){var r=e(213),i=e(107);n.exports=function(n,t){for(var e=0,a=(t=r(t,n)).length;null!=n&&e<a;)n=n[i(t[e++])];return e&&e==a?n:void 0}},function(n,t,e){var r=e(30),i=e(141),a=e(356),o=e(359);n.exports=function(n,t){return r(n)?n:i(n,t)?[n]:a(o(n))}},function(n,t,e){var r=e(0),i=e(41),a=e(4),o=e(31),s=e(75),c=e(152),l=/MSIE .\./.test(o),u=r.Function,p=function(n){return l?function(t,e){var r=c(arguments.length,1)>2,o=a(t)?t:u(t),l=r?s(arguments,2):void 0;return n(r?function(){i(o,this,l)}:o,e)}:n};n.exports={setTimeout:p(r.setTimeout),setInterval:p(r.setInterval)}},function(n,t,e){"use strict";var r=e(0),i=e(3),a=e(24),o=e(11),s=e(9),c=e(75),l=e(68),u=r.Function,p=i([].concat),d=i([].join),f={},h=function(n,t,e){if(!s(f,t)){for(var r=[],i=0;i<t;i++)r[i]="a["+i+"]";f[t]=u("C,a","return new C("+d(r,",")+")")}return f[t](n,e)};n.exports=l?u.bind:function(n){var t=a(this),e=t.prototype,r=c(arguments,1),i=function(){var e=p(r,c(arguments));return this instanceof i?h(t,e.length,e):t.apply(n,e)};return o(e)&&(i.prototype=e),i}},function(n,t,e){"use strict";var r=e(1),i=e(393).start;r({target:"String",proto:!0,forced:e(395)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(1),i=e(14),a=e(41),o=e(215),s=e(172),c=e(10),l=e(11),u=e(35),p=e(2),d=i("Reflect","construct"),f=Object.prototype,h=[].push,m=p((function(){function n(){}return!(d((function(){}),[],n)instanceof n)})),v=!p((function(){d((function(){}))})),g=m||v;r({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,t){s(n),c(t);var e=arguments.length<3?n:s(arguments[2]);if(v&&!m)return d(n,t,e);if(n==e){switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3])}var r=[null];return a(h,r,t),new(a(o,n,r))}var i=e.prototype,p=u(l(i)?i:f),g=a(n,p,t);return l(g)?g:p}})},function(n,t,e){var r=e(1),i=e(0),a=e(37);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(292),i=e(297),a=e(368),o=e(376),s=e(385),c=e(237),l=a((function(n){var t=c(n);return s(t)&&(t=void 0),o(r(n,1,s,!0),i(t,2))}));n.exports=l},function(n,t,e){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var t,e=""+n,i=r.exec(e);if(!i)return e;var a="",o=0,s=0;for(o=i.index;o<e.length;o++){switch(e.charCodeAt(o)){case 34:t="&quot;";break;case 38:t="&amp;";break;case 39:t="&#39;";break;case 60:t="&lt;";break;case 62:t="&gt;";break;default:continue}s!==o&&(a+=e.substring(s,o)),s=o+1,a+=t}return s!==o?a+e.substring(s,o):a}},function(n,t,e){"use strict";e.r(t);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(e(396),e(33)),a=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);t.default=a.exports},function(n,t,e){"use strict";e.r(t);e(26),e(5),e(27),e(45),e(34);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(t,e){return""===t.componentOptions.propsData.active&&(n.activeCodeTabIndex=e),{title:t.componentOptions.propsData.title,elm:t.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(e(397),e(33)),a=Object(i.a)(r,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(t){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);t.default=a.exports},function(n,t,e){"use strict";var r=e(8),i=e(0),a=e(3),o=e(112),s=e(15),c=e(9),l=e(154),u=e(36),p=e(69),d=e(164),f=e(2),h=e(64).f,m=e(40).f,v=e(13).f,g=e(392),b=e(158).trim,y=i.Number,w=y.prototype,k=i.TypeError,x=a("".slice),_=a("".charCodeAt),S=function(n){var t=d(n,"number");return"bigint"==typeof t?t:T(t)},T=function(n){var t,e,r,i,a,o,s,c,l=d(n,"number");if(p(l))throw k("Cannot convert a Symbol value to a number");if("string"==typeof l&&l.length>2)if(l=b(l),43===(t=_(l,0))||45===t){if(88===(e=_(l,2))||120===e)return NaN}else if(48===t){switch(_(l,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+l}for(o=(a=x(l,2)).length,s=0;s<o;s++)if((c=_(a,s))<48||c>i)return NaN;return parseInt(a,r)}return+l};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var j,C=function(n){var t=arguments.length<1?0:y(S(n)),e=this;return u(w,e)&&f((function(){g(e)}))?l(Object(t),e,C):t},I=r?h(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),A=0;I.length>A;A++)c(y,j=I[A])&&!c(C,j)&&v(C,j,m(y,j));C.prototype=w,w.constructor=C,s(i,"Number",C,{constructor:!0})}},function(n,t,e){var r=e(2),i=e(0).RegExp;n.exports=r((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,t,e){"use strict";var r=e(170).IteratorPrototype,i=e(35),a=e(50),o=e(37),s=e(72),c=function(){return this};n.exports=function(n,t,e,l){var u=t+" Iterator";return n.prototype=i(r,{next:a(+!l,e)}),o(n,u,!1,!0),s[u]=c,n}},function(n,t,e){"use strict";var r=e(14),i=e(13),a=e(6),o=e(8),s=a("species");n.exports=function(n){var t=r(n),e=i.f;o&&t&&!t[s]&&e(t,s,{configurable:!0,get:function(){return this}})}},function(n,t,e){var r=e(0),i=e(36),a=r.TypeError;n.exports=function(n,t){if(i(t,n))return n;throw a("Incorrect invocation")}},function(n,t,e){var r=e(13).f;n.exports=function(n,t,e){e in n||r(n,e,{configurable:!0,get:function(){return t[e]},set:function(n){t[e]=n}})}},function(n,t,e){var r=e(1),i=e(8),a=e(169),o=e(21),s=e(40),c=e(58);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var t,e,r=o(n),i=s.f,l=a(r),u={},p=0;l.length>p;)void 0!==(e=i(r,t=l[p++]))&&c(u,t,e);return u}})},function(n,t,e){var r=e(2),i=e(0).RegExp;n.exports=r((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,t,e){"use strict";var r=e(1),i=e(121).includes,a=e(2),o=e(148);r({target:"Array",proto:!0,forced:a((function(){return!Array(1).includes()}))},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,t,e){"use strict";var r=e(1),i=e(3),a=e(189),o=e(18),s=e(12),c=e(190),l=i("".indexOf);r({target:"String",proto:!0,forced:!c("includes")},{includes:function(n){return!!~l(s(o(this)),s(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,t){n.exports=function(n){var t=null==n?0:n.length;return t?n[t-1]:void 0}},function(n,t,e){"use strict";var r=e(1),i=e(158).trim;r({target:"String",proto:!0,forced:e(390)("trim")},{trim:function(){return i(this)}})},function(n,t,e){var r=e(7),i=e(9),a=e(36),o=e(193),s=RegExp.prototype;n.exports=function(n){var t=n.flags;return void 0!==t||"flags"in s||i(n,"flags")||!a(s,n)?t:r(o,n)}},function(n,t,e){var r=e(129),i=Math.floor,a=function(n,t){var e=n.length,c=i(e/2);return e<8?o(n,t):s(n,a(r(n,0,c),t),a(r(n,c),t),t)},o=function(n,t){for(var e,r,i=n.length,a=1;a<i;){for(r=a,e=n[a];r&&t(n[r-1],e)>0;)n[r]=n[--r];r!==a++&&(n[r]=e)}return n},s=function(n,t,e,r){for(var i=t.length,a=e.length,o=0,s=0;o<i||s<a;)n[o+s]=o<i&&s<a?r(t[o],e[s])<=0?t[o++]:e[s++]:o<i?t[o++]:e[s++];return n};n.exports=a},function(n,t,e){var r=e(0),i=e(8),a=e(115).MISSED_STICKY,o=e(28),s=e(242),c=e(39).get,l=RegExp.prototype,u=r.TypeError;i&&a&&s(l,"sticky",{configurable:!0,get:function(){if(this!==l){if("RegExp"===o(this))return!!c(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,t,e){var r=e(168),i=e(13);n.exports=function(n,t,e){return e.get&&r(e.get,t,{getter:!0}),e.set&&r(e.set,t,{setter:!0}),i.f(n,t,e)}},function(n,t,e){n.exports=e(407)},function(n,t,e){var r=e(0),i=e(7),a=e(4),o=e(11),s=r.TypeError;n.exports=function(n,t){var e,r;if("string"===t&&a(e=n.toString)&&!o(r=i(e,n)))return r;if(a(e=n.valueOf)&&!o(r=i(e,n)))return r;if("string"!==t&&a(e=n.toString)&&!o(r=i(e,n)))return r;throw s("Can't convert object to primitive value")}},function(n,t){var e=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var t=+n;return(t>0?r:e)(t)}},function(n,t,e){var r=e(0),i=e(4),a=e(95),o=r.WeakMap;n.exports=i(o)&&/native code/.test(a(o))},function(n,t,e){var r=e(0),i=e(4),a=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,t,e){e(249),e(256),e(257),e(258),e(259),e(260)},function(n,t,e){"use strict";var r,i,a,o=e(1),s=e(17),c=e(97),l=e(0),u=e(7),p=e(15),d=e(74),f=e(37),h=e(230),m=e(24),v=e(4),g=e(11),b=e(231),y=e(126),w=e(173).set,k=e(250),x=e(253),_=e(128),S=e(254),T=e(39),j=e(57),C=e(76),I=e(77),A=C.CONSTRUCTOR,O=C.REJECTION_EVENT,E=C.SUBCLASSING,L=T.getterFor("Promise"),z=T.set,M=j&&j.prototype,R=j,P=M,B=l.TypeError,N=l.document,D=l.process,$=I.f,U=$,F=!!(N&&N.createEvent&&l.dispatchEvent),q=function(n){var t;return!(!g(n)||!v(t=n.then))&&t},V=function(n,t){var e,r,i,a=t.value,o=1==t.state,s=o?n.ok:n.fail,c=n.resolve,l=n.reject,p=n.domain;try{s?(o||(2===t.rejection&&K(t),t.rejection=1),!0===s?e=a:(p&&p.enter(),e=s(a),p&&(p.exit(),i=!0)),e===n.promise?l(B("Promise-chain cycle")):(r=q(e))?u(r,e,c,l):c(e)):l(a)}catch(n){p&&!i&&p.exit(),l(n)}},J=function(n,t){n.notified||(n.notified=!0,k((function(){for(var e,r=n.reactions;e=r.get();)V(e,n);n.notified=!1,t&&!n.rejection&&G(n)})))},W=function(n,t,e){var r,i;F?((r=N.createEvent("Event")).promise=t,r.reason=e,r.initEvent(n,!1,!0),l.dispatchEvent(r)):r={promise:t,reason:e},!O&&(i=l["on"+n])?i(r):"unhandledrejection"===n&&x("Unhandled promise rejection",e)},G=function(n){u(w,l,(function(){var t,e=n.facade,r=n.value;if(H(n)&&(t=_((function(){c?D.emit("unhandledRejection",r,e):W("unhandledrejection",e,r)})),n.rejection=c||H(n)?2:1,t.error))throw t.value}))},H=function(n){return 1!==n.rejection&&!n.parent},K=function(n){u(w,l,(function(){var t=n.facade;c?D.emit("rejectionHandled",t):W("rejectionhandled",t,n.value)}))},X=function(n,t,e){return function(r){n(t,r,e)}},Q=function(n,t,e){n.done||(n.done=!0,e&&(n=e),n.value=t,n.state=2,J(n,!0))},Y=function(n,t,e){if(!n.done){n.done=!0,e&&(n=e);try{if(n.facade===t)throw B("Promise can't be resolved itself");var r=q(t);r?k((function(){var e={done:!1};try{u(r,t,X(Y,e,n),X(Q,e,n))}catch(t){Q(e,t,n)}})):(n.value=t,n.state=1,J(n,!1))}catch(t){Q({done:!1},t,n)}}};if(A&&(P=(R=function(n){b(this,P),m(n),u(r,this);var t=L(this);try{n(X(Y,t),X(Q,t))}catch(n){Q(t,n)}}).prototype,(r=function(n){z(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new S,rejection:!1,state:0,value:void 0})}).prototype=p(P,"then",(function(n,t){var e=L(this),r=$(y(this,R));return e.parent=!0,r.ok=!v(n)||n,r.fail=v(t)&&t,r.domain=c?D.domain:void 0,0==e.state?e.reactions.add(r):k((function(){V(r,e)})),r.promise})),i=function(){var n=new r,t=L(n);this.promise=n,this.resolve=X(Y,t),this.reject=X(Q,t)},I.f=$=function(n){return n===R||void 0===n?new i(n):U(n)},!s&&v(j)&&M!==Object.prototype)){a=M.then,E||p(M,"then",(function(n,t){var e=this;return new R((function(n,t){u(a,e,n,t)})).then(n,t)}),{unsafe:!0});try{delete M.constructor}catch(n){}d&&d(M,P)}o({global:!0,constructor:!0,wrap:!0,forced:A},{Promise:R}),f(R,"Promise",!1,!0),h("Promise")},function(n,t,e){var r,i,a,o,s,c,l,u,p=e(0),d=e(62),f=e(40).f,h=e(173).set,m=e(174),v=e(251),g=e(252),b=e(97),y=p.MutationObserver||p.WebKitMutationObserver,w=p.document,k=p.process,x=p.Promise,_=f(p,"queueMicrotask"),S=_&&_.value;S||(r=function(){var n,t;for(b&&(n=k.domain)&&n.exit();i;){t=i.fn,i=i.next;try{t()}catch(n){throw i?o():a=void 0,n}}a=void 0,n&&n.enter()},m||b||g||!y||!w?!v&&x&&x.resolve?((l=x.resolve(void 0)).constructor=x,u=d(l.then,l),o=function(){u(r)}):b?o=function(){k.nextTick(r)}:(h=d(h,p),o=function(){h(r)}):(s=!0,c=w.createTextNode(""),new y(r).observe(c,{characterData:!0}),o=function(){c.data=s=!s})),n.exports=S||function(n){var t={fn:n,next:void 0};a&&(a.next=t),i||(i=t,o()),a=t}},function(n,t,e){var r=e(31),i=e(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==i.Pebble},function(n,t,e){var r=e(31);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,t,e){var r=e(0);n.exports=function(n,t){var e=r.console;e&&e.error&&(1==arguments.length?e.error(n):e.error(n,t))}},function(n,t){var e=function(){this.head=null,this.tail=null};e.prototype={add:function(n){var t={item:n,next:null};this.head?this.tail.next=t:this.head=t,this.tail=t},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=e},function(n,t){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,t,e){"use strict";var r=e(1),i=e(7),a=e(24),o=e(77),s=e(128),c=e(175);r({target:"Promise",stat:!0,forced:e(178)},{all:function(n){var t=this,e=o.f(t),r=e.resolve,l=e.reject,u=s((function(){var e=a(t.resolve),o=[],s=0,u=1;c(n,(function(n){var a=s++,c=!1;u++,i(e,t,n).then((function(n){c||(c=!0,o[a]=n,--u||r(o))}),l)})),--u||r(o)}));return u.error&&l(u.value),e.promise}})},function(n,t,e){"use strict";var r=e(1),i=e(17),a=e(76).CONSTRUCTOR,o=e(57),s=e(14),c=e(4),l=e(15),u=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(n){return this.then(void 0,n)}}),!i&&c(o)){var p=s("Promise").prototype.catch;u.catch!==p&&l(u,"catch",p,{unsafe:!0})}},function(n,t,e){"use strict";var r=e(1),i=e(7),a=e(24),o=e(77),s=e(128),c=e(175);r({target:"Promise",stat:!0,forced:e(178)},{race:function(n){var t=this,e=o.f(t),r=e.reject,l=s((function(){var o=a(t.resolve);c(n,(function(n){i(o,t,n).then(e.resolve,r)}))}));return l.error&&r(l.value),e.promise}})},function(n,t,e){"use strict";var r=e(1),i=e(7),a=e(77);r({target:"Promise",stat:!0,forced:e(76).CONSTRUCTOR},{reject:function(n){var t=a.f(this);return i(t.reject,void 0,n),t.promise}})},function(n,t,e){"use strict";var r=e(1),i=e(14),a=e(17),o=e(57),s=e(76).CONSTRUCTOR,c=e(180),l=i("Promise"),u=a&&!s;r({target:"Promise",stat:!0,forced:a||s},{resolve:function(n){return c(u&&this===l?o:this,n)}})},function(n,t,e){var r=e(1),i=e(262);r({target:"Object",stat:!0,arity:2,forced:Object.assign!==i},{assign:i})},function(n,t,e){"use strict";var r=e(8),i=e(3),a=e(7),o=e(2),s=e(92),c=e(96),l=e(123),u=e(16),p=e(67),d=Object.assign,f=Object.defineProperty,h=i([].concat);n.exports=!d||o((function(){if(r&&1!==d({b:1},d(f({},"a",{enumerable:!0,get:function(){f(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},t={},e=Symbol();return n[e]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){t[n]=n})),7!=d({},n)[e]||"abcdefghijklmnopqrst"!=s(d({},t)).join("")}))?function(n,t){for(var e=u(n),i=arguments.length,o=1,d=c.f,f=l.f;i>o;)for(var m,v=p(arguments[o++]),g=d?h(s(v),d(v)):s(v),b=g.length,y=0;b>y;)m=g[y++],r&&!a(f,v,m)||(e[m]=v[m]);return e}:d},function(n,t,e){"use strict";var r=e(1),i=e(17),a=e(57),o=e(2),s=e(14),c=e(4),l=e(126),u=e(180),p=e(15),d=a&&a.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&o((function(){d.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var t=l(this,s("Promise")),e=c(n);return this.then(e?function(e){return u(t,n()).then((function(){return e}))}:n,e?function(e){return u(t,n()).then((function(){throw e}))}:n)}}),!i&&c(a)){var f=s("Promise").prototype.finally;d.finally!==f&&p(d,"finally",f,{unsafe:!0})}},function(n,t,e){"use strict";var r=e(1),i=e(0),a=e(7),o=e(3),s=e(17),c=e(8),l=e(54),u=e(2),p=e(9),d=e(36),f=e(10),h=e(21),m=e(91),v=e(12),g=e(50),b=e(35),y=e(92),w=e(64),k=e(181),x=e(96),_=e(40),S=e(13),T=e(151),j=e(123),C=e(15),I=e(53),A=e(94),O=e(71),E=e(89),L=e(6),z=e(182),M=e(99),R=e(266),P=e(37),B=e(39),N=e(63).forEach,D=A("hidden"),$=B.set,U=B.getterFor("Symbol"),F=Object.prototype,q=i.Symbol,V=q&&q.prototype,J=i.TypeError,W=i.QObject,G=_.f,H=S.f,K=k.f,X=j.f,Q=o([].push),Y=I("symbols"),Z=I("op-symbols"),nn=I("wks"),tn=!W||!W.prototype||!W.prototype.findChild,en=c&&u((function(){return 7!=b(H({},"a",{get:function(){return H(this,"a",{value:7}).a}})).a}))?function(n,t,e){var r=G(F,t);r&&delete F[t],H(n,t,e),r&&n!==F&&H(F,t,r)}:H,rn=function(n,t){var e=Y[n]=b(V);return $(e,{type:"Symbol",tag:n,description:t}),c||(e.description=t),e},an=function(n,t,e){n===F&&an(Z,t,e),f(n);var r=m(t);return f(e),p(Y,r)?(e.enumerable?(p(n,D)&&n[D][r]&&(n[D][r]=!1),e=b(e,{enumerable:g(0,!1)})):(p(n,D)||H(n,D,g(1,{})),n[D][r]=!0),en(n,r,e)):H(n,r,e)},on=function(n,t){f(n);var e=h(t),r=y(e).concat(un(e));return N(r,(function(t){c&&!a(sn,e,t)||an(n,t,e[t])})),n},sn=function(n){var t=m(n),e=a(X,this,t);return!(this===F&&p(Y,t)&&!p(Z,t))&&(!(e||!p(this,t)||!p(Y,t)||p(this,D)&&this[D][t])||e)},cn=function(n,t){var e=h(n),r=m(t);if(e!==F||!p(Y,r)||p(Z,r)){var i=G(e,r);return!i||!p(Y,r)||p(e,D)&&e[D][r]||(i.enumerable=!0),i}},ln=function(n){var t=K(h(n)),e=[];return N(t,(function(n){p(Y,n)||p(O,n)||Q(e,n)})),e},un=function(n){var t=n===F,e=K(t?Z:h(n)),r=[];return N(e,(function(n){!p(Y,n)||t&&!p(F,n)||Q(r,Y[n])})),r};l||(C(V=(q=function(){if(d(V,this))throw J("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?v(arguments[0]):void 0,t=E(n),e=function(n){this===F&&a(e,Z,n),p(this,D)&&p(this[D],t)&&(this[D][t]=!1),en(this,t,g(1,n))};return c&&tn&&en(F,t,{configurable:!0,set:e}),rn(t,n)}).prototype,"toString",(function(){return U(this).tag})),C(q,"withoutSetter",(function(n){return rn(E(n),n)})),j.f=sn,S.f=an,T.f=on,_.f=cn,w.f=k.f=ln,x.f=un,z.f=function(n){return rn(L(n),n)},c&&(H(V,"description",{configurable:!0,get:function(){return U(this).description}}),s||C(F,"propertyIsEnumerable",sn,{unsafe:!0}))),r({global:!0,constructor:!0,wrap:!0,forced:!l,sham:!l},{Symbol:q}),N(y(nn),(function(n){M(n)})),r({target:"Symbol",stat:!0,forced:!l},{useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!l,sham:!c},{create:function(n,t){return void 0===t?b(n):on(b(n),t)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:cn}),r({target:"Object",stat:!0,forced:!l},{getOwnPropertyNames:ln}),R(),P(q,"Symbol"),O[D]=!0},function(n,t,e){var r=e(0);n.exports=r},function(n,t,e){var r=e(7),i=e(14),a=e(6),o=e(15);n.exports=function(){var n=i("Symbol"),t=n&&n.prototype,e=t&&t.valueOf,s=a("toPrimitive");t&&!t[s]&&o(t,s,(function(n){return r(e,this)}),{arity:1})}},function(n,t,e){var r=e(0),i=e(51),a=e(98),o=e(11),s=e(6)("species"),c=r.Array;n.exports=function(n){var t;return i(n)&&(t=n.constructor,(a(t)&&(t===c||i(t.prototype))||o(t)&&null===(t=t[s]))&&(t=void 0)),void 0===t?c:t}},function(n,t,e){var r=e(1),i=e(14),a=e(9),o=e(12),s=e(53),c=e(183),l=s("string-to-symbol-registry"),u=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!c},{for:function(n){var t=o(n);if(a(l,t))return l[t];var e=i("Symbol")(t);return l[t]=e,u[e]=t,e}})},function(n,t,e){var r=e(1),i=e(9),a=e(69),o=e(70),s=e(53),c=e(183),l=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!c},{keyFor:function(n){if(!a(n))throw TypeError(o(n)+" is not a symbol");if(i(l,n))return l[n]}})},function(n,t,e){var r=e(1),i=e(54),a=e(2),o=e(96),s=e(16);r({target:"Object",stat:!0,forced:!i||a((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var t=o.f;return t?t(s(n)):[]}})},function(n,t,e){"use strict";var r=e(127),i=e(86);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,t,e){e(99)("asyncIterator")},function(n,t,e){var r=e(14),i=e(99),a=e(37);i("toStringTag"),a(r("Symbol"),"Symbol")},function(n,t,e){var r=e(0);e(37)(r.JSON,"JSON",!0)},function(n,t,e){e(37)(Math,"Math",!0)},function(n,t,e){"use strict";var r=e(14),i=e(9),a=e(29),o=e(36),s=e(74),c=e(124),l=e(232),u=e(154),p=e(187),d=e(277),f=e(278),h=e(279),m=e(8),v=e(17);n.exports=function(n,t,e,g){var b=g?2:1,y=n.split("."),w=y[y.length-1],k=r.apply(null,y);if(k){var x=k.prototype;if(!v&&i(x,"cause")&&delete x.cause,!e)return k;var _=r("Error"),S=t((function(n,t){var e=p(g?t:n,void 0),r=g?new k(n):new k;return void 0!==e&&a(r,"message",e),h&&a(r,"stack",f(r.stack,2)),this&&o(x,this)&&u(r,this,S),arguments.length>b&&d(r,arguments[b]),r}));if(S.prototype=x,"Error"!==w?s?s(S,_):c(S,_,{name:!0}):m&&"stackTraceLimit"in k&&(l(S,k,"stackTraceLimit"),l(S,k,"prepareStackTrace")),c(S,k),!v)try{x.name!==w&&a(x,"name",w),x.constructor=S}catch(n){}return S}}},function(n,t,e){var r=e(11),i=e(29);n.exports=function(n,t){r(t)&&"cause"in t&&i(n,"cause",t.cause)}},function(n,t,e){var r=e(3),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(o);n.exports=function(n,t){if(c&&"string"==typeof n&&!i.prepareStackTrace)for(;t--;)n=a(n,s,"");return n}},function(n,t,e){var r=e(2),i=e(50);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,t,e){"use strict";var r=e(8),i=e(2),a=e(10),o=e(35),s=e(187),c=Error.prototype.toString,l=i((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==c.call(n))return!0}return"2: 1"!==c.call({message:1,name:2})||"Error"!==c.call({})}));n.exports=l?function(){var n=a(this),t=s(n.name,"Error"),e=s(n.message);return t?e?t+": "+e:t:e}:c},function(n,t,e){"use strict";var r=e(1),i=e(3),a=e(51),o=i([].reverse),s=[1,2];r({target:"Array",proto:!0,forced:String(s)===String(s.reverse())},{reverse:function(){return a(this)&&(this.length=this.length),o(this)}})},function(n,t,e){"use strict";var r=e(1),i=e(283).left,a=e(48),o=e(55),s=e(97);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var t=arguments.length;return i(this,n,t,t>1?arguments[1]:void 0)}})},function(n,t,e){var r=e(0),i=e(24),a=e(16),o=e(67),s=e(20),c=r.TypeError,l=function(n){return function(t,e,r,l){i(e);var u=a(t),p=o(u),d=s(u),f=n?d-1:0,h=n?-1:1;if(r<2)for(;;){if(f in p){l=p[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw c("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in p&&(l=e(l,p[f],f,u));return l}};n.exports={left:l(!1),right:l(!0)}},function(n,t,e){"use strict";var r,i=e(1),a=e(3),o=e(40).f,s=e(56),c=e(12),l=e(189),u=e(18),p=e(190),d=e(17),f=a("".startsWith),h=a("".slice),m=Math.min,v=p("startsWith");i({target:"String",proto:!0,forced:!!(d||v||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!v},{startsWith:function(n){var t=c(u(this));l(n);var e=s(m(arguments.length>1?arguments[1]:void 0,t.length)),r=c(n);return f?f(t,r,e):h(t,e,e+r.length)===r}})},function(n,t,e){var r=e(1),i=e(191),a=e(2),o=e(11),s=e(286).onFreeze,c=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){c(1)})),sham:!i},{freeze:function(n){return c&&o(n)?c(s(n)):n}})},function(n,t,e){var r=e(1),i=e(3),a=e(71),o=e(11),s=e(9),c=e(13).f,l=e(64),u=e(181),p=e(287),d=e(89),f=e(191),h=!1,m=d("meta"),v=0,g=function(n){c(n,m,{value:{objectID:"O"+v++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=l.f,t=i([].splice),e={};e[m]=1,n(e).length&&(l.f=function(e){for(var r=n(e),i=0,a=r.length;i<a;i++)if(r[i]===m){t(r,i,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,t){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,m)){if(!p(n))return"F";if(!t)return"E";g(n)}return n[m].objectID},getWeakData:function(n,t){if(!s(n,m)){if(!p(n))return!0;if(!t)return!1;g(n)}return n[m].weakData},onFreeze:function(n){return f&&h&&p(n)&&!s(n,m)&&g(n),n}};a[m]=!0},function(n,t,e){var r=e(2),i=e(11),a=e(28),o=e(288),s=Object.isExtensible,c=r((function(){s(1)}));n.exports=c||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=a(n))&&(!s||s(n)))}:s},function(n,t,e){var r=e(2);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,t,e){"use strict";var r=e(0),i=e(62),a=e(7),o=e(16),s=e(290),c=e(176),l=e(98),u=e(20),p=e(58),d=e(153),f=e(113),h=r.Array;n.exports=function(n){var t=o(n),e=l(this),r=arguments.length,m=r>1?arguments[1]:void 0,v=void 0!==m;v&&(m=i(m,r>2?arguments[2]:void 0));var g,b,y,w,k,x,_=f(t),S=0;if(!_||this==h&&c(_))for(g=u(t),b=e?new this(g):h(g);g>S;S++)x=v?m(t[S],S):t[S],p(b,S,x);else for(k=(w=d(t,_)).next,b=e?new this:[];!(y=a(k,w)).done;S++)x=v?s(w,m,[y.value,S],!0):y.value,p(b,S,x);return b.length=S,b}},function(n,t,e){var r=e(10),i=e(177);n.exports=function(n,t,e,a){try{return a?t(r(e)[0],e[1]):t(e)}catch(t){i(n,"throw",t)}}},function(n,t,e){var r=e(3),i=e(16),a=Math.floor,o=r("".charAt),s=r("".replace),c=r("".slice),l=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,t,e,r,p,d){var f=e+n.length,h=r.length,m=u;return void 0!==p&&(p=i(p),m=l),s(d,m,(function(i,s){var l;switch(o(s,0)){case"$":return"$";case"&":return n;case"`":return c(t,0,e);case"'":return c(t,f);case"<":l=p[c(s,1,-1)];break;default:var u=+s;if(0===u)return i;if(u>h){var d=a(u/10);return 0===d?i:d<=h?void 0===r[d-1]?o(s,1):r[d-1]+o(s,1):i}l=r[u-1]}return void 0===l?"":l}))}},function(n,t,e){var r=e(194),i=e(293);n.exports=function n(t,e,a,o,s){var c=-1,l=t.length;for(a||(a=i),s||(s=[]);++c<l;){var u=t[c];e>0&&a(u)?e>1?n(u,e-1,a,o,s):r(s,u):o||(s[s.length]=u)}return s}},function(n,t,e){var r=e(80),i=e(135),a=e(30),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,t,e){var r=e(66),i=e(52);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,t,e){var r=e(80),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var t=a.call(n,s),e=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(t?n[s]=e:delete n[s]),i}},function(n,t){var e=Object.prototype.toString;n.exports=function(n){return e.call(n)}},function(n,t,e){var r=e(298),i=e(354),a=e(143),o=e(30),s=e(365);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,t,e){var r=e(299),i=e(353),a=e(211);n.exports=function(n){var t=i(n);return 1==t.length&&t[0][2]?a(t[0][0],t[0][1]):function(e){return e===n||r(e,n,t)}}},function(n,t,e){var r=e(196),i=e(200);n.exports=function(n,t,e,a){var o=e.length,s=o,c=!a;if(null==n)return!s;for(n=Object(n);o--;){var l=e[o];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++o<s;){var u=(l=e[o])[0],p=n[u],d=l[1];if(c&&l[2]){if(void 0===p&&!(u in n))return!1}else{var f=new r;if(a)var h=a(p,d,u,n,t,f);if(!(void 0===h?i(d,p,3,a,f):h))return!1}}return!0}},function(n,t){n.exports=function(){this.__data__=[],this.size=0}},function(n,t,e){var r=e(104),i=Array.prototype.splice;n.exports=function(n){var t=this.__data__,e=r(t,n);return!(e<0)&&(e==t.length-1?t.pop():i.call(t,e,1),--this.size,!0)}},function(n,t,e){var r=e(104);n.exports=function(n){var t=this.__data__,e=r(t,n);return e<0?void 0:t[e][1]}},function(n,t,e){var r=e(104);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,t,e){var r=e(104);n.exports=function(n,t){var e=this.__data__,i=r(e,n);return i<0?(++this.size,e.push([n,t])):e[i][1]=t,this}},function(n,t,e){var r=e(103);n.exports=function(){this.__data__=new r,this.size=0}},function(n,t){n.exports=function(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e}},function(n,t){n.exports=function(n){return this.__data__.get(n)}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t,e){var r=e(103),i=e(136),a=e(138);n.exports=function(n,t){var e=this.__data__;if(e instanceof r){var o=e.__data__;if(!i||o.length<199)return o.push([n,t]),this.size=++e.size,this;e=this.__data__=new a(o)}return e.set(n,t),this.size=e.size,this}},function(n,t,e){var r=e(198),i=e(311),a=e(137),o=e(199),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,p=l.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?d:s).test(o(n))}},function(n,t,e){var r,i=e(312),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,t,e){var r=e(32)["__core-js_shared__"];n.exports=r},function(n,t){n.exports=function(n,t){return null==n?void 0:n[t]}},function(n,t,e){var r=e(315),i=e(103),a=e(136);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,t,e){var r=e(316),i=e(317),a=e(318),o=e(319),s=e(320);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=a,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(105);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,t){n.exports=function(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}},function(n,t,e){var r=e(105),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;if(r){var e=t[n];return"__lodash_hash_undefined__"===e?void 0:e}return i.call(t,n)?t[n]:void 0}},function(n,t,e){var r=e(105),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;return r?void 0!==t[n]:i.call(t,n)}},function(n,t,e){var r=e(105);n.exports=function(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=r&&void 0===t?"__lodash_hash_undefined__":t,this}},function(n,t,e){var r=e(106);n.exports=function(n){var t=r(this,n).delete(n);return this.size-=t?1:0,t}},function(n,t){n.exports=function(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}},function(n,t,e){var r=e(106);n.exports=function(n){return r(this,n).get(n)}},function(n,t,e){var r=e(106);n.exports=function(n){return r(this,n).has(n)}},function(n,t,e){var r=e(106);n.exports=function(n,t){var e=r(this,n),i=e.size;return e.set(n,t),this.size+=e.size==i?0:1,this}},function(n,t,e){var r=e(196),i=e(201),a=e(330),o=e(333),s=e(349),c=e(30),l=e(205),u=e(207),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,f,h,m){var v=c(n),g=c(t),b=v?"[object Array]":s(n),y=g?"[object Array]":s(t),w=(b="[object Arguments]"==b?p:b)==p,k=(y="[object Arguments]"==y?p:y)==p,x=b==y;if(x&&l(n)){if(!l(t))return!1;v=!0,w=!1}if(x&&!w)return m||(m=new r),v||u(n)?i(n,t,e,f,h,m):a(n,t,b,e,f,h,m);if(!(1&e)){var _=w&&d.call(n,"__wrapped__"),S=k&&d.call(t,"__wrapped__");if(_||S){var T=_?n.value():n,j=S?t.value():t;return m||(m=new r),h(T,j,e,f,m)}}return!!x&&(m||(m=new r),o(n,t,e,f,h,m))}},function(n,t){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length;++e<r;)if(t(n[e],e,n))return!0;return!1}},function(n,t,e){var r=e(80),i=e(331),a=e(197),o=e(201),s=e(332),c=e(139),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,t,e,r,l,p,d){switch(e){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=t.byteLength||!p(new i(n),new i(t)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=c),n.size!=t.size&&!h)return!1;var m=d.get(n);if(m)return m==t;r|=2,d.set(n,t);var v=o(f(n),f(t),r,l,p,d);return d.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(t)}return!1}},function(n,t,e){var r=e(32).Uint8Array;n.exports=r},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n,r){e[++t]=[r,n]})),e}},function(n,t,e){var r=e(334),i=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,a,o,s){var c=1&e,l=r(n),u=l.length;if(u!=r(t).length&&!c)return!1;for(var p=u;p--;){var d=l[p];if(!(c?d in t:i.call(t,d)))return!1}var f=s.get(n),h=s.get(t);if(f&&h)return f==t&&h==n;var m=!0;s.set(n,t),s.set(t,n);for(var v=c;++p<u;){var g=n[d=l[p]],b=t[d];if(a)var y=c?a(b,g,d,t,n,s):a(g,b,d,n,t,s);if(!(void 0===y?g===b||o(g,b,e,a,s):y)){m=!1;break}v||(v="constructor"==d)}if(m&&!v){var w=n.constructor,k=t.constructor;w==k||!("constructor"in n)||!("constructor"in t)||"function"==typeof w&&w instanceof w&&"function"==typeof k&&k instanceof k||(m=!1)}return s.delete(n),s.delete(t),m}},function(n,t,e){var r=e(335),i=e(336),a=e(204);n.exports=function(n){return r(n,a,i)}},function(n,t,e){var r=e(194),i=e(30);n.exports=function(n,t,e){var a=t(n);return i(n)?a:r(a,e(n))}},function(n,t,e){var r=e(337),i=e(338),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(t){return a.call(n,t)})))}:i;n.exports=s},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=0,a=[];++e<r;){var o=n[e];t(o,e,n)&&(a[i++]=o)}return a}},function(n,t){n.exports=function(){return[]}},function(n,t,e){var r=e(340),i=e(135),a=e(30),o=e(205),s=e(206),c=e(207),l=Object.prototype.hasOwnProperty;n.exports=function(n,t){var e=a(n),u=!e&&i(n),p=!e&&!u&&o(n),d=!e&&!u&&!p&&c(n),f=e||u||p||d,h=f?r(n.length,String):[],m=h.length;for(var v in n)!t&&!l.call(n,v)||f&&("length"==v||p&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,t){n.exports=function(n,t){for(var e=-1,r=Array(n);++e<n;)r[e]=t(e);return r}},function(n,t){n.exports=function(){return!1}},function(n,t,e){var r=e(66),i=e(140),a=e(52),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,t){n.exports=function(n){return function(t){return n(t)}}},function(n,t,e){(function(n){var r=e(195),i=t&&!t.nodeType&&t,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,e(156)(n))},function(n,t,e){var r=e(346),i=e(347),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var t=[];for(var e in Object(n))a.call(n,e)&&"constructor"!=e&&t.push(e);return t}},function(n,t){var e=Object.prototype;n.exports=function(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||e)}},function(n,t,e){var r=e(348)(Object.keys,Object);n.exports=r},function(n,t){n.exports=function(n,t){return function(e){return n(t(e))}}},function(n,t,e){var r=e(350),i=e(136),a=e(351),o=e(209),s=e(352),c=e(66),l=e(199),u=l(r),p=l(i),d=l(a),f=l(o),h=l(s),m=c;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||a&&"[object Promise]"!=m(a.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var t=c(n),e="[object Object]"==t?n.constructor:void 0,r=e?l(e):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return t}),n.exports=m},function(n,t,e){var r=e(42)(e(32),"DataView");n.exports=r},function(n,t,e){var r=e(42)(e(32),"Promise");n.exports=r},function(n,t,e){var r=e(42)(e(32),"WeakMap");n.exports=r},function(n,t,e){var r=e(210),i=e(204);n.exports=function(n){for(var t=i(n),e=t.length;e--;){var a=t[e],o=n[a];t[e]=[a,o,r(o)]}return t}},function(n,t,e){var r=e(200),i=e(355),a=e(362),o=e(141),s=e(210),c=e(211),l=e(107);n.exports=function(n,t){return o(n)&&s(t)?c(l(n),t):function(e){var o=i(e,n);return void 0===o&&o===t?a(e,n):r(t,o,3)}}},function(n,t,e){var r=e(212);n.exports=function(n,t,e){var i=null==n?void 0:r(n,t);return void 0===i?e:i}},function(n,t,e){var r=e(357),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(i,(function(n,e,r,i){t.push(r?i.replace(a,"$1"):e||n)})),t}));n.exports=o},function(n,t,e){var r=e(358);n.exports=function(n){var t=r(n,(function(n){return 500===e.size&&e.clear(),n})),e=t.cache;return t}},function(n,t,e){var r=e(138);function i(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new TypeError("Expected a function");var e=function(){var r=arguments,i=t?t.apply(this,r):r[0],a=e.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return e.cache=a.set(i,o)||a,o};return e.cache=new(i.Cache||r),e}i.Cache=r,n.exports=i},function(n,t,e){var r=e(360);n.exports=function(n){return null==n?"":r(n)}},function(n,t,e){var r=e(80),i=e(361),a=e(30),o=e(142),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(t){if("string"==typeof t)return t;if(a(t))return i(t,n)+"";if(o(t))return c?c.call(t):"";var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=Array(r);++e<r;)i[e]=t(n[e],e,n);return i}},function(n,t,e){var r=e(363),i=e(364);n.exports=function(n,t){return null!=n&&i(n,t,r)}},function(n,t){n.exports=function(n,t){return null!=n&&t in Object(n)}},function(n,t,e){var r=e(213),i=e(135),a=e(30),o=e(206),s=e(140),c=e(107);n.exports=function(n,t,e){for(var l=-1,u=(t=r(t,n)).length,p=!1;++l<u;){var d=c(t[l]);if(!(p=null!=n&&e(n,d)))break;n=n[d]}return p||++l!=u?p:!!(u=null==n?0:n.length)&&s(u)&&o(d,u)&&(a(n)||i(n))}},function(n,t,e){var r=e(366),i=e(367),a=e(141),o=e(107);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,t){n.exports=function(n){return function(t){return null==t?void 0:t[n]}}},function(n,t,e){var r=e(212);n.exports=function(n){return function(t){return r(t,n)}}},function(n,t,e){var r=e(143),i=e(369),a=e(371);n.exports=function(n,t){return a(i(n,t,r),n+"")}},function(n,t,e){var r=e(370),i=Math.max;n.exports=function(n,t,e){return t=i(void 0===t?n.length-1:t,0),function(){for(var a=arguments,o=-1,s=i(a.length-t,0),c=Array(s);++o<s;)c[o]=a[t+o];o=-1;for(var l=Array(t+1);++o<t;)l[o]=a[o];return l[t]=e(c),r(n,this,l)}}},function(n,t){n.exports=function(n,t,e){switch(e.length){case 0:return n.call(t);case 1:return n.call(t,e[0]);case 2:return n.call(t,e[0],e[1]);case 3:return n.call(t,e[0],e[1],e[2])}return n.apply(t,e)}},function(n,t,e){var r=e(372),i=e(375)(r);n.exports=i},function(n,t,e){var r=e(373),i=e(374),a=e(143),o=i?function(n,t){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(t),writable:!0})}:a;n.exports=o},function(n,t){n.exports=function(n){return function(){return n}}},function(n,t,e){var r=e(42),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,t){var e=Date.now;n.exports=function(n){var t=0,r=0;return function(){var i=e(),a=16-(i-r);if(r=i,a>0){if(++t>=800)return arguments[0]}else t=0;return n.apply(void 0,arguments)}}},function(n,t,e){var r=e(202),i=e(377),a=e(382),o=e(203),s=e(383),c=e(139);n.exports=function(n,t,e){var l=-1,u=i,p=n.length,d=!0,f=[],h=f;if(e)d=!1,u=a;else if(p>=200){var m=t?null:s(n);if(m)return c(m);d=!1,u=o,h=new r}else h=t?[]:f;n:for(;++l<p;){var v=n[l],g=t?t(v):v;if(v=e||0!==v?v:0,d&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;t&&h.push(g),f.push(v)}else u(h,g,e)||(h!==f&&h.push(g),f.push(v))}return f}},function(n,t,e){var r=e(378);n.exports=function(n,t){return!!(null==n?0:n.length)&&r(n,t,0)>-1}},function(n,t,e){var r=e(379),i=e(380),a=e(381);n.exports=function(n,t,e){return t==t?a(n,t,e):r(n,i,e)}},function(n,t){n.exports=function(n,t,e,r){for(var i=n.length,a=e+(r?1:-1);r?a--:++a<i;)if(t(n[a],a,n))return a;return-1}},function(n,t){n.exports=function(n){return n!=n}},function(n,t){n.exports=function(n,t,e){for(var r=e-1,i=n.length;++r<i;)if(n[r]===t)return r;return-1}},function(n,t){n.exports=function(n,t,e){for(var r=-1,i=null==n?0:n.length;++r<i;)if(e(t,n[r]))return!0;return!1}},function(n,t,e){var r=e(209),i=e(384),a=e(139),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,t){n.exports=function(){}},function(n,t,e){var r=e(208),i=e(52);n.exports=function(n){return i(n)&&r(n)}},function(n,t,e){var r=e(1),i=e(0),a=e(214).setInterval;r({global:!0,bind:!0,forced:i.setInterval!==a},{setInterval:a})},function(n,t,e){var r=e(1),i=e(0),a=e(214).setTimeout;r({global:!0,bind:!0,forced:i.setTimeout!==a},{setTimeout:a})},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(73).PROPER,i=e(2),a=e(159);n.exports=function(n){return i((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||r&&a[n].name!==n}))}},function(n,t,e){var r=e(1),i=e(215);r({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},function(n,t,e){var r=e(3);n.exports=r(1..valueOf)},function(n,t,e){var r=e(3),i=e(56),a=e(12),o=e(394),s=e(18),c=r(o),l=r("".slice),u=Math.ceil,p=function(n){return function(t,e,r){var o,p,d=a(s(t)),f=i(e),h=d.length,m=void 0===r?" ":a(r);return f<=h||""==m?d:((p=c(m,u((o=f-h)/m.length))).length>o&&(p=l(p,0,o)),n?d+p:p+d)}};n.exports={start:p(!1),end:p(!0)}},function(n,t,e){"use strict";var r=e(0),i=e(47),a=e(12),o=e(18),s=r.RangeError;n.exports=function(n){var t=a(o(this)),e="",r=i(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(t+=t))1&r&&(e+=t);return e}},function(n,t,e){var r=e(31);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,t,e){"use strict";e(217)},function(n,t,e){"use strict";e(218)},function(n,t,e){"use strict";var r=e(1),i=e(3),a=e(24),o=e(16),s=e(20),c=e(12),l=e(2),u=e(240),p=e(48),d=e(399),f=e(400),h=e(55),m=e(401),v=[],g=i(v.sort),b=i(v.push),y=l((function(){v.sort(void 0)})),w=l((function(){v.sort(null)})),k=p("sort"),x=!l((function(){if(h)return h<70;if(!(d&&d>3)){if(f)return!0;if(m)return m<603;var n,t,e,r,i="";for(n=65;n<76;n++){switch(t=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:e=3;break;case 68:case 71:e=4;break;default:e=2}for(r=0;r<47;r++)v.push({k:t+r,v:e})}for(v.sort((function(n,t){return t.v-n.v})),r=0;r<v.length;r++)t=v[r].k.charAt(0),i.charAt(i.length-1)!==t&&(i+=t);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:y||!w||!k||!x},{sort:function(n){void 0!==n&&a(n);var t=o(this);if(x)return void 0===n?g(t):g(t,n);var e,r,i=[],l=s(t);for(r=0;r<l;r++)r in t&&b(i,t[r]);for(u(i,function(n){return function(t,e){return void 0===e?-1:void 0===t?1:void 0!==n?+n(t,e)||0:c(t)>c(e)?1:-1}}(n)),e=i.length,r=0;r<e;)t[r]=i[r++];for(;r<l;)delete t[r++];return t}})},function(n,t,e){var r=e(31).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,t,e){var r=e(31);n.exports=/MSIE|Trident/.test(r)},function(n,t,e){var r=e(31).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,t,e){},function(n,t,e){},function(n,t,e){"use strict";var r=e(1),i=e(0),a=e(93),o=e(47),s=e(20),c=e(16),l=e(114),u=e(58),p=e(79)("splice"),d=i.TypeError,f=Math.max,h=Math.min;r({target:"Array",proto:!0,forced:!p},{splice:function(n,t){var e,r,i,p,m,v,g=c(this),b=s(g),y=a(n,b),w=arguments.length;if(0===w?e=r=0:1===w?(e=0,r=b-y):(e=w-2,r=h(f(o(t),0),b-y)),b+e-r>9007199254740991)throw d("Maximum allowed length exceeded");for(i=l(g,r),p=0;p<r;p++)(m=y+p)in g&&u(i,p,g[m]);if(i.length=r,e<r){for(p=y;p<b-r;p++)v=p+e,(m=p+r)in g?g[v]=g[m]:delete g[v];for(p=b;p>b-r+e;p--)delete g[p-1]}else if(e>r)for(p=b-r;p>y;p--)v=p+e-1,(m=p+r-1)in g?g[v]=g[m]:delete g[v];for(p=0;p<e;p++)g[p+y]=arguments[p+2];return g.length=b-r+e,i}})},function(n,t,e){"use strict";e(221)},function(n,t,e){"use strict";e(222)},function(n,t,e){"use strict";e.r(t);e(150),e(248),e(261),e(263);var r=e(59),i=e(101),a=(e(43),e(5),e(22),e(25),e(45),e(34),Object.freeze({}));function o(n){return null==n}function s(n){return null!=n}function c(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function f(n){return"[object RegExp]"===p.call(n)}function h(n){var t=parseFloat(String(n));return t>=0&&Math.floor(t)===t&&isFinite(n)}function m(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function g(n){var t=parseFloat(n);return isNaN(t)?n:t}function b(n,t){for(var e=Object.create(null),r=n.split(","),i=0;i<r.length;i++)e[r[i]]=!0;return t?function(n){return e[n.toLowerCase()]}:function(n){return e[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function w(n,t){if(n.length){var e=n.indexOf(t);if(e>-1)return n.splice(e,1)}}var k=Object.prototype.hasOwnProperty;function x(n,t){return k.call(n,t)}function _(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var S=/-(\w)/g,T=_((function(n){return n.replace(S,(function(n,t){return t?t.toUpperCase():""}))})),j=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,I=_((function(n){return n.replace(C,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,t){return n.bind(t)}:function(n,t){function e(e){var r=arguments.length;return r?r>1?n.apply(t,arguments):n.call(t,e):n.call(t)}return e._length=n.length,e};function O(n,t){t=t||0;for(var e=n.length-t,r=new Array(e);e--;)r[e]=n[e+t];return r}function E(n,t){for(var e in t)n[e]=t[e];return n}function L(n){for(var t={},e=0;e<n.length;e++)n[e]&&E(t,n[e]);return t}function z(n,t,e){}var M=function(n,t,e){return!1},R=function(n){return n};function P(n,t){if(n===t)return!0;var e=u(n),r=u(t);if(!e||!r)return!e&&!r&&String(n)===String(t);try{var i=Array.isArray(n),a=Array.isArray(t);if(i&&a)return n.length===t.length&&n.every((function(n,e){return P(n,t[e])}));if(n instanceof Date&&t instanceof Date)return n.getTime()===t.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(t);return o.length===s.length&&o.every((function(e){return P(n[e],t[e])}))}catch(n){return!1}}function B(n,t){for(var e=0;e<n.length;e++)if(P(n[e],t))return e;return-1}function N(n){var t=!1;return function(){t||(t=!0,n.apply(this,arguments))}}var D=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:M,isReservedAttr:M,isUnknownElement:M,getTagNamespace:z,parsePlatformTagName:R,mustUseProp:M,async:!0,_lifecycleHooks:$},F=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n,t,e,r){Object.defineProperty(n,t,{value:e,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^"+F.source+".$_\\d]");var J,W="__proto__"in{},G="undefined"!=typeof window,H="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,K=H&&WXEnvironment.platform.toLowerCase(),X=G&&window.navigator.userAgent.toLowerCase(),Q=X&&/msie|trident/.test(X),Y=X&&X.indexOf("msie 9.0")>0,Z=X&&X.indexOf("edge/")>0,nn=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===K),tn=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),en={}.watch,rn=!1;if(G)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===J&&(J=!G&&!H&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),J},sn=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,un="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);ln="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=z,dn=0,fn=function(){this.id=dn++,this.subs=[]};fn.prototype.addSub=function(n){this.subs.push(n)},fn.prototype.removeSub=function(n){w(this.subs,n)},fn.prototype.depend=function(){fn.target&&fn.target.addDep(this)},fn.prototype.notify=function(){var n=this.subs.slice();for(var t=0,e=n.length;t<e;t++)n[t].update()},fn.target=null;var hn=[];function mn(n){hn.push(n),fn.target=n}function vn(){hn.pop(),fn.target=hn[hn.length-1]}var gn=function(n,t,e,r,i,a,o,s){this.tag=n,this.data=t,this.children=e,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},bn={child:{configurable:!0}};bn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,bn);var yn=function(n){void 0===n&&(n="");var t=new gn;return t.text=n,t.isComment=!0,t};function wn(n){return new gn(void 0,void 0,void 0,String(n))}function kn(n){var t=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return t.ns=n.ns,t.isStatic=n.isStatic,t.key=n.key,t.isComment=n.isComment,t.fnContext=n.fnContext,t.fnOptions=n.fnOptions,t.fnScopeId=n.fnScopeId,t.asyncMeta=n.asyncMeta,t.isCloned=!0,t}var xn=Array.prototype,_n=Object.create(xn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var t=xn[n];q(_n,n,(function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];var i,a=t.apply(this,e),o=this.__ob__;switch(n){case"push":case"unshift":i=e;break;case"splice":i=e.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var Sn=Object.getOwnPropertyNames(_n),Tn=!0;function jn(n){Tn=n}var Cn=function(n){this.value=n,this.dep=new fn,this.vmCount=0,q(n,"__ob__",this),Array.isArray(n)?(W?function(n,t){n.__proto__=t}(n,_n):function(n,t,e){for(var r=0,i=e.length;r<i;r++){var a=e[r];q(n,a,t[a])}}(n,_n,Sn),this.observeArray(n)):this.walk(n)};function In(n,t){var e;if(u(n)&&!(n instanceof gn))return x(n,"__ob__")&&n.__ob__ instanceof Cn?e=n.__ob__:Tn&&!on()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(e=new Cn(n)),t&&e&&e.vmCount++,e}function An(n,t,e,r,i){var a=new fn,o=Object.getOwnPropertyDescriptor(n,t);if(!o||!1!==o.configurable){var s=o&&o.get,c=o&&o.set;s&&!c||2!==arguments.length||(e=n[t]);var l=!i&&In(e);Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var t=s?s.call(n):e;return fn.target&&(a.depend(),l&&(l.dep.depend(),Array.isArray(t)&&Ln(t))),t},set:function(t){var r=s?s.call(n):e;t===r||t!=t&&r!=r||s&&!c||(c?c.call(n,t):e=t,l=!i&&In(t),a.notify())}})}}function On(n,t,e){if(Array.isArray(n)&&h(t))return n.length=Math.max(n.length,t),n.splice(t,1,e),e;if(t in n&&!(t in Object.prototype))return n[t]=e,e;var r=n.__ob__;return n._isVue||r&&r.vmCount?e:r?(An(r.value,t,e),r.dep.notify(),e):(n[t]=e,e)}function En(n,t){if(Array.isArray(n)&&h(t))n.splice(t,1);else{var e=n.__ob__;n._isVue||e&&e.vmCount||x(n,t)&&(delete n[t],e&&e.dep.notify())}}function Ln(n){for(var t=void 0,e=0,r=n.length;e<r;e++)(t=n[e])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Ln(t)}Cn.prototype.walk=function(n){for(var t=Object.keys(n),e=0;e<t.length;e++)An(n,t[e])},Cn.prototype.observeArray=function(n){for(var t=0,e=n.length;t<e;t++)In(n[t])};var zn=U.optionMergeStrategies;function Mn(n,t){if(!t)return n;for(var e,r,i,a=un?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++)"__ob__"!==(e=a[o])&&(r=n[e],i=t[e],x(n,e)?r!==i&&d(r)&&d(i)&&Mn(r,i):On(n,e,i));return n}function Rn(n,t,e){return e?function(){var r="function"==typeof t?t.call(e,e):t,i="function"==typeof n?n.call(e,e):n;return r?Mn(r,i):i}:t?n?function(){return Mn("function"==typeof t?t.call(this,this):t,"function"==typeof n?n.call(this,this):n)}:t:n}function Pn(n,t){var e=t?n?n.concat(t):Array.isArray(t)?t:[t]:n;return e?function(n){for(var t=[],e=0;e<n.length;e++)-1===t.indexOf(n[e])&&t.push(n[e]);return t}(e):e}function Bn(n,t,e,r){var i=Object.create(n||null);return t?E(i,t):i}zn.data=function(n,t,e){return e?Rn(n,t,e):t&&"function"!=typeof t?n:Rn(n,t)},$.forEach((function(n){zn[n]=Pn})),D.forEach((function(n){zn[n+"s"]=Bn})),zn.watch=function(n,t,e,r){if(n===en&&(n=void 0),t===en&&(t=void 0),!t)return Object.create(n||null);if(!n)return t;var i={};for(var a in E(i,n),t){var o=i[a],s=t[a];o&&!Array.isArray(o)&&(o=[o]),i[a]=o?o.concat(s):Array.isArray(s)?s:[s]}return i},zn.props=zn.methods=zn.inject=zn.computed=function(n,t,e,r){if(!n)return t;var i=Object.create(null);return E(i,n),t&&E(i,t),i},zn.provide=Rn;var Nn=function(n,t){return void 0===t?n:t};function Dn(n,t,e){if("function"==typeof t&&(t=t.options),function(n,t){var e=n.props;if(e){var r,i,a={};if(Array.isArray(e))for(r=e.length;r--;)"string"==typeof(i=e[r])&&(a[T(i)]={type:null});else if(d(e))for(var o in e)i=e[o],a[T(o)]=d(i)?i:{type:i};else 0;n.props=a}}(t),function(n,t){var e=n.inject;if(e){var r=n.inject={};if(Array.isArray(e))for(var i=0;i<e.length;i++)r[e[i]]={from:e[i]};else if(d(e))for(var a in e){var o=e[a];r[a]=d(o)?E({from:a},o):{from:o}}else 0}}(t),function(n){var t=n.directives;if(t)for(var e in t){var r=t[e];"function"==typeof r&&(t[e]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(n=Dn(n,t.extends,e)),t.mixins))for(var r=0,i=t.mixins.length;r<i;r++)n=Dn(n,t.mixins[r],e);var a,o={};for(a in n)s(a);for(a in t)x(n,a)||s(a);function s(r){var i=zn[r]||Nn;o[r]=i(n[r],t[r],e,r)}return o}function $n(n,t,e,r){if("string"==typeof e){var i=n[t];if(x(i,e))return i[e];var a=T(e);if(x(i,a))return i[a];var o=j(a);return x(i,o)?i[o]:i[e]||i[a]||i[o]}}function Un(n,t,e,r){var i=t[n],a=!x(e,n),o=e[n],s=Jn(Boolean,i.type);if(s>-1)if(a&&!x(i,"default"))o=!1;else if(""===o||o===I(n)){var c=Jn(String,i.type);(c<0||s<c)&&(o=!0)}if(void 0===o){o=function(n,t,e){if(!x(t,"default"))return;var r=t.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[e]&&void 0!==n._props[e])return n._props[e];return"function"==typeof r&&"Function"!==qn(t.type)?r.call(n):r}(r,i,n);var l=Tn;jn(!0),In(o),jn(l)}return o}var Fn=/^\s*function (\w+)/;function qn(n){var t=n&&n.toString().match(Fn);return t?t[1]:""}function Vn(n,t){return qn(n)===qn(t)}function Jn(n,t){if(!Array.isArray(t))return Vn(t,n)?0:-1;for(var e=0,r=t.length;e<r;e++)if(Vn(t[e],n))return e;return-1}function Wn(n,t,e){mn();try{if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,t,e))return}catch(n){Hn(n,r,"errorCaptured hook")}}Hn(n,t,e)}finally{vn()}}function Gn(n,t,e,r,i){var a;try{(a=e?n.apply(t,e):n.call(t))&&!a._isVue&&m(a)&&!a._handled&&(a.catch((function(n){return Wn(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Wn(n,r,i)}return a}function Hn(n,t,e){if(U.errorHandler)try{return U.errorHandler.call(null,n,t,e)}catch(t){t!==n&&Kn(t,null,"config.errorHandler")}Kn(n,t,e)}function Kn(n,t,e){if(!G&&!H||"undefined"==typeof console)throw n;console.error(n)}var Xn,Qn=!1,Yn=[],Zn=!1;function nt(){Zn=!1;var n=Yn.slice(0);Yn.length=0;for(var t=0;t<n.length;t++)n[t]()}if("undefined"!=typeof Promise&&cn(Promise)){var tt=Promise.resolve();Xn=function(){tt.then(nt),nn&&setTimeout(z)},Qn=!0}else if(Q||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xn="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(nt)}:function(){setTimeout(nt,0)};else{var et=1,rt=new MutationObserver(nt),it=document.createTextNode(String(et));rt.observe(it,{characterData:!0}),Xn=function(){et=(et+1)%2,it.data=String(et)},Qn=!0}function at(n,t){var e;if(Yn.push((function(){if(n)try{n.call(t)}catch(n){Wn(n,t,"nextTick")}else e&&e(t)})),Zn||(Zn=!0,Xn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){e=n}))}var ot=new ln;function st(n){!function n(t,e){var r,i,a=Array.isArray(t);if(!a&&!u(t)||Object.isFrozen(t)||t instanceof gn)return;if(t.__ob__){var o=t.__ob__.dep.id;if(e.has(o))return;e.add(o)}if(a)for(r=t.length;r--;)n(t[r],e);else for(i=Object.keys(t),r=i.length;r--;)n(t[i[r]],e)}(n,ot),ot.clear()}var ct=_((function(n){var t="&"===n.charAt(0),e="~"===(n=t?n.slice(1):n).charAt(0),r="!"===(n=e?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:e,capture:r,passive:t}}));function lt(n,t){function e(){var n=arguments,r=e.fns;if(!Array.isArray(r))return Gn(r,null,arguments,t,"v-on handler");for(var i=r.slice(),a=0;a<i.length;a++)Gn(i[a],null,n,t,"v-on handler")}return e.fns=n,e}function ut(n,t,e,r,i,a){var s,l,u,p;for(s in n)l=n[s],u=t[s],p=ct(s),o(l)||(o(u)?(o(l.fns)&&(l=n[s]=lt(l,a)),c(p.once)&&(l=n[s]=i(p.name,l,p.capture)),e(p.name,l,p.capture,p.passive,p.params)):l!==u&&(u.fns=l,n[s]=u));for(s in t)o(n[s])&&r((p=ct(s)).name,t[s],p.capture)}function pt(n,t,e){var r;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var i=n[t];function a(){e.apply(this,arguments),w(r.fns,a)}o(i)?r=lt([a]):s(i.fns)&&c(i.merged)?(r=i).fns.push(a):r=lt([i,a]),r.merged=!0,n[t]=r}function dt(n,t,e,r,i){if(s(t)){if(x(t,e))return n[e]=t[e],i||delete t[e],!0;if(x(t,r))return n[e]=t[r],i||delete t[r],!0}return!1}function ft(n){return l(n)?[wn(n)]:Array.isArray(n)?function n(t,e){var r,i,a,u,p=[];for(r=0;r<t.length;r++)o(i=t[r])||"boolean"==typeof i||(a=p.length-1,u=p[a],Array.isArray(i)?i.length>0&&(ht((i=n(i,(e||"")+"_"+r))[0])&&ht(u)&&(p[a]=wn(u.text+i[0].text),i.shift()),p.push.apply(p,i)):l(i)?ht(u)?p[a]=wn(u.text+i):""!==i&&p.push(wn(i)):ht(i)&&ht(u)?p[a]=wn(u.text+i.text):(c(t._isVList)&&s(i.tag)&&o(i.key)&&s(e)&&(i.key="__vlist"+e+"_"+r+"__"),p.push(i)));return p}(n):void 0}function ht(n){return s(n)&&s(n.text)&&!1===n.isComment}function mt(n,t){if(n){for(var e=Object.create(null),r=un?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){for(var o=n[a].from,s=t;s;){if(s._provided&&x(s._provided,o)){e[a]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[a]){var c=n[a].default;e[a]="function"==typeof c?c.call(t):c}else 0}}return e}}function vt(n,t){if(!n||!n.length)return{};for(var e={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==t&&a.fnContext!==t||!o||null==o.slot)(e.default||(e.default=[])).push(a);else{var s=o.slot,c=e[s]||(e[s]=[]);"template"===a.tag?c.push.apply(c,a.children||[]):c.push(a)}}for(var l in e)e[l].every(gt)&&delete e[l];return e}function gt(n){return n.isComment&&!n.asyncFactory||" "===n.text}function bt(n){return n.isComment&&n.asyncFactory}function yt(n,t,e){var r,i=Object.keys(t).length>0,o=n?!!n.$stable:!i,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&e&&e!==a&&s===e.$key&&!i&&!e.$hasNormal)return e;for(var c in r={},n)n[c]&&"$"!==c[0]&&(r[c]=wt(t,c,n[c]))}else r={};for(var l in t)l in r||(r[l]=kt(t,l));return n&&Object.isExtensible(n)&&(n._normalized=r),q(r,"$stable",o),q(r,"$key",s),q(r,"$hasNormal",i),r}function wt(n,t,e){var r=function(){var n=arguments.length?e.apply(null,arguments):e({}),t=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ft(n))&&n[0];return n&&(!t||1===n.length&&t.isComment&&!bt(t))?void 0:n};return e.proxy&&Object.defineProperty(n,t,{get:r,enumerable:!0,configurable:!0}),r}function kt(n,t){return function(){return n[t]}}function xt(n,t){var e,r,i,a,o;if(Array.isArray(n)||"string"==typeof n)for(e=new Array(n.length),r=0,i=n.length;r<i;r++)e[r]=t(n[r],r);else if("number"==typeof n)for(e=new Array(n),r=0;r<n;r++)e[r]=t(r+1,r);else if(u(n))if(un&&n[Symbol.iterator]){e=[];for(var c=n[Symbol.iterator](),l=c.next();!l.done;)e.push(t(l.value,e.length)),l=c.next()}else for(a=Object.keys(n),e=new Array(a.length),r=0,i=a.length;r<i;r++)o=a[r],e[r]=t(n[o],o,r);return s(e)||(e=[]),e._isVList=!0,e}function _t(n,t,e,r){var i,a=this.$scopedSlots[n];a?(e=e||{},r&&(e=E(E({},r),e)),i=a(e)||("function"==typeof t?t():t)):i=this.$slots[n]||("function"==typeof t?t():t);var o=e&&e.slot;return o?this.$createElement("template",{slot:o},i):i}function St(n){return $n(this.$options,"filters",n)||R}function Tt(n,t){return Array.isArray(n)?-1===n.indexOf(t):n!==t}function jt(n,t,e,r,i){var a=U.keyCodes[t]||e;return i&&r&&!U.keyCodes[t]?Tt(i,r):a?Tt(a,n):r?I(r)!==t:void 0===n}function Ct(n,t,e,r,i){if(e)if(u(e)){var a;Array.isArray(e)&&(e=L(e));var o=function(o){if("class"===o||"style"===o||y(o))a=n;else{var s=n.attrs&&n.attrs.type;a=r||U.mustUseProp(t,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=T(o),l=I(o);c in a||l in a||(a[o]=e[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){e[o]=n}))};for(var s in e)o(s)}else;return n}function It(n,t){var e=this._staticTrees||(this._staticTrees=[]),r=e[n];return r&&!t||Ot(r=e[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function At(n,t,e){return Ot(n,"__once__"+t+(e?"_"+e:""),!0),n}function Ot(n,t,e){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Et(n[r],t+"_"+r,e);else Et(n,t,e)}function Et(n,t,e){n.isStatic=!0,n.key=t,n.isOnce=e}function Lt(n,t){if(t)if(d(t)){var e=n.on=n.on?E({},n.on):{};for(var r in t){var i=e[r],a=t[r];e[r]=i?[].concat(i,a):a}}else;return n}function zt(n,t,e,r){t=t||{$stable:!e};for(var i=0;i<n.length;i++){var a=n[i];Array.isArray(a)?zt(a,t,e):a&&(a.proxy&&(a.fn.proxy=!0),t[a.key]=a.fn)}return r&&(t.$key=r),t}function Mt(n,t){for(var e=0;e<t.length;e+=2){var r=t[e];"string"==typeof r&&r&&(n[t[e]]=t[e+1])}return n}function Rt(n,t){return"string"==typeof n?t+n:n}function Pt(n){n._o=At,n._n=g,n._s=v,n._l=xt,n._t=_t,n._q=P,n._i=B,n._m=It,n._f=St,n._k=jt,n._b=Ct,n._v=wn,n._e=yn,n._u=zt,n._g=Lt,n._d=Mt,n._p=Rt}function Bt(n,t,e,r,i){var o,s=this,l=i.options;x(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var u=c(l._compiled),p=!u;this.data=n,this.props=t,this.children=e,this.parent=r,this.listeners=n.on||a,this.injections=mt(l.inject,r),this.slots=function(){return s.$slots||yt(n.scopedSlots,s.$slots=vt(e,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return yt(n.scopedSlots,this.slots())}}),u&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=yt(n.scopedSlots,this.$slots)),l._scopeId?this._c=function(n,t,e,i){var a=Vt(o,n,t,e,i,p);return a&&!Array.isArray(a)&&(a.fnScopeId=l._scopeId,a.fnContext=r),a}:this._c=function(n,t,e,r){return Vt(o,n,t,e,r,p)}}function Nt(n,t,e,r,i){var a=kn(n);return a.fnContext=e,a.fnOptions=r,t.slot&&((a.data||(a.data={})).slot=t.slot),a}function Dt(n,t){for(var e in t)n[T(e)]=t[e]}Pt(Bt.prototype);var $t={init:function(n,t){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var e=n;$t.prepatch(e,e)}else{(n.componentInstance=function(n,t){var e={_isComponent:!0,_parentVnode:n,parent:t},r=n.data.inlineTemplate;s(r)&&(e.render=r.render,e.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(e)}(n,Zt)).$mount(t?n.elm:void 0,t)}},prepatch:function(n,t){var e=t.componentOptions;!function(n,t,e,r,i){0;var o=r.data.scopedSlots,s=n.$scopedSlots,c=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),l=!!(i||n.$options._renderChildren||c);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=i,n.$attrs=r.data.attrs||a,n.$listeners=e||a,t&&n.$options.props){jn(!1);for(var u=n._props,p=n.$options._propKeys||[],d=0;d<p.length;d++){var f=p[d],h=n.$options.props;u[f]=Un(f,h,t,n)}jn(!0),n.$options.propsData=t}e=e||a;var m=n.$options._parentListeners;n.$options._parentListeners=e,Yt(n,e,m),l&&(n.$slots=vt(i,r.context),n.$forceUpdate());0}(t.componentInstance=n.componentInstance,e.propsData,e.listeners,t,e.children)},insert:function(n){var t,e=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,re(r,"mounted")),n.data.keepAlive&&(e._isMounted?((t=r)._inactive=!1,ae.push(t)):ee(r,!0))},destroy:function(n){var t=n.componentInstance;t._isDestroyed||(n.data.keepAlive?function n(t,e){if(e&&(t._directInactive=!0,te(t)))return;if(!t._inactive){t._inactive=!0;for(var r=0;r<t.$children.length;r++)n(t.$children[r]);re(t,"deactivated")}}(t,!0):t.$destroy())}},Ut=Object.keys($t);function Ft(n,t,e,r,i){if(!o(n)){var l=e.$options._base;if(u(n)&&(n=l.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,t){if(c(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var e=Wt;e&&s(n.owners)&&-1===n.owners.indexOf(e)&&n.owners.push(e);if(c(n.loading)&&s(n.loadingComp))return n.loadingComp;if(e&&!s(n.owners)){var r=n.owners=[e],i=!0,a=null,l=null;e.$on("hook:destroyed",(function(){return w(r,e)}));var p=function(n){for(var t=0,e=r.length;t<e;t++)r[t].$forceUpdate();n&&(r.length=0,null!==a&&(clearTimeout(a),a=null),null!==l&&(clearTimeout(l),l=null))},d=N((function(e){n.resolved=Gt(e,t),i?r.length=0:p(!0)})),f=N((function(t){s(n.errorComp)&&(n.error=!0,p(!0))})),h=n(d,f);return u(h)&&(m(h)?o(n.resolved)&&h.then(d,f):m(h.component)&&(h.component.then(d,f),s(h.error)&&(n.errorComp=Gt(h.error,t)),s(h.loading)&&(n.loadingComp=Gt(h.loading,t),0===h.delay?n.loading=!0:a=setTimeout((function(){a=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),h.delay||200)),s(h.timeout)&&(l=setTimeout((function(){l=null,o(n.resolved)&&f(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,l)))return function(n,t,e,r,i){var a=yn();return a.asyncFactory=n,a.asyncMeta={data:t,context:e,children:r,tag:i},a}(p,t,e,r,i);t=t||{},Te(n),s(t.model)&&function(n,t){var e=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(t.attrs||(t.attrs={}))[e]=t.model.value;var i=t.on||(t.on={}),a=i[r],o=t.model.callback;s(a)?(Array.isArray(a)?-1===a.indexOf(o):a!==o)&&(i[r]=[o].concat(a)):i[r]=o}(n.options,t);var d=function(n,t,e){var r=t.options.props;if(!o(r)){var i={},a=n.attrs,c=n.props;if(s(a)||s(c))for(var l in r){var u=I(l);dt(i,c,l,u,!0)||dt(i,a,l,u,!1)}return i}}(t,n);if(c(n.options.functional))return function(n,t,e,r,i){var o=n.options,c={},l=o.props;if(s(l))for(var u in l)c[u]=Un(u,l,t||a);else s(e.attrs)&&Dt(c,e.attrs),s(e.props)&&Dt(c,e.props);var p=new Bt(e,c,i,r,n),d=o.render.call(null,p._c,p);if(d instanceof gn)return Nt(d,e,p.parent,o,p);if(Array.isArray(d)){for(var f=ft(d)||[],h=new Array(f.length),m=0;m<f.length;m++)h[m]=Nt(f[m],e,p.parent,o,p);return h}}(n,d,t,e,r);var f=t.on;if(t.on=t.nativeOn,c(n.options.abstract)){var h=t.slot;t={},h&&(t.slot=h)}!function(n){for(var t=n.hook||(n.hook={}),e=0;e<Ut.length;e++){var r=Ut[e],i=t[r],a=$t[r];i===a||i&&i._merged||(t[r]=i?qt(a,i):a)}}(t);var v=n.options.name||i;return new gn("vue-component-"+n.cid+(v?"-"+v:""),t,void 0,void 0,void 0,e,{Ctor:n,propsData:d,listeners:f,tag:i,children:r},p)}}}function qt(n,t){var e=function(e,r){n(e,r),t(e,r)};return e._merged=!0,e}function Vt(n,t,e,r,i,a){return(Array.isArray(e)||l(e))&&(i=r,r=e,e=void 0),c(a)&&(i=2),function(n,t,e,r,i){if(s(e)&&s(e.__ob__))return yn();s(e)&&s(e.is)&&(t=e.is);if(!t)return yn();0;Array.isArray(r)&&"function"==typeof r[0]&&((e=e||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=ft(r):1===i&&(r=function(n){for(var t=0;t<n.length;t++)if(Array.isArray(n[t]))return Array.prototype.concat.apply([],n);return n}(r));var a,l;if("string"==typeof t){var p;l=n.$vnode&&n.$vnode.ns||U.getTagNamespace(t),a=U.isReservedTag(t)?new gn(U.parsePlatformTagName(t),e,r,void 0,void 0,n):e&&e.pre||!s(p=$n(n.$options,"components",t))?new gn(t,e,r,void 0,void 0,n):Ft(p,e,n,r,t)}else a=Ft(t,e,n,r);return Array.isArray(a)?a:s(a)?(s(l)&&function n(t,e,r){t.ns=e,"foreignObject"===t.tag&&(e=void 0,r=!0);if(s(t.children))for(var i=0,a=t.children.length;i<a;i++){var l=t.children[i];s(l.tag)&&(o(l.ns)||c(r)&&"svg"!==l.tag)&&n(l,e,r)}}(a,l),s(e)&&function(n){u(n.style)&&st(n.style);u(n.class)&&st(n.class)}(e),a):yn()}(n,t,e,r,i)}var Jt,Wt=null;function Gt(n,t){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?t.extend(n):n}function Ht(n){if(Array.isArray(n))for(var t=0;t<n.length;t++){var e=n[t];if(s(e)&&(s(e.componentOptions)||bt(e)))return e}}function Kt(n,t){Jt.$on(n,t)}function Xt(n,t){Jt.$off(n,t)}function Qt(n,t){var e=Jt;return function r(){var i=t.apply(null,arguments);null!==i&&e.$off(n,r)}}function Yt(n,t,e){Jt=n,ut(t,e||{},Kt,Xt,Qt,n),Jt=void 0}var Zt=null;function ne(n){var t=Zt;return Zt=n,function(){Zt=t}}function te(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function ee(n,t){if(t){if(n._directInactive=!1,te(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var e=0;e<n.$children.length;e++)ee(n.$children[e]);re(n,"activated")}}function re(n,t){mn();var e=n.$options[t],r=t+" hook";if(e)for(var i=0,a=e.length;i<a;i++)Gn(e[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+t),vn()}var ie=[],ae=[],oe={},se=!1,ce=!1,le=0;var ue=0,pe=Date.now;if(G&&!Q){var de=window.performance;de&&"function"==typeof de.now&&pe()>document.createEvent("Event").timeStamp&&(pe=function(){return de.now()})}function fe(){var n,t;for(ue=pe(),ce=!0,ie.sort((function(n,t){return n.id-t.id})),le=0;le<ie.length;le++)(n=ie[le]).before&&n.before(),t=n.id,oe[t]=null,n.run();var e=ae.slice(),r=ie.slice();le=ie.length=ae.length=0,oe={},se=ce=!1,function(n){for(var t=0;t<n.length;t++)n[t]._inactive=!0,ee(n[t],!0)}(e),function(n){var t=n.length;for(;t--;){var e=n[t],r=e.vm;r._watcher===e&&r._isMounted&&!r._isDestroyed&&re(r,"updated")}}(r),sn&&U.devtools&&sn.emit("flush")}var he=0,me=function(n,t,e,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=e,this.id=++he,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(n){if(!V.test(n)){var t=n.split(".");return function(n){for(var e=0;e<t.length;e++){if(!n)return;n=n[t[e]]}return n}}}(t),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()};me.prototype.get=function(){var n;mn(this);var t=this.vm;try{n=this.getter.call(t,t)}catch(n){if(!this.user)throw n;Wn(n,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&st(n),vn(),this.cleanupDeps()}return n},me.prototype.addDep=function(n){var t=n.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(n),this.depIds.has(t)||n.addSub(this))},me.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var t=this.deps[n];this.newDepIds.has(t.id)||t.removeSub(this)}var e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0},me.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var t=n.id;if(null==oe[t]){if(oe[t]=!0,ce){for(var e=ie.length-1;e>le&&ie[e].id>n.id;)e--;ie.splice(e+1,0,n)}else ie.push(n);se||(se=!0,at(fe))}}(this)},me.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var t=this.value;if(this.value=n,this.user){var e='callback for watcher "'+this.expression+'"';Gn(this.cb,this.vm,[n,t],this.vm,e)}else this.cb.call(this.vm,n,t)}}},me.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},me.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},me.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||w(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ve={enumerable:!0,configurable:!0,get:z,set:z};function ge(n,t,e){ve.get=function(){return this[t][e]},ve.set=function(n){this[t][e]=n},Object.defineProperty(n,e,ve)}function be(n){n._watchers=[];var t=n.$options;t.props&&function(n,t){var e=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&jn(!1);var a=function(a){i.push(a);var o=Un(a,t,e,n);An(r,a,o),a in n||ge(n,"_props",a)};for(var o in t)a(o);jn(!0)}(n,t.props),t.methods&&function(n,t){n.$options.props;for(var e in t)n[e]="function"!=typeof t[e]?z:A(t[e],n)}(n,t.methods),t.data?function(n){var t=n.$options.data;d(t=n._data="function"==typeof t?function(n,t){mn();try{return n.call(t,t)}catch(n){return Wn(n,t,"data()"),{}}finally{vn()}}(t,n):t||{})||(t={});var e=Object.keys(t),r=n.$options.props,i=(n.$options.methods,e.length);for(;i--;){var a=e[i];0,r&&x(r,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&ge(n,"_data",a))}var o;In(t,!0)}(n):In(n._data={},!0),t.computed&&function(n,t){var e=n._computedWatchers=Object.create(null),r=on();for(var i in t){var a=t[i],o="function"==typeof a?a:a.get;0,r||(e[i]=new me(n,o||z,z,ye)),i in n||we(n,i,a)}}(n,t.computed),t.watch&&t.watch!==en&&function(n,t){for(var e in t){var r=t[e];if(Array.isArray(r))for(var i=0;i<r.length;i++)_e(n,e,r[i]);else _e(n,e,r)}}(n,t.watch)}var ye={lazy:!0};function we(n,t,e){var r=!on();"function"==typeof e?(ve.get=r?ke(t):xe(e),ve.set=z):(ve.get=e.get?r&&!1!==e.cache?ke(t):xe(e.get):z,ve.set=e.set||z),Object.defineProperty(n,t,ve)}function ke(n){return function(){var t=this._computedWatchers&&this._computedWatchers[n];if(t)return t.dirty&&t.evaluate(),fn.target&&t.depend(),t.value}}function xe(n){return function(){return n.call(this,this)}}function _e(n,t,e,r){return d(e)&&(r=e,e=e.handler),"string"==typeof e&&(e=n[e]),n.$watch(t,e,r)}var Se=0;function Te(n){var t=n.options;if(n.super){var e=Te(n.super);if(e!==n.superOptions){n.superOptions=e;var r=function(n){var t,e=n.options,r=n.sealedOptions;for(var i in e)e[i]!==r[i]&&(t||(t={}),t[i]=e[i]);return t}(n);r&&E(n.extendOptions,r),(t=n.options=Dn(e,n.extendOptions)).name&&(t.components[t.name]=n)}}return t}function je(n){this._init(n)}function Ce(n){n.cid=0;var t=1;n.extend=function(n){n=n||{};var e=this,r=e.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=n.name||e.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(e.prototype)).constructor=o,o.cid=t++,o.options=Dn(e.options,n),o.super=e,o.options.props&&function(n){var t=n.options.props;for(var e in t)ge(n.prototype,"_props",e)}(o),o.options.computed&&function(n){var t=n.options.computed;for(var e in t)we(n.prototype,e,t[e])}(o),o.extend=e.extend,o.mixin=e.mixin,o.use=e.use,D.forEach((function(n){o[n]=e[n]})),a&&(o.options.components[a]=o),o.superOptions=e.options,o.extendOptions=n,o.sealedOptions=E({},o.options),i[r]=o,o}}function Ie(n){return n&&(n.Ctor.options.name||n.tag)}function Ae(n,t){return Array.isArray(n)?n.indexOf(t)>-1:"string"==typeof n?n.split(",").indexOf(t)>-1:!!f(n)&&n.test(t)}function Oe(n,t){var e=n.cache,r=n.keys,i=n._vnode;for(var a in e){var o=e[a];if(o){var s=o.name;s&&!t(s)&&Ee(e,a,r,i)}}}function Ee(n,t,e,r){var i=n[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[t]=null,w(e,t)}!function(n){n.prototype._init=function(n){var t=this;t._uid=Se++,t._isVue=!0,n&&n._isComponent?function(n,t){var e=n.$options=Object.create(n.constructor.options),r=t._parentVnode;e.parent=t.parent,e._parentVnode=r;var i=r.componentOptions;e.propsData=i.propsData,e._parentListeners=i.listeners,e._renderChildren=i.children,e._componentTag=i.tag,t.render&&(e.render=t.render,e.staticRenderFns=t.staticRenderFns)}(t,n):t.$options=Dn(Te(t.constructor),n||{},t),t._renderProxy=t,t._self=t,function(n){var t=n.$options,e=t.parent;if(e&&!t.abstract){for(;e.$options.abstract&&e.$parent;)e=e.$parent;e.$children.push(n)}n.$parent=e,n.$root=e?e.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(t),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var t=n.$options._parentListeners;t&&Yt(n,t)}(t),function(n){n._vnode=null,n._staticTrees=null;var t=n.$options,e=n.$vnode=t._parentVnode,r=e&&e.context;n.$slots=vt(t._renderChildren,r),n.$scopedSlots=a,n._c=function(t,e,r,i){return Vt(n,t,e,r,i,!1)},n.$createElement=function(t,e,r,i){return Vt(n,t,e,r,i,!0)};var i=e&&e.data;An(n,"$attrs",i&&i.attrs||a,null,!0),An(n,"$listeners",t._parentListeners||a,null,!0)}(t),re(t,"beforeCreate"),function(n){var t=mt(n.$options.inject,n);t&&(jn(!1),Object.keys(t).forEach((function(e){An(n,e,t[e])})),jn(!0))}(t),be(t),function(n){var t=n.$options.provide;t&&(n._provided="function"==typeof t?t.call(n):t)}(t),re(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(je),function(n){var t={get:function(){return this._data}},e={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",t),Object.defineProperty(n.prototype,"$props",e),n.prototype.$set=On,n.prototype.$delete=En,n.prototype.$watch=function(n,t,e){if(d(t))return _e(this,n,t,e);(e=e||{}).user=!0;var r=new me(this,n,t,e);if(e.immediate){var i='callback for immediate watcher "'+r.expression+'"';mn(),Gn(t,this,[r.value],this,i),vn()}return function(){r.teardown()}}}(je),function(n){var t=/^hook:/;n.prototype.$on=function(n,e){var r=this;if(Array.isArray(n))for(var i=0,a=n.length;i<a;i++)r.$on(n[i],e);else(r._events[n]||(r._events[n]=[])).push(e),t.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,t){var e=this;function r(){e.$off(n,r),t.apply(e,arguments)}return r.fn=t,e.$on(n,r),e},n.prototype.$off=function(n,t){var e=this;if(!arguments.length)return e._events=Object.create(null),e;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)e.$off(n[r],t);return e}var a,o=e._events[n];if(!o)return e;if(!t)return e._events[n]=null,e;for(var s=o.length;s--;)if((a=o[s])===t||a.fn===t){o.splice(s,1);break}return e},n.prototype.$emit=function(n){var t=this,e=t._events[n];if(e){e=e.length>1?O(e):e;for(var r=O(arguments,1),i='event handler for "'+n+'"',a=0,o=e.length;a<o;a++)Gn(e[a],t,r,t,i)}return t}}(je),function(n){n.prototype._update=function(n,t){var e=this,r=e.$el,i=e._vnode,a=ne(e);e._vnode=n,e.$el=i?e.__patch__(i,n):e.__patch__(e.$el,n,t,!1),a(),r&&(r.__vue__=null),e.$el&&(e.$el.__vue__=e),e.$vnode&&e.$parent&&e.$vnode===e.$parent._vnode&&(e.$parent.$el=e.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){re(n,"beforeDestroy"),n._isBeingDestroyed=!0;var t=n.$parent;!t||t._isBeingDestroyed||n.$options.abstract||w(t.$children,n),n._watcher&&n._watcher.teardown();for(var e=n._watchers.length;e--;)n._watchers[e].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),re(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(je),function(n){Pt(n.prototype),n.prototype.$nextTick=function(n){return at(n,this)},n.prototype._render=function(){var n,t=this,e=t.$options,r=e.render,i=e._parentVnode;i&&(t.$scopedSlots=yt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Wt=t,n=r.call(t._renderProxy,t.$createElement)}catch(e){Wn(e,t,"render"),n=t._vnode}finally{Wt=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=yn()),n.parent=i,n}}(je);var Le=[String,RegExp,Array],ze={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Le,exclude:Le,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,t=this.keys,e=this.vnodeToCache,r=this.keyToCache;if(e){var i=e.tag,a=e.componentInstance,o=e.componentOptions;n[r]={name:Ie(o),tag:i,componentInstance:a},t.push(r),this.max&&t.length>parseInt(this.max)&&Ee(n,t[0],t,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ee(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(t){Oe(n,(function(n){return Ae(t,n)}))})),this.$watch("exclude",(function(t){Oe(n,(function(n){return!Ae(t,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,t=Ht(n),e=t&&t.componentOptions;if(e){var r=Ie(e),i=this.include,a=this.exclude;if(i&&(!r||!Ae(i,r))||a&&r&&Ae(a,r))return t;var o=this.cache,s=this.keys,c=null==t.key?e.Ctor.cid+(e.tag?"::"+e.tag:""):t.key;o[c]?(t.componentInstance=o[c].componentInstance,w(s,c),s.push(c)):(this.vnodeToCache=t,this.keyToCache=c),t.data.keepAlive=!0}return t||n&&n[0]}}};!function(n){var t={get:function(){return U}};Object.defineProperty(n,"config",t),n.util={warn:pn,extend:E,mergeOptions:Dn,defineReactive:An},n.set=On,n.delete=En,n.nextTick=at,n.observable=function(n){return In(n),n},n.options=Object.create(null),D.forEach((function(t){n.options[t+"s"]=Object.create(null)})),n.options._base=n,E(n.options.components,ze),function(n){n.use=function(n){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(n)>-1)return this;var e=O(arguments,1);return e.unshift(this),"function"==typeof n.install?n.install.apply(n,e):"function"==typeof n&&n.apply(null,e),t.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Dn(this.options,n),this}}(n),Ce(n),function(n){D.forEach((function(t){n[t]=function(n,e){return e?("component"===t&&d(e)&&(e.name=e.name||n,e=this.options._base.extend(e)),"directive"===t&&"function"==typeof e&&(e={bind:e,update:e}),this.options[t+"s"][n]=e,e):this.options[t+"s"][n]}}))}(n)}(je),Object.defineProperty(je.prototype,"$isServer",{get:on}),Object.defineProperty(je.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(je,"FunctionalRenderContext",{value:Bt}),je.version="2.6.14";var Me=b("style,class"),Re=b("input,textarea,option,select,progress"),Pe=b("contenteditable,draggable,spellcheck"),Be=b("events,caret,typing,plaintext-only"),Ne=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),De="http://www.w3.org/1999/xlink",$e=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ue=function(n){return $e(n)?n.slice(6,n.length):""},Fe=function(n){return null==n||!1===n};function qe(n){for(var t=n.data,e=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(t=Ve(r.data,t));for(;s(e=e.parent);)e&&e.data&&(t=Ve(t,e.data));return function(n,t){if(s(n)||s(t))return Je(n,We(t));return""}(t.staticClass,t.class)}function Ve(n,t){return{staticClass:Je(n.staticClass,t.staticClass),class:s(n.class)?[n.class,t.class]:t.class}}function Je(n,t){return n?t?n+" "+t:n:t||""}function We(n){return Array.isArray(n)?function(n){for(var t,e="",r=0,i=n.length;r<i;r++)s(t=We(n[r]))&&""!==t&&(e&&(e+=" "),e+=t);return e}(n):u(n)?function(n){var t="";for(var e in n)n[e]&&(t&&(t+=" "),t+=e);return t}(n):"string"==typeof n?n:""}var Ge={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},He=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Ke=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Xe=function(n){return He(n)||Ke(n)};var Qe=Object.create(null);var Ye=b("text,number,password,search,email,tel,url");var Ze=Object.freeze({createElement:function(n,t){var e=document.createElement(n);return"select"!==n||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&e.setAttribute("multiple","multiple"),e},createElementNS:function(n,t){return document.createElementNS(Ge[n],t)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,t,e){n.insertBefore(t,e)},removeChild:function(n,t){n.removeChild(t)},appendChild:function(n,t){n.appendChild(t)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,t){n.textContent=t},setStyleScope:function(n,t){n.setAttribute(t,"")}}),nr={create:function(n,t){tr(t)},update:function(n,t){n.data.ref!==t.data.ref&&(tr(n,!0),tr(t))},destroy:function(n){tr(n,!0)}};function tr(n,t){var e=n.data.ref;if(s(e)){var r=n.context,i=n.componentInstance||n.elm,a=r.$refs;t?Array.isArray(a[e])?w(a[e],i):a[e]===i&&(a[e]=void 0):n.data.refInFor?Array.isArray(a[e])?a[e].indexOf(i)<0&&a[e].push(i):a[e]=[i]:a[e]=i}}var er=new gn("",{},[]),rr=["create","activate","update","remove","destroy"];function ir(n,t){return n.key===t.key&&n.asyncFactory===t.asyncFactory&&(n.tag===t.tag&&n.isComment===t.isComment&&s(n.data)===s(t.data)&&function(n,t){if("input"!==n.tag)return!0;var e,r=s(e=n.data)&&s(e=e.attrs)&&e.type,i=s(e=t.data)&&s(e=e.attrs)&&e.type;return r===i||Ye(r)&&Ye(i)}(n,t)||c(n.isAsyncPlaceholder)&&o(t.asyncFactory.error))}function ar(n,t,e){var r,i,a={};for(r=t;r<=e;++r)s(i=n[r].key)&&(a[i]=r);return a}var or={create:sr,update:sr,destroy:function(n){sr(n,er)}};function sr(n,t){(n.data.directives||t.data.directives)&&function(n,t){var e,r,i,a=n===er,o=t===er,s=lr(n.data.directives,n.context),c=lr(t.data.directives,t.context),l=[],u=[];for(e in c)r=s[e],i=c[e],r?(i.oldValue=r.value,i.oldArg=r.arg,pr(i,"update",t,n),i.def&&i.def.componentUpdated&&u.push(i)):(pr(i,"bind",t,n),i.def&&i.def.inserted&&l.push(i));if(l.length){var p=function(){for(var e=0;e<l.length;e++)pr(l[e],"inserted",t,n)};a?pt(t,"insert",p):p()}u.length&&pt(t,"postpatch",(function(){for(var e=0;e<u.length;e++)pr(u[e],"componentUpdated",t,n)}));if(!a)for(e in s)c[e]||pr(s[e],"unbind",n,n,o)}(n,t)}var cr=Object.create(null);function lr(n,t){var e,r,i=Object.create(null);if(!n)return i;for(e=0;e<n.length;e++)(r=n[e]).modifiers||(r.modifiers=cr),i[ur(r)]=r,r.def=$n(t.$options,"directives",r.name);return i}function ur(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function pr(n,t,e,r,i){var a=n.def&&n.def[t];if(a)try{a(e.elm,n,e,r,i)}catch(r){Wn(r,e.context,"directive "+n.name+" "+t+" hook")}}var dr=[nr,or];function fr(n,t){var e=t.componentOptions;if(!(s(e)&&!1===e.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(t.data.attrs))){var r,i,a=t.elm,c=n.data.attrs||{},l=t.data.attrs||{};for(r in s(l.__ob__)&&(l=t.data.attrs=E({},l)),l)i=l[r],c[r]!==i&&hr(a,r,i,t.data.pre);for(r in(Q||Z)&&l.value!==c.value&&hr(a,"value",l.value),c)o(l[r])&&($e(r)?a.removeAttributeNS(De,Ue(r)):Pe(r)||a.removeAttribute(r))}}function hr(n,t,e,r){r||n.tagName.indexOf("-")>-1?mr(n,t,e):Ne(t)?Fe(e)?n.removeAttribute(t):(e="allowfullscreen"===t&&"EMBED"===n.tagName?"true":t,n.setAttribute(t,e)):Pe(t)?n.setAttribute(t,function(n,t){return Fe(t)||"false"===t?"false":"contenteditable"===n&&Be(t)?t:"true"}(t,e)):$e(t)?Fe(e)?n.removeAttributeNS(De,Ue(t)):n.setAttributeNS(De,t,e):mr(n,t,e)}function mr(n,t,e){if(Fe(e))n.removeAttribute(t);else{if(Q&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===t&&""!==e&&!n.__ieph){var r=function(t){t.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(t,e)}}var vr={create:fr,update:fr};function gr(n,t){var e=t.elm,r=t.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var a=qe(t),c=e._transitionClasses;s(c)&&(a=Je(a,We(c))),a!==e._prevClass&&(e.setAttribute("class",a),e._prevClass=a)}}var br,yr={create:gr,update:gr};function wr(n,t,e){var r=br;return function i(){var a=t.apply(null,arguments);null!==a&&_r(n,i,e,r)}}var kr=Qn&&!(tn&&Number(tn[1])<=53);function xr(n,t,e,r){if(kr){var i=ue,a=t;t=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}br.addEventListener(n,t,rn?{capture:e,passive:r}:e)}function _r(n,t,e,r){(r||br).removeEventListener(n,t._wrapper||t,e)}function Sr(n,t){if(!o(n.data.on)||!o(t.data.on)){var e=t.data.on||{},r=n.data.on||{};br=t.elm,function(n){if(s(n.__r)){var t=Q?"change":"input";n[t]=[].concat(n.__r,n[t]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(e),ut(e,r,xr,_r,wr,t.context),br=void 0}}var Tr,jr={create:Sr,update:Sr};function Cr(n,t){if(!o(n.data.domProps)||!o(t.data.domProps)){var e,r,i=t.elm,a=n.data.domProps||{},c=t.data.domProps||{};for(e in s(c.__ob__)&&(c=t.data.domProps=E({},c)),a)e in c||(i[e]="");for(e in c){if(r=c[e],"textContent"===e||"innerHTML"===e){if(t.children&&(t.children.length=0),r===a[e])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===e&&"PROGRESS"!==i.tagName){i._value=r;var l=o(r)?"":String(r);Ir(i,l)&&(i.value=l)}else if("innerHTML"===e&&Ke(i.tagName)&&o(i.innerHTML)){(Tr=Tr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=Tr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(r!==a[e])try{i[e]=r}catch(n){}}}}function Ir(n,t){return!n.composing&&("OPTION"===n.tagName||function(n,t){var e=!0;try{e=document.activeElement!==n}catch(n){}return e&&n.value!==t}(n,t)||function(n,t){var e=n.value,r=n._vModifiers;if(s(r)){if(r.number)return g(e)!==g(t);if(r.trim)return e.trim()!==t.trim()}return e!==t}(n,t))}var Ar={create:Cr,update:Cr},Or=_((function(n){var t={},e=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(e);r.length>1&&(t[r[0].trim()]=r[1].trim())}})),t}));function Er(n){var t=Lr(n.style);return n.staticStyle?E(n.staticStyle,t):t}function Lr(n){return Array.isArray(n)?L(n):"string"==typeof n?Or(n):n}var zr,Mr=/^--/,Rr=/\s*!important$/,Pr=function(n,t,e){if(Mr.test(t))n.style.setProperty(t,e);else if(Rr.test(e))n.style.setProperty(I(t),e.replace(Rr,""),"important");else{var r=Nr(t);if(Array.isArray(e))for(var i=0,a=e.length;i<a;i++)n.style[r]=e[i];else n.style[r]=e}},Br=["Webkit","Moz","ms"],Nr=_((function(n){if(zr=zr||document.createElement("div").style,"filter"!==(n=T(n))&&n in zr)return n;for(var t=n.charAt(0).toUpperCase()+n.slice(1),e=0;e<Br.length;e++){var r=Br[e]+t;if(r in zr)return r}}));function Dr(n,t){var e=t.data,r=n.data;if(!(o(e.staticStyle)&&o(e.style)&&o(r.staticStyle)&&o(r.style))){var i,a,c=t.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},p=l||u,d=Lr(t.data.style)||{};t.data.normalizedStyle=s(d.__ob__)?E({},d):d;var f=function(n,t){var e,r={};if(t)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(e=Er(i.data))&&E(r,e);(e=Er(n.data))&&E(r,e);for(var a=n;a=a.parent;)a.data&&(e=Er(a.data))&&E(r,e);return r}(t,!0);for(a in p)o(f[a])&&Pr(c,a,"");for(a in f)(i=f[a])!==p[a]&&Pr(c,a,null==i?"":i)}}var $r={create:Dr,update:Dr},Ur=/\s+/;function Fr(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(Ur).forEach((function(t){return n.classList.add(t)})):n.classList.add(t);else{var e=" "+(n.getAttribute("class")||"")+" ";e.indexOf(" "+t+" ")<0&&n.setAttribute("class",(e+t).trim())}}function qr(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(Ur).forEach((function(t){return n.classList.remove(t)})):n.classList.remove(t),n.classList.length||n.removeAttribute("class");else{for(var e=" "+(n.getAttribute("class")||"")+" ",r=" "+t+" ";e.indexOf(r)>=0;)e=e.replace(r," ");(e=e.trim())?n.setAttribute("class",e):n.removeAttribute("class")}}function Vr(n){if(n){if("object"==typeof n){var t={};return!1!==n.css&&E(t,Jr(n.name||"v")),E(t,n),t}return"string"==typeof n?Jr(n):void 0}}var Jr=_((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Wr=G&&!Y,Gr="transition",Hr="transitionend",Kr="animation",Xr="animationend";Wr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Gr="WebkitTransition",Hr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Kr="WebkitAnimation",Xr="webkitAnimationEnd"));var Qr=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Qr((function(){Qr(n)}))}function Zr(n,t){var e=n._transitionClasses||(n._transitionClasses=[]);e.indexOf(t)<0&&(e.push(t),Fr(n,t))}function ni(n,t){n._transitionClasses&&w(n._transitionClasses,t),qr(n,t)}function ti(n,t,e){var r=ri(n,t),i=r.type,a=r.timeout,o=r.propCount;if(!i)return e();var s="transition"===i?Hr:Xr,c=0,l=function(){n.removeEventListener(s,u),e()},u=function(t){t.target===n&&++c>=o&&l()};setTimeout((function(){c<o&&l()}),a+1),n.addEventListener(s,u)}var ei=/\b(transform|all)(,|$)/;function ri(n,t){var e,r=window.getComputedStyle(n),i=(r[Gr+"Delay"]||"").split(", "),a=(r[Gr+"Duration"]||"").split(", "),o=ii(i,a),s=(r[Kr+"Delay"]||"").split(", "),c=(r[Kr+"Duration"]||"").split(", "),l=ii(s,c),u=0,p=0;return"transition"===t?o>0&&(e="transition",u=o,p=a.length):"animation"===t?l>0&&(e="animation",u=l,p=c.length):p=(e=(u=Math.max(o,l))>0?o>l?"transition":"animation":null)?"transition"===e?a.length:c.length:0,{type:e,timeout:u,propCount:p,hasTransform:"transition"===e&&ei.test(r[Gr+"Property"])}}function ii(n,t){for(;n.length<t.length;)n=n.concat(n);return Math.max.apply(null,t.map((function(t,e){return ai(t)+ai(n[e])})))}function ai(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oi(n,t){var e=n.elm;s(e._leaveCb)&&(e._leaveCb.cancelled=!0,e._leaveCb());var r=Vr(n.data.transition);if(!o(r)&&!s(e._enterCb)&&1===e.nodeType){for(var i=r.css,a=r.type,c=r.enterClass,l=r.enterToClass,p=r.enterActiveClass,d=r.appearClass,f=r.appearToClass,h=r.appearActiveClass,m=r.beforeEnter,v=r.enter,b=r.afterEnter,y=r.enterCancelled,w=r.beforeAppear,k=r.appear,x=r.afterAppear,_=r.appearCancelled,S=r.duration,T=Zt,j=Zt.$vnode;j&&j.parent;)T=j.context,j=j.parent;var C=!T._isMounted||!n.isRootInsert;if(!C||k||""===k){var I=C&&d?d:c,A=C&&h?h:p,O=C&&f?f:l,E=C&&w||m,L=C&&"function"==typeof k?k:v,z=C&&x||b,M=C&&_||y,R=g(u(S)?S.enter:S);0;var P=!1!==i&&!Y,B=li(L),D=e._enterCb=N((function(){P&&(ni(e,O),ni(e,A)),D.cancelled?(P&&ni(e,I),M&&M(e)):z&&z(e),e._enterCb=null}));n.data.show||pt(n,"insert",(function(){var t=e.parentNode,r=t&&t._pending&&t._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),L&&L(e,D)})),E&&E(e),P&&(Zr(e,I),Zr(e,A),Yr((function(){ni(e,I),D.cancelled||(Zr(e,O),B||(ci(R)?setTimeout(D,R):ti(e,a,D)))}))),n.data.show&&(t&&t(),L&&L(e,D)),P||B||D()}}}function si(n,t){var e=n.elm;s(e._enterCb)&&(e._enterCb.cancelled=!0,e._enterCb());var r=Vr(n.data.transition);if(o(r)||1!==e.nodeType)return t();if(!s(e._leaveCb)){var i=r.css,a=r.type,c=r.leaveClass,l=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,v=r.delayLeave,b=r.duration,y=!1!==i&&!Y,w=li(f),k=g(u(b)?b.leave:b);0;var x=e._leaveCb=N((function(){e.parentNode&&e.parentNode._pending&&(e.parentNode._pending[n.key]=null),y&&(ni(e,l),ni(e,p)),x.cancelled?(y&&ni(e,c),m&&m(e)):(t(),h&&h(e)),e._leaveCb=null}));v?v(_):_()}function _(){x.cancelled||(!n.data.show&&e.parentNode&&((e.parentNode._pending||(e.parentNode._pending={}))[n.key]=n),d&&d(e),y&&(Zr(e,c),Zr(e,p),Yr((function(){ni(e,c),x.cancelled||(Zr(e,l),w||(ci(k)?setTimeout(x,k):ti(e,a,x)))}))),f&&f(e,x),y||w||x())}}function ci(n){return"number"==typeof n&&!isNaN(n)}function li(n){if(o(n))return!1;var t=n.fns;return s(t)?li(Array.isArray(t)?t[0]:t):(n._length||n.length)>1}function ui(n,t){!0!==t.data.show&&oi(t)}var pi=function(n){var t,e,r={},i=n.modules,a=n.nodeOps;for(t=0;t<rr.length;++t)for(r[rr[t]]=[],e=0;e<i.length;++e)s(i[e][rr[t]])&&r[rr[t]].push(i[e][rr[t]]);function u(n){var t=a.parentNode(n);s(t)&&a.removeChild(t,n)}function p(n,t,e,i,o,l,u){if(s(n.elm)&&s(l)&&(n=l[u]=kn(n)),n.isRootInsert=!o,!function(n,t,e,i){var a=n.data;if(s(a)){var o=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return d(n,t),f(e,n.elm,i),c(o)&&function(n,t,e,i){var a,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(a=o.data)&&s(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](er,o);t.push(o);break}f(e,n.elm,i)}(n,t,e,i),!0}}(n,t,e,i)){var p=n.data,m=n.children,b=n.tag;s(b)?(n.elm=n.ns?a.createElementNS(n.ns,b):a.createElement(b,n),g(n),h(n,m,t),s(p)&&v(n,t),f(e,n.elm,i)):c(n.isComment)?(n.elm=a.createComment(n.text),f(e,n.elm,i)):(n.elm=a.createTextNode(n.text),f(e,n.elm,i))}}function d(n,t){s(n.data.pendingInsert)&&(t.push.apply(t,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(v(n,t),g(n)):(tr(n),t.push(n))}function f(n,t,e){s(n)&&(s(e)?a.parentNode(e)===n&&a.insertBefore(n,t,e):a.appendChild(n,t))}function h(n,t,e){if(Array.isArray(t)){0;for(var r=0;r<t.length;++r)p(t[r],e,n.elm,null,!0,t,r)}else l(n.text)&&a.appendChild(n.elm,a.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,e){for(var i=0;i<r.create.length;++i)r.create[i](er,n);s(t=n.data.hook)&&(s(t.create)&&t.create(er,n),s(t.insert)&&e.push(n))}function g(n){var t;if(s(t=n.fnScopeId))a.setStyleScope(n.elm,t);else for(var e=n;e;)s(t=e.context)&&s(t=t.$options._scopeId)&&a.setStyleScope(n.elm,t),e=e.parent;s(t=Zt)&&t!==n.context&&t!==n.fnContext&&s(t=t.$options._scopeId)&&a.setStyleScope(n.elm,t)}function y(n,t,e,r,i,a){for(;r<=i;++r)p(e[r],a,n,t,!1,e,r)}function w(n){var t,e,i=n.data;if(s(i))for(s(t=i.hook)&&s(t=t.destroy)&&t(n),t=0;t<r.destroy.length;++t)r.destroy[t](n);if(s(t=n.children))for(e=0;e<n.children.length;++e)w(n.children[e])}function k(n,t,e){for(;t<=e;++t){var r=n[t];s(r)&&(s(r.tag)?(x(r),w(r)):u(r.elm))}}function x(n,t){if(s(t)||s(n.data)){var e,i=r.remove.length+1;for(s(t)?t.listeners+=i:t=function(n,t){function e(){0==--e.listeners&&u(n)}return e.listeners=t,e}(n.elm,i),s(e=n.componentInstance)&&s(e=e._vnode)&&s(e.data)&&x(e,t),e=0;e<r.remove.length;++e)r.remove[e](n,t);s(e=n.data.hook)&&s(e=e.remove)?e(n,t):t()}else u(n.elm)}function _(n,t,e,r){for(var i=e;i<r;i++){var a=t[i];if(s(a)&&ir(n,a))return i}}function S(n,t,e,i,l,u){if(n!==t){s(t.elm)&&s(i)&&(t=i[l]=kn(t));var d=t.elm=n.elm;if(c(n.isAsyncPlaceholder))s(t.asyncFactory.resolved)?C(n.elm,t,e):t.isAsyncPlaceholder=!0;else if(c(t.isStatic)&&c(n.isStatic)&&t.key===n.key&&(c(t.isCloned)||c(t.isOnce)))t.componentInstance=n.componentInstance;else{var f,h=t.data;s(h)&&s(f=h.hook)&&s(f=f.prepatch)&&f(n,t);var v=n.children,g=t.children;if(s(h)&&m(t)){for(f=0;f<r.update.length;++f)r.update[f](n,t);s(f=h.hook)&&s(f=f.update)&&f(n,t)}o(t.text)?s(v)&&s(g)?v!==g&&function(n,t,e,r,i){var c,l,u,d=0,f=0,h=t.length-1,m=t[0],v=t[h],g=e.length-1,b=e[0],w=e[g],x=!i;for(0;d<=h&&f<=g;)o(m)?m=t[++d]:o(v)?v=t[--h]:ir(m,b)?(S(m,b,r,e,f),m=t[++d],b=e[++f]):ir(v,w)?(S(v,w,r,e,g),v=t[--h],w=e[--g]):ir(m,w)?(S(m,w,r,e,g),x&&a.insertBefore(n,m.elm,a.nextSibling(v.elm)),m=t[++d],w=e[--g]):ir(v,b)?(S(v,b,r,e,f),x&&a.insertBefore(n,v.elm,m.elm),v=t[--h],b=e[++f]):(o(c)&&(c=ar(t,d,h)),o(l=s(b.key)?c[b.key]:_(b,t,d,h))?p(b,r,n,m.elm,!1,e,f):ir(u=t[l],b)?(S(u,b,r,e,f),t[l]=void 0,x&&a.insertBefore(n,u.elm,m.elm)):p(b,r,n,m.elm,!1,e,f),b=e[++f]);d>h?y(n,o(e[g+1])?null:e[g+1].elm,e,f,g,r):f>g&&k(t,d,h)}(d,v,g,e,u):s(g)?(s(n.text)&&a.setTextContent(d,""),y(d,null,g,0,g.length-1,e)):s(v)?k(v,0,v.length-1):s(n.text)&&a.setTextContent(d,""):n.text!==t.text&&a.setTextContent(d,t.text),s(h)&&s(f=h.hook)&&s(f=f.postpatch)&&f(n,t)}}}function T(n,t,e){if(c(e)&&s(n.parent))n.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}var j=b("attrs,class,staticClass,staticStyle,key");function C(n,t,e,r){var i,a=t.tag,o=t.data,l=t.children;if(r=r||o&&o.pre,t.elm=n,c(t.isComment)&&s(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(s(o)&&(s(i=o.hook)&&s(i=i.init)&&i(t,!0),s(i=t.componentInstance)))return d(t,e),!0;if(s(a)){if(s(l))if(n.hasChildNodes())if(s(i=o)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,f=0;f<l.length;f++){if(!p||!C(p,l[f],e,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else h(t,l,e);if(s(o)){var m=!1;for(var g in o)if(!j(g)){m=!0,v(t,e);break}!m&&o.class&&st(o.class)}}else n.data!==t.text&&(n.data=t.text);return!0}return function(n,t,e,i){if(!o(t)){var l,u=!1,d=[];if(o(n))u=!0,p(t,d);else{var f=s(n.nodeType);if(!f&&ir(n,t))S(n,t,d,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),e=!0),c(e)&&C(n,t,d))return T(t,d,!0),n;l=n,n=new gn(a.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=a.parentNode(h);if(p(t,d,h._leaveCb?null:v,a.nextSibling(h)),s(t.parent))for(var g=t.parent,b=m(t);g;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](g);if(g.elm=t.elm,b){for(var x=0;x<r.create.length;++x)r.create[x](er,g);var _=g.data.hook.insert;if(_.merged)for(var j=1;j<_.fns.length;j++)_.fns[j]()}else tr(g);g=g.parent}s(v)?k([n],0,0):s(n.tag)&&w(n)}}return T(t,d,u),t.elm}s(n)&&w(n)}}({nodeOps:Ze,modules:[vr,yr,jr,Ar,$r,G?{create:ui,activate:ui,remove:function(n,t){!0!==n.data.show?si(n,t):t()}}:{}].concat(dr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&yi(n,"input")}));var di={inserted:function(n,t,e,r){"select"===e.tag?(r.elm&&!r.elm._vOptions?pt(e,"postpatch",(function(){di.componentUpdated(n,t,e)})):fi(n,t,e.context),n._vOptions=[].map.call(n.options,vi)):("textarea"===e.tag||Ye(n.type))&&(n._vModifiers=t.modifiers,t.modifiers.lazy||(n.addEventListener("compositionstart",gi),n.addEventListener("compositionend",bi),n.addEventListener("change",bi),Y&&(n.vmodel=!0)))},componentUpdated:function(n,t,e){if("select"===e.tag){fi(n,t,e.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,vi);if(i.some((function(n,t){return!P(n,r[t])})))(n.multiple?t.value.some((function(n){return mi(n,i)})):t.value!==t.oldValue&&mi(t.value,i))&&yi(n,"change")}}};function fi(n,t,e){hi(n,t,e),(Q||Z)&&setTimeout((function(){hi(n,t,e)}),0)}function hi(n,t,e){var r=t.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,c=n.options.length;s<c;s++)if(o=n.options[s],i)a=B(r,vi(o))>-1,o.selected!==a&&(o.selected=a);else if(P(vi(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function mi(n,t){return t.every((function(t){return!P(t,n)}))}function vi(n){return"_value"in n?n._value:n.value}function gi(n){n.target.composing=!0}function bi(n){n.target.composing&&(n.target.composing=!1,yi(n.target,"input"))}function yi(n,t){var e=document.createEvent("HTMLEvents");e.initEvent(t,!0,!0),n.dispatchEvent(e)}function wi(n){return!n.componentInstance||n.data&&n.data.transition?n:wi(n.componentInstance._vnode)}var ki={model:di,show:{bind:function(n,t,e){var r=t.value,i=(e=wi(e)).data&&e.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(e.data.show=!0,oi(e,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,t,e){var r=t.value;!r!=!t.oldValue&&((e=wi(e)).data&&e.data.transition?(e.data.show=!0,r?oi(e,(function(){n.style.display=n.__vOriginalDisplay})):si(e,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,t,e,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},xi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function _i(n){var t=n&&n.componentOptions;return t&&t.Ctor.options.abstract?_i(Ht(t.children)):n}function Si(n){var t={},e=n.$options;for(var r in e.propsData)t[r]=n[r];var i=e._parentListeners;for(var a in i)t[T(a)]=i[a];return t}function Ti(n,t){if(/\d-keep-alive$/.test(t.tag))return n("keep-alive",{props:t.componentOptions.propsData})}var ji=function(n){return n.tag||bt(n)},Ci=function(n){return"show"===n.name},Ii={name:"transition",props:xi,abstract:!0,render:function(n){var t=this,e=this.$slots.default;if(e&&(e=e.filter(ji)).length){0;var r=this.mode;0;var i=e[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=_i(i);if(!a)return i;if(this._leaving)return Ti(n,i);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=Si(this),c=this._vnode,u=_i(c);if(a.data.directives&&a.data.directives.some(Ci)&&(a.data.show=!0),u&&u.data&&!function(n,t){return t.key===n.key&&t.tag===n.tag}(a,u)&&!bt(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=E({},s);if("out-in"===r)return this._leaving=!0,pt(p,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Ti(n,i);if("in-out"===r){if(bt(a))return c;var d,f=function(){d()};pt(s,"afterEnter",f),pt(s,"enterCancelled",f),pt(p,"delayLeave",(function(n){d=n}))}}return i}}},Ai=E({tag:String,moveClass:String},xi);function Oi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ei(n){n.data.newPos=n.elm.getBoundingClientRect()}function Li(n){var t=n.data.pos,e=n.data.newPos,r=t.left-e.left,i=t.top-e.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+i+"px)",a.transitionDuration="0s"}}delete Ai.mode;var zi={Transition:Ii,TransitionGroup:{props:Ai,beforeMount:function(){var n=this,t=this._update;this._update=function(e,r){var i=ne(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),t.call(n,e,r)}},render:function(n){for(var t=this.tag||this.$vnode.data.tag||"span",e=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Si(this),s=0;s<i.length;s++){var c=i[s];if(c.tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),e[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(r){for(var l=[],u=[],p=0;p<r.length;p++){var d=r[p];d.data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),e[d.key]?l.push(d):u.push(d)}this.kept=n(t,null,l),this.removed=u}return n(t,null,a)},updated:function(){var n=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,t)&&(n.forEach(Oi),n.forEach(Ei),n.forEach(Li),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var e=n.elm,r=e.style;Zr(e,t),r.transform=r.WebkitTransform=r.transitionDuration="",e.addEventListener(Hr,e._moveCb=function n(r){r&&r.target!==e||r&&!/transform$/.test(r.propertyName)||(e.removeEventListener(Hr,n),e._moveCb=null,ni(e,t))})}})))},methods:{hasMove:function(n,t){if(!Wr)return!1;if(this._hasMove)return this._hasMove;var e=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){qr(e,n)})),Fr(e,t),e.style.display="none",this.$el.appendChild(e);var r=ri(e);return this.$el.removeChild(e),this._hasMove=r.hasTransform}}}};je.config.mustUseProp=function(n,t,e){return"value"===e&&Re(n)&&"button"!==t||"selected"===e&&"option"===n||"checked"===e&&"input"===n||"muted"===e&&"video"===n},je.config.isReservedTag=Xe,je.config.isReservedAttr=Me,je.config.getTagNamespace=function(n){return Ke(n)?"svg":"math"===n?"math":void 0},je.config.isUnknownElement=function(n){if(!G)return!0;if(Xe(n))return!1;if(n=n.toLowerCase(),null!=Qe[n])return Qe[n];var t=document.createElement(n);return n.indexOf("-")>-1?Qe[n]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Qe[n]=/HTMLUnknownElement/.test(t.toString())},E(je.options.directives,ki),E(je.options.components,zi),je.prototype.__patch__=G?pi:z,je.prototype.$mount=function(n,t){return function(n,t,e){var r;return n.$el=t,n.$options.render||(n.$options.render=yn),re(n,"beforeMount"),r=function(){n._update(n._render(),e)},new me(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&re(n,"beforeUpdate")}},!0),e=!1,null==n.$vnode&&(n._isMounted=!0,re(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var t=document.querySelector(n);return t||document.createElement("div")}return n}(n):void 0,t)},G&&setTimeout((function(){U.devtools&&sn&&sn.emit("init",je)}),0);var Mi=je;
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function Ri(n,t){for(var e in t)n[e]=t[e];return n}var Pi=/[!'()*]/g,Bi=function(n){return"%"+n.charCodeAt(0).toString(16)},Ni=/%2C/g,Di=function(n){return encodeURIComponent(n).replace(Pi,Bi).replace(Ni,",")};function $i(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ui=function(n){return null==n||"object"==typeof n?n:String(n)};function Fi(n){var t={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var e=n.replace(/\+/g," ").split("="),r=$i(e.shift()),i=e.length>0?$i(e.join("=")):null;void 0===t[r]?t[r]=i:Array.isArray(t[r])?t[r].push(i):t[r]=[t[r],i]})),t):t}function qi(n){var t=n?Object.keys(n).map((function(t){var e=n[t];if(void 0===e)return"";if(null===e)return Di(t);if(Array.isArray(e)){var r=[];return e.forEach((function(n){void 0!==n&&(null===n?r.push(Di(t)):r.push(Di(t)+"="+Di(n)))})),r.join("&")}return Di(t)+"="+Di(e)})).filter((function(n){return n.length>0})).join("&"):null;return t?"?"+t:""}var Vi=/\/?$/;function Ji(n,t,e,r){var i=r&&r.options.stringifyQuery,a=t.query||{};try{a=Wi(a)}catch(n){}var o={name:t.name||n&&n.name,meta:n&&n.meta||{},path:t.path||"/",hash:t.hash||"",query:a,params:t.params||{},fullPath:Ki(t,i),matched:n?Hi(n):[]};return e&&(o.redirectedFrom=Ki(e,i)),Object.freeze(o)}function Wi(n){if(Array.isArray(n))return n.map(Wi);if(n&&"object"==typeof n){var t={};for(var e in n)t[e]=Wi(n[e]);return t}return n}var Gi=Ji(null,{path:"/"});function Hi(n){for(var t=[];n;)t.unshift(n),n=n.parent;return t}function Ki(n,t){var e=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(e||"/")+(t||qi)(r)+i}function Xi(n,t,e){return t===Gi?n===t:!!t&&(n.path&&t.path?n.path.replace(Vi,"")===t.path.replace(Vi,"")&&(e||n.hash===t.hash&&Qi(n.query,t.query)):!(!n.name||!t.name)&&(n.name===t.name&&(e||n.hash===t.hash&&Qi(n.query,t.query)&&Qi(n.params,t.params))))}function Qi(n,t){if(void 0===n&&(n={}),void 0===t&&(t={}),!n||!t)return n===t;var e=Object.keys(n).sort(),r=Object.keys(t).sort();return e.length===r.length&&e.every((function(e,i){var a=n[e];if(r[i]!==e)return!1;var o=t[e];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Qi(a,o):String(a)===String(o)}))}function Yi(n){for(var t=0;t<n.matched.length;t++){var e=n.matched[t];for(var r in e.instances){var i=e.instances[r],a=e.enteredCbs[r];if(i&&a){delete e.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var Zi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,t){var e=t.props,r=t.children,i=t.parent,a=t.data;a.routerView=!0;for(var o=i.$createElement,s=e.name,c=i.$route,l=i._routerViewCache||(i._routerViewCache={}),u=0,p=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&u++,d.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(a.routerViewDepth=u,p){var f=l[s],h=f&&f.component;return h?(f.configProps&&na(h,a,f.route,f.configProps),o(h,a,r)):o()}var m=c.matched[u],v=m&&m.components[s];if(!m||!v)return l[s]=null,o();l[s]={component:v},a.registerRouteInstance=function(n,t){var e=m.instances[s];(t&&e!==n||!t&&e===n)&&(m.instances[s]=t)},(a.hook||(a.hook={})).prepatch=function(n,t){m.instances[s]=t.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),Yi(c)};var g=m.props&&m.props[s];return g&&(Ri(l[s],{route:c,configProps:g}),na(v,a,c,g)),o(v,a,r)}};function na(n,t,e,r){var i=t.props=function(n,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(n);case"boolean":return t?n.params:void 0;default:0}}(e,r);if(i){i=t.props=Ri({},i);var a=t.attrs=t.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function ta(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ea(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ra=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ia=ba,aa=ua,oa=function(n,t){return da(ua(n,t),t)},sa=da,ca=ga,la=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ua(n,t){for(var e,r=[],i=0,a=0,o="",s=t&&t.delimiter||"/";null!=(e=la.exec(n));){var c=e[0],l=e[1],u=e.index;if(o+=n.slice(a,u),a=u+c.length,l)o+=l[1];else{var p=n[a],d=e[2],f=e[3],h=e[4],m=e[5],v=e[6],g=e[7];o&&(r.push(o),o="");var b=null!=d&&null!=p&&p!==d,y="+"===v||"*"===v,w="?"===v||"*"===v,k=e[2]||s,x=h||m;r.push({name:f||i++,prefix:d||"",delimiter:k,optional:w,repeat:y,partial:b,asterisk:!!g,pattern:x?ha(x):g?".*":"[^"+fa(k)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function pa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function da(n,t){for(var e=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(e[r]=new RegExp("^(?:"+n[r].pattern+")$",va(t)));return function(t,r){for(var i="",a=t||{},o=(r||{}).pretty?pa:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=a[c.name];if(null==u){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(ra(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(l=o(u[p]),!e[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");i+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!e[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');i+=c.prefix+l}}else i+=c}return i}}function fa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ha(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ma(n,t){return n.keys=t,n}function va(n){return n&&n.sensitive?"":"i"}function ga(n,t,e){ra(t)||(e=t||e,t=[]);for(var r=(e=e||{}).strict,i=!1!==e.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=fa(s);else{var c=fa(s.prefix),l="(?:"+s.pattern+")";t.push(s),s.repeat&&(l+="(?:"+c+l+")*"),a+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=fa(e.delimiter||"/"),p=a.slice(-u.length)===u;return r||(a=(p?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=i?"$":r&&p?"":"(?="+u+"|$)",ma(new RegExp("^"+a,va(e)),t)}function ba(n,t,e){return ra(t)||(e=t||e,t=[]),e=e||{},n instanceof RegExp?function(n,t){var e=n.source.match(/\((?!\?)/g);if(e)for(var r=0;r<e.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ma(n,t)}(n,t):ra(n)?function(n,t,e){for(var r=[],i=0;i<n.length;i++)r.push(ba(n[i],t,e).source);return ma(new RegExp("(?:"+r.join("|")+")",va(e)),t)}(n,t,e):function(n,t,e){return ga(ua(n,e),t,e)}(n,t,e)}ia.parse=aa,ia.compile=oa,ia.tokensToFunction=sa,ia.tokensToRegExp=ca;var ya=Object.create(null);function wa(n,t,e){t=t||{};try{var r=ya[n]||(ya[n]=ia.compile(n));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),r(t,{pretty:!0})}catch(n){return""}finally{delete t[0]}}function ka(n,t,e,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=Ri({},n)).params;return a&&"object"==typeof a&&(i.params=Ri({},a)),i}if(!i.path&&i.params&&t){(i=Ri({},i))._normalized=!0;var o=Ri(Ri({},t.params),i.params);if(t.name)i.name=t.name,i.params=o;else if(t.matched.length){var s=t.matched[t.matched.length-1].path;i.path=wa(s,o,t.path)}else 0;return i}var c=function(n){var t="",e="",r=n.indexOf("#");r>=0&&(t=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(e=n.slice(i+1),n=n.slice(0,i)),{path:n,query:e,hash:t}}(i.path||""),l=t&&t.path||"/",u=c.path?ta(c.path,l,e||i.append):l,p=function(n,t,e){void 0===t&&(t={});var r,i=e||Fi;try{r=i(n||"")}catch(n){r={}}for(var a in t){var o=t[a];r[a]=Array.isArray(o)?o.map(Ui):Ui(o)}return r}(c.query,i.query,r&&r.options.parseQuery),d=i.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var xa,_a=function(){},Sa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var t=this,e=this.$router,r=this.$route,i=e.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,c={},l=e.options.linkActiveClass,u=e.options.linkExactActiveClass,p=null==l?"router-link-active":l,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=o.redirectedFrom?Ji(null,ka(o.redirectedFrom),null,e):o;c[h]=Xi(r,m,this.exactPath),c[f]=this.exact||this.exactPath?c[h]:function(n,t){return 0===n.path.replace(Vi,"/").indexOf(t.path.replace(Vi,"/"))&&(!t.hash||n.hash===t.hash)&&function(n,t){for(var e in t)if(!(e in n))return!1;return!0}(n.query,t.query)}(r,m);var v=c[h]?this.ariaCurrentValue:null,g=function(n){Ta(n)&&(t.replace?e.replace(a,_a):e.push(a,_a))},b={click:Ta};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var y={class:c},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:g,isActive:c[f],isExactActive:c[h]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?n():n("span",{},w)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":v};else{var k=function n(t){var e;if(t)for(var r=0;r<t.length;r++){if("a"===(e=t[r]).tag)return e;if(e.children&&(e=n(e.children)))return e}}(this.$slots.default);if(k){k.isStatic=!1;var x=k.data=Ri({},k.data);for(var _ in x.on=x.on||{},x.on){var S=x.on[_];_ in b&&(x.on[_]=Array.isArray(S)?S:[S])}for(var T in b)T in x.on?x.on[T].push(b[T]):x.on[T]=g;var j=k.data.attrs=Ri({},k.data.attrs);j.href=s,j["aria-current"]=v}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ta(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var t=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return n.preventDefault&&n.preventDefault(),!0}}var ja="undefined"!=typeof window;function Ca(n,t,e,r,i){var a=t||[],o=e||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(t,e,r,i,a,o){var s=i.path,c=i.name;0;var l=i.pathToRegexpOptions||{},u=function(n,t,e){e||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==t)return n;return ea(t.path+"/"+n)}(s,a,l.strict);"boolean"==typeof i.caseSensitive&&(l.sensitive=i.caseSensitive);var p={path:u,regex:Ia(u,l),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ea(o+"/"+i.path):void 0;n(t,e,r,i,p,a)}));e[p.path]||(t.push(p.path),e[p.path]=p);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:i.children};n(t,e,r,h,a,p.path||"/")}c&&(r[c]||(r[c]=p))}(a,o,s,n,i)}));for(var c=0,l=a.length;c<l;c++)"*"===a[c]&&(a.push(a.splice(c,1)[0]),l--,c--);return{pathList:a,pathMap:o,nameMap:s}}function Ia(n,t){return ia(n,[],t)}function Aa(n,t){var e=Ca(n),r=e.pathList,i=e.pathMap,a=e.nameMap;function o(n,e,o){var s=ka(n,e,!1,t),l=s.name;if(l){var u=a[l];if(!u)return c(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),e&&"object"==typeof e.params)for(var d in e.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=e.params[d]);return s.path=wa(u.path,s.params),c(u,s,o)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Oa(m.regex,s.path,s.params))return c(m,s,o)}}return c(null,s)}function s(n,e){var r=n.redirect,i="function"==typeof r?r(Ji(n,e,null,t)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,e);var s=i,l=s.name,u=s.path,p=e.query,d=e.hash,f=e.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,l){a[l];return o({_normalized:!0,name:l,query:p,hash:d,params:f},void 0,e)}if(u){var h=function(n,t){return ta(n,t.parent?t.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:wa(h,f),query:p,hash:d},void 0,e)}return c(null,e)}function c(n,e,r){return n&&n.redirect?s(n,r||e):n&&n.matchAs?function(n,t,e){var r=o({_normalized:!0,path:wa(e,t.params)});if(r){var i=r.matched,a=i[i.length-1];return t.params=r.params,c(a,t)}return c(null,t)}(0,e,n.matchAs):Ji(n,e,r,t)}return{match:o,addRoute:function(n,t){var e="object"!=typeof n?a[n]:void 0;Ca([t||n],r,i,a,e),e&&e.alias.length&&Ca(e.alias.map((function(n){return{path:n,children:[t]}})),r,i,a,e)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Ca(n,r,i,a)}}}function Oa(n,t,e){var r=t.match(n);if(!r)return!1;if(!e)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(e[o.name||"pathMatch"]="string"==typeof r[i]?$i(r[i]):r[i])}return!0}var Ea=ja&&window.performance&&window.performance.now?window.performance:Date;function La(){return Ea.now().toFixed(3)}var za=La();function Ma(){return za}function Ra(n){return za=n}var Pa=Object.create(null);function Ba(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(n,""),e=Ri({},window.history.state);return e.key=Ma(),window.history.replaceState(e,"",t),window.addEventListener("popstate",$a),function(){window.removeEventListener("popstate",$a)}}function Na(n,t,e,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=Ma();if(n)return Pa[n]}(),o=i.call(n,t,e,r?a:null);o&&("function"==typeof o.then?o.then((function(n){Ja(n,a)})).catch((function(n){0})):Ja(o,a))}))}}function Da(){var n=Ma();n&&(Pa[n]={x:window.pageXOffset,y:window.pageYOffset})}function $a(n){Da(),n.state&&n.state.key&&Ra(n.state.key)}function Ua(n){return qa(n.x)||qa(n.y)}function Fa(n){return{x:qa(n.x)?n.x:window.pageXOffset,y:qa(n.y)?n.y:window.pageYOffset}}function qa(n){return"number"==typeof n}var Va=/^#\d/;function Ja(n,t){var e,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Va.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};t=function(n,t){var e=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-e.left-t.x,y:r.top-e.top-t.y}}(i,a={x:qa((e=a).x)?e.x:0,y:qa(e.y)?e.y:0})}else Ua(n)&&(t=Fa(n))}else r&&Ua(n)&&(t=Fa(n));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:n.behavior}):window.scrollTo(t.x,t.y))}var Wa,Ga=ja&&((-1===(Wa=window.navigator.userAgent).indexOf("Android 2.")&&-1===Wa.indexOf("Android 4.0")||-1===Wa.indexOf("Mobile Safari")||-1!==Wa.indexOf("Chrome")||-1!==Wa.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ha(n,t){Da();var e=window.history;try{if(t){var r=Ri({},e.state);r.key=Ma(),e.replaceState(r,"",n)}else e.pushState({key:Ra(La())},"",n)}catch(e){window.location[t?"replace":"assign"](n)}}function Ka(n){Ha(n,!0)}function Xa(n,t,e){var r=function(i){i>=n.length?e():n[i]?t(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Qa={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ya(n,t){return no(n,t,Qa.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var t={};return to.forEach((function(e){e in n&&(t[e]=n[e])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function Za(n,t){return no(n,t,Qa.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function no(n,t,e,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=t,i.type=e,i}var to=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ro(n,t){return eo(n)&&n._isRouter&&(null==t||n.type===t)}function io(n){return function(t,e,r){var i=!1,a=0,o=null;ao(n,(function(n,t,e,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var c,l=co((function(t){var i;((i=t).__esModule||so&&"Module"===i[Symbol.toStringTag])&&(t=t.default),n.resolved="function"==typeof t?t:xa.extend(t),e.components[s]=t,--a<=0&&r()})),u=co((function(n){var t="Failed to resolve async component "+s+": "+n;o||(o=eo(n)?n:new Error(t),r(o))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,u)}}})),i||r()}}function ao(n,t){return oo(n.map((function(n){return Object.keys(n.components).map((function(e){return t(n.components[e],n.instances[e],n,e)}))})))}function oo(n){return Array.prototype.concat.apply([],n)}var so="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function co(n){var t=!1;return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];if(!t)return t=!0,n.apply(this,e)}}var lo=function(n,t){this.router=n,this.base=function(n){if(!n)if(ja){var t=document.querySelector("base");n=(n=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(t),this.current=Gi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function uo(n,t,e,r){var i=ao(n,(function(n,r,i,a){var o=function(n,t){"function"!=typeof n&&(n=xa.extend(n));return n.options[t]}(n,t);if(o)return Array.isArray(o)?o.map((function(n){return e(n,r,i,a)})):e(o,r,i,a)}));return oo(r?i.reverse():i)}function po(n,t){if(t)return function(){return n.apply(t,arguments)}}lo.prototype.listen=function(n){this.cb=n},lo.prototype.onReady=function(n,t){this.ready?n():(this.readyCbs.push(n),t&&this.readyErrorCbs.push(t))},lo.prototype.onError=function(n){this.errorCbs.push(n)},lo.prototype.transitionTo=function(n,t,e){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(t){t(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),t&&t(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){e&&e(n),n&&!i.ready&&(ro(n,Qa.redirected)&&a===Gi||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(n)}))))}))},lo.prototype.confirmTransition=function(n,t,e){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!ro(n)&&eo(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(t){t(n)})):console.error(n)),e&&e(n)},c=n.matched.length-1,l=i.matched.length-1;if(Xi(n,i)&&c===l&&n.matched[c]===i.matched[l])return this.ensureURL(),n.hash&&Na(this.router,i,n,!1),s(((o=no(a=i,n,Qa.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,t){var e,r=Math.max(n.length,t.length);for(e=0;e<r&&n[e]===t[e];e++);return{updated:t.slice(0,e),activated:t.slice(e),deactivated:n.slice(e)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,h=[].concat(function(n){return uo(n,"beforeRouteLeave",po,!0)}(d),this.router.beforeHooks,function(n){return uo(n,"beforeRouteUpdate",po)}(p),f.map((function(n){return n.beforeEnter})),io(f)),m=function(t,e){if(r.pending!==n)return s(Za(i,n));try{t(n,i,(function(t){!1===t?(r.ensureURL(!0),s(function(n,t){return no(n,t,Qa.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,n))):eo(t)?(r.ensureURL(!0),s(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(s(Ya(i,n)),"object"==typeof t&&t.replace?r.replace(t):r.push(t)):e(t)}))}catch(n){s(n)}};Xa(h,m,(function(){Xa(function(n){return uo(n,"beforeRouteEnter",(function(n,t,e,r){return function(n,t,e){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(t.enteredCbs[e]||(t.enteredCbs[e]=[]),t.enteredCbs[e].push(n)),a(n)}))}}(n,e,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(Za(i,n));r.pending=null,t(n),r.router.app&&r.router.app.$nextTick((function(){Yi(n)}))}))}))},lo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},lo.prototype.setupListeners=function(){},lo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Gi,this.pending=null};var fo=function(n){function t(t,e){n.call(this,t,e),this._startLocation=ho(this.base)}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router,e=t.options.scrollBehavior,r=Ga&&e;r&&this.listeners.push(Ba());var i=function(){var e=n.current,i=ho(n.base);n.current===Gi&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Na(t,n,e,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(n){window.history.go(n)},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Ha(ea(r.base+n.fullPath)),Na(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Ka(ea(r.base+n.fullPath)),Na(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.ensureURL=function(n){if(ho(this.base)!==this.current.fullPath){var t=ea(this.base+this.current.fullPath);n?Ha(t):Ka(t)}},t.prototype.getCurrentLocation=function(){return ho(this.base)},t}(lo);function ho(n){var t=window.location.pathname,e=t.toLowerCase(),r=n.toLowerCase();return!n||e!==r&&0!==e.indexOf(ea(r+"/"))||(t=t.slice(n.length)),(t||"/")+window.location.search+window.location.hash}var mo=function(n){function t(t,e,r){n.call(this,t,e),r&&function(n){var t=ho(n);if(!/^\/#/.test(t))return window.location.replace(ea(n+"/#"+t)),!0}(this.base)||vo()}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,e=Ga&&t;e&&this.listeners.push(Ba());var r=function(){var t=n.current;vo()&&n.transitionTo(go(),(function(r){e&&Na(n.router,r,t,!0),Ga||wo(r.fullPath)}))},i=Ga?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Na(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){wo(n.fullPath),Na(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.go=function(n){window.history.go(n)},t.prototype.ensureURL=function(n){var t=this.current.fullPath;go()!==t&&(n?yo(t):wo(t))},t.prototype.getCurrentLocation=function(){return go()},t}(lo);function vo(){var n=go();return"/"===n.charAt(0)||(wo("/"+n),!1)}function go(){var n=window.location.href,t=n.indexOf("#");return t<0?"":n=n.slice(t+1)}function bo(n){var t=window.location.href,e=t.indexOf("#");return(e>=0?t.slice(0,e):t)+"#"+n}function yo(n){Ga?Ha(bo(n)):window.location.hash=n}function wo(n){Ga?Ka(bo(n)):window.location.replace(bo(n))}var ko=function(n){function t(t,e){n.call(this,t,e),this.stack=[],this.index=-1}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.push=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),t&&t(n)}),e)},t.prototype.go=function(n){var t=this,e=this.index+n;if(!(e<0||e>=this.stack.length)){var r=this.stack[e];this.confirmTransition(r,(function(){var n=t.current;t.index=e,t.updateRoute(r),t.router.afterHooks.forEach((function(t){t&&t(r,n)}))}),(function(n){ro(n,Qa.duplicated)&&(t.index=e)}))}},t.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},t.prototype.ensureURL=function(){},t}(lo),xo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Aa(n.routes||[],this);var t=n.mode||"hash";switch(this.fallback="history"===t&&!Ga&&!1!==n.fallback,this.fallback&&(t="hash"),ja||(t="abstract"),this.mode=t,t){case"history":this.history=new fo(this,n.base);break;case"hash":this.history=new mo(this,n.base,this.fallback);break;case"abstract":this.history=new ko(this,n.base);break;default:0}},_o={currentRoute:{configurable:!0}};function So(n,t){return n.push(t),function(){var e=n.indexOf(t);e>-1&&n.splice(e,1)}}xo.prototype.match=function(n,t,e){return this.matcher.match(n,t,e)},_o.currentRoute.get=function(){return this.history&&this.history.current},xo.prototype.init=function(n){var t=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var e=t.apps.indexOf(n);e>-1&&t.apps.splice(e,1),t.app===n&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=n;var e=this.history;if(e instanceof fo||e instanceof mo){var r=function(n){e.setupListeners(),function(n){var r=e.current,i=t.options.scrollBehavior;Ga&&i&&"fullPath"in n&&Na(t,n,r,!1)}(n)};e.transitionTo(e.getCurrentLocation(),r,r)}e.listen((function(n){t.apps.forEach((function(t){t._route=n}))}))}},xo.prototype.beforeEach=function(n){return So(this.beforeHooks,n)},xo.prototype.beforeResolve=function(n){return So(this.resolveHooks,n)},xo.prototype.afterEach=function(n){return So(this.afterHooks,n)},xo.prototype.onReady=function(n,t){this.history.onReady(n,t)},xo.prototype.onError=function(n){this.history.onError(n)},xo.prototype.push=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.push(n,t,e)}));this.history.push(n,t,e)},xo.prototype.replace=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.replace(n,t,e)}));this.history.replace(n,t,e)},xo.prototype.go=function(n){this.history.go(n)},xo.prototype.back=function(){this.go(-1)},xo.prototype.forward=function(){this.go(1)},xo.prototype.getMatchedComponents=function(n){var t=n?n.matched?n:this.resolve(n).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(n){return Object.keys(n.components).map((function(t){return n.components[t]}))}))):[]},xo.prototype.resolve=function(n,t,e){var r=ka(n,t=t||this.history.current,e,this),i=this.match(r,t),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,t,e){var r="hash"===e?"#"+t:t;return n?ea(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},xo.prototype.getRoutes=function(){return this.matcher.getRoutes()},xo.prototype.addRoute=function(n,t){this.matcher.addRoute(n,t),this.history.current!==Gi&&this.history.transitionTo(this.history.getCurrentLocation())},xo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Gi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(xo.prototype,_o),xo.install=function n(t){if(!n.installed||xa!==t){n.installed=!0,xa=t;var e=function(n){return void 0!==n},r=function(n,t){var r=n.$options._parentVnode;e(r)&&e(r=r.data)&&e(r=r.registerRouteInstance)&&r(n,t)};t.mixin({beforeCreate:function(){e(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Zi),t.component("RouterLink",Sa);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},xo.version="3.5.4",xo.isNavigationFailure=ro,xo.NavigationFailureType=Qa,xo.START_LOCATION=Gi,ja&&window.Vue&&window.Vue.use(xo);var To=xo;e(233),e(132),e(282),e(110),e(284),e(26),e(27),e(285);function jo(n){n.locales&&Object.keys(n.locales).forEach((function(t){n.locales[t].path=t})),Object.freeze(n)}var Co=e(60),Io=e(81),Ao=(e(131),e(19),e(46),e(235),e(236),e(38),e(23),{NotFound:function(){return Promise.all([e.e(0),e.e(4)]).then(e.bind(null,501))},Layout:function(){return Promise.all([e.e(0),e.e(2)]).then(e.bind(null,500))}}),Oo={"v-761e5d7e":function(){return e.e(5).then(e.bind(null,502))},"v-64d333aa":function(){return e.e(6).then(e.bind(null,503))},"v-648c7cfe":function(){return e.e(7).then(e.bind(null,504))},"v-c2331f12":function(){return e.e(8).then(e.bind(null,505))},"v-255c09a1":function(){return e.e(9).then(e.bind(null,506))},"v-4721bed4":function(){return e.e(10).then(e.bind(null,507))},"v-062877d6":function(){return e.e(11).then(e.bind(null,508))},"v-c44d2880":function(){return e.e(12).then(e.bind(null,509))},"v-3da84d0d":function(){return e.e(13).then(e.bind(null,510))},"v-4537776d":function(){return e.e(14).then(e.bind(null,511))},"v-536574fe":function(){return e.e(15).then(e.bind(null,512))},"v-bf924ecc":function(){return e.e(16).then(e.bind(null,513))}};function Eo(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var Lo=/-(\w)/g,zo=Eo((function(n){return n.replace(Lo,(function(n,t){return t?t.toUpperCase():""}))})),Mo=/\B([A-Z])/g,Ro=Eo((function(n){return n.replace(Mo,"-$1").toLowerCase()})),Po=Eo((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Bo(n,t){if(t)return n(t)?n(t):t.includes("-")?n(Po(zo(t))):n(Po(t))||n(Ro(t))}var No=Object.assign({},Ao,Oo),Do=function(n){return No[n]},$o=function(n){return Oo[n]},Uo=function(n){return Ao[n]},Fo=function(n){return Mi.component(n)};function qo(n){return Bo($o,n)}function Vo(n){return Bo(Uo,n)}function Jo(n){return Bo(Do,n)}function Wo(n){return Bo(Fo,n)}function Go(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return Promise.all(t.filter((function(n){return n})).map(function(){var n=Object(i.a)(Object(r.a)().mark((function n(t){var e;return Object(r.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Wo(t)||!Jo(t)){n.next=5;break}return n.next=3,Jo(t)();case 3:e=n.sent,Mi.component(t,e.default);case 5:case"end":return n.stop()}}),n)})));return function(t){return n.apply(this,arguments)}}()))}function Ho(n,t){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=t)}var Ko=e(144),Xo=(e(130),e(118),e(83),e(223)),Qo=e.n(Xo),Yo=e(224),Zo=e.n(Yo),ns={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Ko.a)(n,1)[0]})).map((function(n){var t=Object(Ko.a)(n,2);t[0];return t[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(t=n)?t.map((function(n){var t="<meta";return Object.keys(n).forEach((function(e){t+=" ".concat(e,'="').concat(Zo()(n[e]),'"')})),t+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=es(this.$canonicalUrl)}var t},mounted:function(){this.currentMetaTags=Object(Io.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=rs(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Qo()([{name:"description",content:this.$description}],n,this.siteMeta,is)},updateCanonicalLink:function(){ts(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",es(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){rs(null,this.currentMetaTags),ts()}};function ts(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function es(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function rs(n,t){if(t&&Object(Io.a)(t).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var t=document.createElement("meta");return Object.keys(n).forEach((function(e){t.setAttribute(e,n[e])})),document.head.appendChild(t),t}))}function is(n){for(var t=0,e=["name","property","itemprop"];t<e.length;t++){var r=e[t];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}e(146);var as=e(157),os={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:e.n(as)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,t=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return t.some((function(t){return t.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,o=0;o<e.length;o++){var s=e[o],c=e[o+1],l=0===o&&0===r||r>=s.parentElement.offsetTop+10&&(!c||r<c.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(l&&u!==decodeURIComponent(s.hash)){var p=s;if(a===i)for(var d=o+1;d<e.length;d++)if(u===decodeURIComponent(e[d].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(p.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ss=(e(87),e(109)),cs=e.n(ss),ls={mounted:function(){var n=this;cs.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,t,e){n.path===t.path||Mi.component(n.name)||cs.a.start(),e()})),this.$router.afterEach((function(){cs.a.done(),n.isSidebarOpen=!1}))}};e(85),e(61),e(88),e(388);function us(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}e(111);function ps(n,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ds(n,t,e){return t&&ps(n.prototype,t),e&&ps(n,e),Object.defineProperty(n,"prototype",{writable:!1}),n}e(389);var fs=function(){function n(){us(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ds(n,[{key:"show",value:function(n){var t=this,e=n.text,r=void 0===e?"":e,i=n.duration,a=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(o),a>0&&setTimeout((function(){t.close(o)}),a)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),hs={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(t){document.querySelectorAll(t).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var t=this;if(!n.classList.contains("codecopy-enabled")){var e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",(function(){t.copyToClipboard(n.innerText)})),n.appendChild(e),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var t=document.createElement("textarea");t.value=n,t.setAttribute("readonly",""),t.style.position="absolute",t.style.left="-9999px",document.body.appendChild(t);var e=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);t.select(),document.execCommand("copy"),(new fs).show({text:"复制成功",duration:1e3}),document.body.removeChild(t),e&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(e))}}};e(238),e(84),e(145),e(147),e(391);!function(n,t){void 0===t&&(t={});var e=t.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===e&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var ms={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},vs={},gs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},bs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:ms[n]},ys=function n(t,e,r){var i=document.createElement(t);return e&&Object.keys(e).forEach((function(n){if(n.indexOf("data"))i[n]=e[n];else{var t=n.replace("data","");i.dataset[t]=e[n]}})),r&&r.forEach((function(t){var e=t.tag,r=t.attrs,a=t.children;i.appendChild(n(e,r,a))})),i},ws=function(n,t,e){var r,i=(r=n.querySelectorAll(".".concat(t)),Array.prototype.slice.call(r));return 1!==i.length||e?i:i[0]},ks=function(n,t){var e,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};s.htmlTpl=gs(s.html),s.jsTpl=(e=s.js,r=e.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,t){var e=n.split(/export\s+default/),r="(function() {".concat(e[0]," ; return ").concat(e[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=t,a}(s.js,s.html);var c=bs("vue");return s.jsLib.unshift(c),s},xs=function(n,t){var e,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:t.jsLib||[],cssLib:t.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(e=o.js,window.Babel?window.Babel.transform(e,{presets:["es2015"]}).code:e),o},_s=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ss(){var n=ws(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var t=ws(n,"vuepress-plugin-demo-block__code"),e=ws(n,"vuepress-plugin-demo-block__display"),r=ws(n,"vuepress-plugin-demo-block__footer"),i=ws(e,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var c=t.querySelector("div").clientHeight,l="react"===s?function(n,t){var e=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(e,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:t.jsLib||[],cssLib:t.cssLib||[],jsTpl:_s(n),htmlTpl:gs("")},o=bs("react"),s=bs("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?xs(a,o):ks(a,o),u=ys("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Ts.bind(null,u,c,t,r)),bs("jsfiddle")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(bs("cssLib")).concat(bs("jsLib")).join(",");return ys("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:t}},{tag:"input",attrs:{type:"hidden",name:"html",value:e}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),bs("codepen")&&r.appendChild(function(n){var t=n.css,e=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:t,html:e,js:r,js_external:i.concat(bs("jsLib")).join(";"),css_external:a.concat(bs("cssLib")).join(";"),layout:bs("codepenLayout"),js_pre_processor:bs("codepenJsProcessor"),editors:bs("codepenEditors")});return ys("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==o.horizontal?o.horizontal:bs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=t.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),e.appendChild(p)}if(l.css&&function(n){if(!vs[n]){var t=ys("style",{innerHTML:n});document.body.appendChild(t),vs[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),i);else if("vue"===s){var d=(new(Vue.extend(l.script))).$mount();i.appendChild(d.$el)}else"vanilla"===s&&(i.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ss()}),300)}function Ts(n,t,e,r){var i="1"!==n.dataset.isExpand;e.style.height=i?"".concat(t,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var js={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ss()},updated:function(){Ss()}},Cs=(e(227),"auto"),Is="zoom-in",As="zoom-out",Os="grab",Es="move";function Ls(n,t,e){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(t,e,i):n.removeEventListener(t,e,i)}function zs(n,t){if(n){var e=new Image;e.onload=function(){t&&t(e)},e.src=n}}function Ms(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Rs(n,t,e){!function(n){var t=Ps,e=Bs;if(n.transition){var r=n.transition;delete n.transition,n[t]=r}if(n.transform){var i=n.transform;delete n.transform,n[e]=i}}(t);var r=n.style,i={};for(var a in t)e&&(i[a]=r[a]||""),r[a]=t[a];return i}var Ps="transition",Bs="transform",Ns="transform",Ds="transitionend";var $s=function(){},Us={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:$s,onClose:$s,onGrab:$s,onMove:$s,onRelease:$s,onBeforeOpen:$s,onBeforeClose:$s,onBeforeGrab:$s,onBeforeRelease:$s,onImageLoading:$s,onImageLoaded:$s},Fs={init:function(n){var t,e;t=this,e=n,Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((function(n){t[n]=t[n].bind(e)}))},click:function(n){if(n.preventDefault(),Vs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,t=window.pageXOffset||n.scrollLeft,e=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:t,y:e});var r=this.lastScrollPosition.x-t,i=this.lastScrollPosition.y-e,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(qs(n)&&!Vs(n)){n.preventDefault();var t=n.clientX,e=n.clientY;this.pressTimer=setTimeout(function(){this.grab(t,e)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){qs(n)&&!Vs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var t=n.touches[0],e=t.clientX,r=t.clientY;this.pressTimer=setTimeout(function(){this.grab(e,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var t=n.touches[0],e=t.clientX,r=t.clientY;this.move(e,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function qs(n){return 0===n.button}function Vs(n){return n.metaKey||n.ctrlKey}var Js={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Rs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ls(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Rs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ws="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Gs=function(){function n(n,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}}(),Hs=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r])}return n},Ks={init:function(n,t){this.el=n,this.instance=t,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ms(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,t=n.zIndex,e=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:t+1,cursor:e?Os:As,transition:Ns+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Rs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Rs(this.el,{transform:"none"})},grab:function(n,t,e){var r=Xs(),i=r.x-n,a=r.y-t;Rs(this.el,{cursor:Es,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},move:function(n,t,e){var r=Xs(),i=r.x-n,a=r.y-t;Rs(this.el,{transition:Ns,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+e)+","+(this.scale.y+e)+")"})},restoreCloseStyle:function(){Rs(this.el,this.styleClose)},restoreOpenStyle:function(){Rs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var t=this.el.cloneNode(!1);t.setAttribute("src",this.srcOriginal),t.style.position="fixed",t.style.visibility="hidden",n.appendChild(t),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(t)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Xs(),t=this.rect.left+this.rect.width/2,e=this.rect.top+this.rect.height/2;return{x:n.x-t,y:n.y-e}},calculateScale:function(){var n=this.el.dataset,t=n.zoomingHeight,e=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&t&&e)return{x:e/this.rect.width,y:t/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ws(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,c=Xs(),l={x:c.x-o,y:c.y-s},u=l.x/o,p=l.y/s,d=a+Math.min(u,p);if(i&&"string"==typeof i){var f=e||this.el.naturalWidth,h=t||this.el.naturalHeight,m=parseFloat(i)*f/(100*this.rect.width),v=parseFloat(i)*h/(100*this.rect.height);if(d>m||d>v)return{x:m,y:v}}return{x:d,y:d}}};function Xs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Qs(n,t,e){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Ls(n,r,t[r],e)}))}var Ys=function(){function n(t){!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ks),this.overlay=Object.create(Js),this.handler=Object.create(Fs),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Hs({},Us,t),this.overlay.init(this),this.handler.init(this)}return Gs(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var t=document.querySelectorAll(n),e=t.length;e--;)this.listen(t[e]);else"IMG"===n.tagName&&(n.style.cursor=Is,Ls(n,"click",this.handler.click),this.options.preloadImage&&zs(Ms(n)));return this}},{key:"config",value:function(n){return n?(Hs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var t=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),zs(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ls(document,"scroll",this.handler.scroll),Ls(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ls(window,"resize",this.handler.resizeWindow);var a=function n(){Ls(r,Ds,n,!1),t.lock=!1,t.target.upgradeSource(),t.options.enableGrab&&Qs(document,t.handler,!0),e(r)};return Ls(r,Ds,a),this}}}},{key:"close",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeClose(e),this.lock=!0,this.body.style.cursor=Cs,this.overlay.fadeOut(),this.target.zoomOut(),Ls(document,"scroll",this.handler.scroll,!1),Ls(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ls(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Ls(e,Ds,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Qs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),t(e)};return Ls(e,Ds,r),this}}},{key:"grab",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,t,e);var a=function n(){Ls(i,Ds,n,!1),r(i)};return Ls(i,Ds,a),this}}},{key:"move",value:function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Es,this.target.move(n,t,e);var i=this.target.el,a=function n(){Ls(i,Ds,n,!1),r(i)};return Ls(i,Ds,a),this}}},{key:"release",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var e=this.target.el;this.options.onBeforeRelease(e),this.lock=!0,this.body.style.cursor=Cs,this.target.restoreOpenStyle();var r=function r(){Ls(e,Ds,r,!1),n.lock=!1,n.released=!0,t(e)};return Ls(e,Ds,r),this}}}]),n}(),Zs=".theme-vdoing-content img:not(.no-zoom)",nc=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),tc=Number("500"),ec=function(){function n(){us(this,n),this.instance=new Ys(nc)}return ds(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zs;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zs,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:tc;setTimeout((function(){return n.update(t)}),e)}}]),n}(),rc=[ns,os,ls,hs,js,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new ec,this.$vuepress.zooming.updateDelay()}}],ic={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Ho("layout",n),Mi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ac=e(33),oc=Object(ac.a)(ic,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,t,e){var r;switch(t){case"components":n[t]||(n[t]={}),Object.assign(n[t],e);break;case"mixins":n[t]||(n[t]=[]),(r=n[t]).push.apply(r,Object(Io.a)(e));break;default:throw new Error("Unknown option name.")}}(oc,"mixins",rc);var sc=[{name:"v-761e5d7e",path:"/pages/dcff10/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-761e5d7e").then(e)}},{path:"/pages/dcff10/index.html",redirect:"/pages/dcff10/"},{path:"/01.Java/JVM.html",redirect:"/pages/dcff10/"},{name:"v-64d333aa",path:"/pages/f9a6a6/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-64d333aa").then(e)}},{path:"/pages/f9a6a6/index.html",redirect:"/pages/f9a6a6/"},{path:"/01.Java/Java基础.html",redirect:"/pages/f9a6a6/"},{name:"v-648c7cfe",path:"/pages/f2ec12/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-648c7cfe").then(e)}},{path:"/pages/f2ec12/index.html",redirect:"/pages/f2ec12/"},{path:"/01.Java/Java并发.html",redirect:"/pages/f2ec12/"},{name:"v-c2331f12",path:"/pages/3dacb0/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-c2331f12").then(e)}},{path:"/pages/3dacb0/index.html",redirect:"/pages/3dacb0/"},{path:"/01.Java/Java集合.html",redirect:"/pages/3dacb0/"},{name:"v-255c09a1",path:"/pages/b825b8/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-255c09a1").then(e)}},{path:"/pages/b825b8/index.html",redirect:"/pages/b825b8/"},{path:"/01.Java/NIO.html",redirect:"/pages/b825b8/"},{name:"v-4721bed4",path:"/pages/f4d6a4/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-4721bed4").then(e)}},{path:"/pages/f4d6a4/index.html",redirect:"/pages/f4d6a4/"},{path:"/02.数据库/ES.html",redirect:"/pages/f4d6a4/"},{name:"v-062877d6",path:"/pages/fa91e2/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-062877d6").then(e)}},{path:"/pages/fa91e2/index.html",redirect:"/pages/fa91e2/"},{path:"/02.数据库/MogoDB.html",redirect:"/pages/fa91e2/"},{name:"v-c44d2880",path:"/pages/7e2298/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-c44d2880").then(e)}},{path:"/pages/7e2298/index.html",redirect:"/pages/7e2298/"},{path:"/02.数据库/MySQL.html",redirect:"/pages/7e2298/"},{name:"v-3da84d0d",path:"/pages/7e5d5d/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-3da84d0d").then(e)}},{path:"/pages/7e5d5d/index.html",redirect:"/pages/7e5d5d/"},{path:"/03.计算机基础/MybastisPlus.html",redirect:"/pages/7e5d5d/"},{name:"v-4537776d",path:"/pages/4501c4/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-4537776d").then(e)}},{path:"/pages/4501c4/index.html",redirect:"/pages/4501c4/"},{path:"/03.计算机基础/SpringBoot.html",redirect:"/pages/4501c4/"},{name:"v-536574fe",path:"/archives/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-536574fe").then(e)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-bf924ecc",path:"/",component:oc,beforeEnter:function(n,t,e){Go("Layout","v-bf924ecc").then(e)}},{path:"/index.html",redirect:"/"},{path:"*",component:oc}],cc={title:"Jerry's Binlog",description:"Write the Code. Change the World.",base:"/notes/",headTags:[["link",{rel:"icon",href:"/notes/img/favicon.ico"}],["meta",{name:"keywords",content:"qianyizzz,wxy"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"JVM",frontmatter:{title:"JVM",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/dcff10/"},regularPath:"/01.Java/JVM.html",relativePath:"01.Java/JVM.md",key:"v-761e5d7e",path:"/pages/dcff10/",headers:[{level:2,title:"一、什么是JVM",slug:"一、什么是jvm",normalizedTitle:"一、什么是jvm",charIndex:2},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:15},{level:3,title:"好处",slug:"好处",normalizedTitle:"好处",charIndex:73},{level:3,title:"比较",slug:"比较",normalizedTitle:"比较",charIndex:123},{level:2,title:"二、内存结构",slug:"二、内存结构",normalizedTitle:"二、内存结构",charIndex:148},{level:3,title:"整体架构",slug:"整体架构",normalizedTitle:"整体架构",charIndex:159},{level:3,title:"1、程序计数器",slug:"_1、程序计数器",normalizedTitle:"1、程序计数器",charIndex:170},{level:3,title:"2、虚拟机栈",slug:"_2、虚拟机栈",normalizedTitle:"2、虚拟机栈",charIndex:360},{level:3,title:"3、本地方法栈",slug:"_3、本地方法栈",normalizedTitle:"3、本地方法栈",charIndex:1357},{level:3,title:"4、堆",slug:"_4、堆",normalizedTitle:"4、堆",charIndex:1443},{level:3,title:"5、方法区",slug:"_5、方法区",normalizedTitle:"5、方法区",charIndex:1629},{level:3,title:"6、直接内存",slug:"_6、直接内存",normalizedTitle:"6、直接内存",charIndex:7953},{level:2,title:"三、垃圾回收",slug:"三、垃圾回收",normalizedTitle:"三、垃圾回收",charIndex:10420},{level:3,title:"1、如何判断对象可以回收",slug:"_1、如何判断对象可以回收",normalizedTitle:"1、如何判断对象可以回收",charIndex:10431},{level:3,title:"2、垃圾回收算法",slug:"_2、垃圾回收算法",normalizedTitle:"2、垃圾回收算法",charIndex:12668},{level:3,title:"3、分代回收",slug:"_3、分代回收",normalizedTitle:"3、分代回收",charIndex:13150},{level:3,title:"4、垃圾回收器",slug:"_4、垃圾回收器",normalizedTitle:"4、垃圾回收器",charIndex:13738},{level:3,title:"5、GC 调优",slug:"_5、gc-调优",normalizedTitle:"5、gc 调优",charIndex:17485},{level:2,title:"四、类加载与字节码技术",slug:"四、类加载与字节码技术",normalizedTitle:"四、类加载与字节码技术",charIndex:18210},{level:3,title:"1、类文件结构",slug:"_1、类文件结构",normalizedTitle:"1、类文件结构",charIndex:18228},{level:3,title:"2、字节码指令",slug:"_2、字节码指令",normalizedTitle:"2、字节码指令",charIndex:21467},{level:3,title:"3、编译期处理",slug:"_3、编译期处理",normalizedTitle:"3、编译期处理",charIndex:37406},{level:3,title:"4、类加载阶段",slug:"_4、类加载阶段",normalizedTitle:"4、类加载阶段",charIndex:46647},{level:3,title:"5、类加载器",slug:"_5、类加载器",normalizedTitle:"5、类加载器",charIndex:48801},{level:3,title:"6、运行期优化",slug:"_6、运行期优化",normalizedTitle:"6、运行期优化",charIndex:51867},{level:2,title:"五、内存模型",slug:"五、内存模型",normalizedTitle:"五、内存模型",charIndex:57281}],headersStr:"一、什么是JVM 定义 好处 比较 二、内存结构 整体架构 1、程序计数器 2、虚拟机栈 3、本地方法栈 4、堆 5、方法区 6、直接内存 三、垃圾回收 1、如何判断对象可以回收 2、垃圾回收算法 3、分代回收 4、垃圾回收器 5、GC 调优 四、类加载与字节码技术 1、类文件结构 2、字节码指令 3、编译期处理 4、类加载阶段 5、类加载器 6、运行期优化 五、内存模型",content:'# 一、什么是JVM\n\n\n# 定义\n\nJava Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）\n\n\n# 好处\n\n * 一次编写，到处运行\n * 自动内存管理，垃圾回收机制\n * 数组下标越界检查\n\n\n# 比较\n\nJVM JRE JDK的区别\n\n\n\n\n# 二、内存结构\n\n\n# 整体架构\n\n\n\n\n# 1、程序计数器\n\n# 作用\n\n用于保存JVM中下一条所要执行的指令的地址\n\n# 特点\n\n * 线程私有\n   * CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码\n   * 程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\n * 不会存在内存溢出\n\n\n# 2、虚拟机栈\n\n# 定义\n\n * 每个线程运行需要的内存空间，称为虚拟机栈\n * 每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存\n * 每个线程只能有一个活动栈帧，对应着当前正在执行的方法\n\n# 演示\n\n代码\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tmethod1();\n\t}\n\n\tprivate static void method1() {\n\t\tmethod2(1, 2);\n\t}\n\n\tprivate static int method2(int a, int b) {\n\t\tint c = a + b;\n\t\treturn c;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点\n\n# 问题辨析\n\n * 垃圾回收是否涉及栈内存？\n   * 不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n * 栈内存的分配越大越好吗？\n   * 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\n * 方法内的局部变量是否是线程安全的？\n   * 如果方法内局部变量没有逃离方法的作用范围，则是线程安全的\n   * 如果如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题\n\n# 内存溢出\n\nJava.lang.stackOverflowError 栈内存溢出\n\n发生原因\n\n * 虚拟机栈中，栈帧过多（无限递归）\n * 每个栈帧所占用过大\n\n# 线程运行诊断\n\nCPU占用过高\n\n * Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程\n   * top命令，查看是哪个进程占用CPU过高\n   * ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高\n   * jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16进制的，需要转换\n\n\n# 3、本地方法栈\n\n一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法\n\n\n# 4、堆\n\n# 定义\n\n通过new关键字创建的对象都会被放在堆内存\n\n# 特点\n\n * 所有线程共享，堆内存中的对象都需要考虑线程安全问题\n * 有垃圾回收机制\n\n# 堆内存溢出\n\njava.lang.OutofMemoryError ：java heap space. 堆内存溢出\n\n# 堆内存诊断\n\njps\n\njmap\n\njconsole\n\njvirsalvm\n\n\n# 5、方法区\n\n# 结构\n\n\n\n# 内存溢出\n\n * 1.8以前会导致永久代内存溢出\n * 1.8以后会导致元空间内存溢出\n\n# 常量池\n\n二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）\n\n通过反编译来查看类的信息\n\n * 获得对应类的.class文件\n   \n   * 在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入\n     \n     \n   \n   * 输入 javac 对应类的绝对路径\n     \n     F:\\JAVA\\JDK8.0\\bin>javac F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.java\n     \n     \n     1\n     \n     \n     输入完成后，对应的目录下就会出现类的.class文件\n\n * 在控制台输入 javap -v 类的绝对路径\n   \n   javap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class\n   \n   \n   1\n   \n\n * 然后能在控制台看到反编译以后类的信息了\n   \n   * 类的基本信息\n     \n     \n   \n   * 常量池\n     \n     \n     \n     \n   \n   * 虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）\n     \n     \n\n# 运行时常量池\n\n * 常量池\n   * 就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息\n * 运行时常量池\n   * 常量池是*.class文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n# 常量池与串池的关系\n\n# 串池StringTable\n\n特征\n\n * 常量池中的字符串仅是符号，只有在被用到时才会转化为对象\n * 利用串池的机制，来避免重复创建字符串对象\n * 字符串变量拼接的原理是StringBuilder\n * 字符串常量拼接的原理是编译器优化\n * 可以使用intern方法，主动将串池中还没有的字符串对象放入串池中\n * 注意：无论是串池还是堆里面的字符串，都是对象\n\n用来放字符串对象且里面的元素不重复\n\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = "a"; \n\t\tString b = "b";\n\t\tString ab = "ab";\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，还没有成为java字符串\n\n0: ldc           #2                  // String a\n2: astore_1\n3: ldc           #3                  // String b\n5: astore_2\n6: ldc           #4                  // String ab\n8: astore_3\n9: return\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，并放入串池中（hashtable结构 不可扩容）\n\n当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中\n\n当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中\n\n最终StringTable [“a”, “b”, “ab”]\n\n注意：字符串对象的创建都是懒惰的，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。\n\n使用拼接字符串变量对象创建字符串的过程\n\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = "a";\n\t\tString b = "b";\n\t\tString ab = "ab";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tString ab2 = a+b; \n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n反编译后的结果\n\n\t Code:\n      stack=2, locals=5, args_size=1\n         0: ldc           #2                  // String a\n         2: astore_1\n         3: ldc           #3                  // String b\n         5: astore_2\n         6: ldc           #4                  // String ab\n         8: astore_3\n         9: new           #5                  // class java/lang/StringBuilder\n        12: dup\n        13: invokespecial #6                  // Method java/lang/StringBuilder."<init>":()V\n        16: aload_1\n        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String\n;)Ljava/lang/StringBuilder;\n        20: aload_2\n        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String\n;)Ljava/lang/StringBuilder;\n        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str\ning;\n        27: astore        4\n        29: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过拼接的方式来创建字符串的过程是：StringBuilder().append(“a”).append(“b”).toString()\n\n最后的toString方法的返回值是一个新的字符串，但字符串的值和拼接的字符串一致，但是两个不同的字符串，一个存在于串池之中，一个存在于堆内存之中\n\nString ab = "ab";\nString ab2 = a+b;\n//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中\nSystem.out.println(ab == ab2);\n\n\n1\n2\n3\n4\n\n\n使用拼接字符串常量对象的方法创建字符串\n\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = "a";\n\t\tString b = "b";\n\t\tString ab = "ab";\n\t\tString ab2 = a+b;\n\t\t//使用拼接字符串的方法创建字符串\n\t\tString ab3 = "a" + "b";\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n反编译后的结果\n\n \t  Code:\n      stack=2, locals=6, args_size=1\n         0: ldc           #2                  // String a\n         2: astore_1\n         3: ldc           #3                  // String b\n         5: astore_2\n         6: ldc           #4                  // String ab\n         8: astore_3\n         9: new           #5                  // class java/lang/StringBuilder\n        12: dup\n        13: invokespecial #6                  // Method java/lang/StringBuilder."<init>":()V\n        16: aload_1\n        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String\n;)Ljava/lang/StringBuilder;\n        20: aload_2\n        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String\n;)Ljava/lang/StringBuilder;\n        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str\ning;\n        27: astore        4\n        //ab3初始化时直接从串池中获取字符串\n        29: ldc           #4                  // String ab\n        31: astore        5\n        33: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 使用拼接字符串常量的方法来创建新的字符串时，因为内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。\n * 使用拼接字符串变量的方法来创建新的字符串时，因为内容是变量，只能在运行期确定它的值，所以需要使用StringBuilder来创建\n\n# intern方法 1.8\n\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n * 如果串池中没有该字符串对象，则放入成功\n * 如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n\n注意：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象\n\n例1\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t//"a" "b" 被放入串池中，str则存在于堆内存之中\n\t\tString str = new String("a") + new String("b");\n\t\t//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象\n\t\tString st2 = str.intern();\n\t\t//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回\n\t\tString str3 = "ab";\n\t\t//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true\n\t\tSystem.out.println(str == st2);\n\t\tSystem.out.println(str == str3);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例2\n\npublic class Main {\n\tpublic static void main(String[] args) {\n        //此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中\n\t\tString str3 = "ab";\n        //"a" "b" 被放入串池中，str则存在于堆内存之中\n\t\tString str = new String("a") + new String("b");\n        //此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"\n\t\tString str2 = str.intern();\n        //false\n\t\tSystem.out.println(str == str2);\n        //false\n\t\tSystem.out.println(str == str3);\n        //true\n\t\tSystem.out.println(str2 == str3);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# intern方法 1.6\n\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n * 如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中\n * 如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n\n注意：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象\n\n# StringTable 垃圾回收\n\nStringTable在内存紧张时，会发生垃圾回收\n\n# StringTable调优\n\n * 因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间\n   \n   -XX:StringTableSize=xxxx\n   \n   \n   1\n   \n\n * 考虑是否需要将字符串对象入池\n   \n   可以通过intern方法减少重复入池\n\n\n# 6、直接内存\n\n * 属于操作系统，常见于NIO操作时，用于数据缓冲区\n * 分配回收成本较高，但读写性能高\n * 不受JVM内存回收管理\n\n# 文件读写流程\n\n\n\n使用了DirectBuffer\n\n\n\n直接内存是操作系统和Java代码都可以访问的一块区域，无需将代码从系统内存复制到Java堆内存，从而提高了效率\n\n# 释放原理\n\n直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过unsafe.freeMemory来手动释放\n\n通过\n\n//通过ByteBuffer申请1M的直接内存\nByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);\n\n\n1\n2\n\n\n申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？\n\nallocateDirect的实现\n\npublic static ByteBuffer allocateDirect(int capacity) {\n    return new DirectByteBuffer(capacity);\n}\n\n\n1\n2\n3\n\n\nDirectByteBuffer类\n\nDirectByteBuffer(int cap) {   // package-private\n   \n    super(-1, 0, cap, cap);\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n        base = unsafe.allocateMemory(size); //申请内存\n    } catch (OutOfMemoryError x) {\n        Bits.unreserveMemory(size, cap);\n        throw x;\n    }\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n        // Round up to page boundary\n        address = base + ps - (base & (ps - 1));\n    } else {\n        address = base;\n    }\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象\n    att = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存\n\npublic void clean() {\n       if (remove(this)) {\n           try {\n               this.thunk.run(); //调用run方法\n           } catch (final Throwable var2) {\n               AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                   public Void run() {\n                       if (System.err != null) {\n                           (new Error("Cleaner terminated abnormally", var2)).printStackTrace();\n                       }\n\n                       System.exit(1);\n                       return null;\n                   }\n               });\n           }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对应对象的run方法\n\npublic void run() {\n    if (address == 0) {\n        // Paranoia\n        return;\n    }\n    unsafe.freeMemory(address); //释放直接内存中占用的内存\n    address = 0;\n    Bits.unreserveMemory(size, capacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 直接内存的回收机制总结\n\n * 使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法\n * ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存\n\n\n# 三、垃圾回收\n\n\n# 1、如何判断对象可以回收\n\n# 引用计数法\n\n弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放\n\n\n\n# 可达性分析算法\n\n * JVM中的垃圾回收器通过可达性分析来探索所有存活的对象\n * 扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收\n * 可以作为GC Root的对象\n   * 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n   * 方法区中类静态属性引用的对象\n   * 方法区中常量引用的对象\n   * 本地方法栈中JNI（即一般说的Native方法）引用的对象\n\n# 五种引用\n\n\n\n# 强引用\n\n只有GC Root都不引用该对象时，才会回收强引用对象\n\n * 如上图B、C对象都不引用A1对象时，A1对象才会被回收\n\n# 软引用\n\n当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象\n\n * 如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收\n\n# 软引用的使用\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tfinal int _4M = 4*1024*1024;\n\t\t//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用\n\t\tList<SoftReference<byte[]>> list = new ArrayList<>();\n\t\tSoftReference<byte[]> ref= new SoftReference<>(new byte[_4M]);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，软引用本身不会被清理\n\n如果想要清理软引用，需要使用引用队列\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tfinal int _4M = 4*1024*1024;\n\t\t//使用引用队列，用于移除引用为空的软引用对象\n\t\tReferenceQueue<byte[]> queue = new ReferenceQueue<>();\n\t\t//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用\n\t\tList<SoftReference<byte[]>> list = new ArrayList<>();\n\t\tSoftReference<byte[]> ref= new SoftReference<>(new byte[_4M]);\n\n\t\t//遍历引用队列，如果有元素，则移除\n\t\tReference<? extends byte[]> poll = queue.poll();\n\t\twhile(poll != null) {\n\t\t\t//引用队列不为空，则从集合中移除该元素\n\t\t\tlist.remove(poll);\n\t\t\t//移动到引用队列中的下一个元素\n\t\t\tpoll = queue.poll();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n**大概思路为：**查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）\n\n# 弱引用\n\n只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象\n\n * 如上图如果B对象不再引用A3对象，则A3对象会被回收\n\n弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference\n\n# 虚引用\n\n当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法\n\n * 虚引用的一个体现是释放直接内存所分配的内存，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存\n * 如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存\n\n# 终结器引用\n\n所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了\n\n * 如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了\n\n# 引用队列\n\n * 软引用和弱引用可以配合引用队列\n   * 在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象\n * 虚引用和终结器引用必须配合引用队列\n   * 虚引用和终结器引用在使用时会关联一个引用队列\n\n\n# 2、垃圾回收算法\n\n# 标记-清除\n\n\n\n定义：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间\n\n * 这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接覆盖这段内存\n\n缺点：容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢\n\n# 标记-整理\n\n\n\n标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低\n\n# 复制\n\n\n\n\n\n\n\n\n\n将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。\n\n\n# 3、分代回收\n\n\n\n# 回收流程\n\n新创建的对象都被放在了新生代的伊甸园中\n\n\n\n当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 Minor GC\n\nMinor GC 会将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存区\n\n\n\n\n\n\n\n再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1\n\n\n\n如果幸存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中\n\n\n\n如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不再使用的对象并回收\n\n# GC 分析\n\n# 大对象处理策略\n\n当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代\n\n# 线程内存溢出\n\n某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行\n\n这是因为当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常\n\n\n# 4、垃圾回收器\n\n# 相关概念\n\n并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n\n并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上\n\n吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%\n\n# 串行\n\n * 单线程\n * 内存较小，个人电脑（CPU核数较少）\n\n\n\n安全点：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象\n\n因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态\n\n# Serial 收集器\n\nSerial收集器是最基本的、发展历史最悠久的收集器\n\n特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）\n\n# ParNew 收集器\n\nParNew收集器其实就是Serial收集器的多线程版本\n\n特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题\n\n# Serial Old 收集器\n\nSerial Old是Serial收集器的老年代版本\n\n特点：同样是单线程收集器，采用标记-整理算法\n\n# 吞吐量优先\n\n * 多线程\n * 堆内存较大，多核CPU\n * 单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短\n * JDK1.8默认使用的垃圾回收器\n\n\n\n# Parallel Scavenge 收集器\n\n与吞吐量关系密切，故也称为吞吐量优先收集器\n\n特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）\n\n该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）\n\nGC自适应调节策略：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。\n\nParallel Scavenge收集器使用两个参数控制吞吐量：\n\n * XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间\n * XX:GCRatio 直接设置吞吐量的大小\n\n# Parallel Old 收集器\n\n是Parallel Scavenge收集器的老年代版本\n\n特点：多线程，采用标记-整理算法（老年代没有幸存区）\n\n# 响应时间优先\n\n * 多线程\n * 堆内存较大，多核CPU\n * 尽可能让单次STW时间变短（尽量不影响其他线程运行）\n\n\n\n# CMS 收集器\n\nConcurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器\n\n特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片\n\n应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务\n\nCMS收集器的运行过程分为下列4步：\n\n初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题\n\n并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行\n\n重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题\n\n并发清除：对标记的对象进行清除回收\n\nCMS收集器的内存回收过程是与用户线程一起并发执行的\n\n# G1\n\n# 定义：\n\nGarbage First\n\nJDK 9以后默认使用，而且替代了CMS 收集器\n\n\n\n# 适用场景\n\n * 同时注重吞吐量和低延迟（响应时间）\n * 超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域\n * 整体上是标记-整理算法，两个区域之间是复制算法\n\n相关参数：JDK8 并不是默认开启的，所需要参数开启\n\n\n\n# G1垃圾回收阶段\n\n\n\n新生代伊甸园垃圾回收—–>内存不足，新生代回收+并发标记—–>回收新生代伊甸园、幸存区、老年代内存——>新生代伊甸园垃圾回收(重新开始)\n\n# Young Collection\n\n分区算法region\n\n分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间\n\nE：伊甸园 S：幸存区 O：老年代\n\n * 会STW\n\n\n\n\n\n\n\n# Young Collection + CM\n\nCM：并发标记\n\n * 在 Young GC 时会对 GC Root 进行初始标记\n * 在老年代占用堆内存的比例达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定\n\n\n\n# Mixed Collection\n\n会对E S O 进行全面的回收\n\n * 最终标记\n * 拷贝存活\n\n-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间\n\n问：为什么有的老年代被拷贝了，有的没拷贝？\n\n因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）\n\n\n\n# Full GC\n\nG1在老年代内存不足时（老年代所占内存超过阈值）\n\n * 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理\n * 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC\n\n# Young Collection 跨代引用\n\n * 新生代回收的跨代引用（老年代引用新生代）问题\n\n\n\n * 卡表与Remembered Set\n   * Remembered Set 存在于E中，用于保存新生代对象对应的脏卡\n     * 脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡\n * 在引用变更时通过post-write barried + dirty card queue\n * concurrent refinement threads 更新 Remembered Set\n\n\n\n# Remark\n\n重新标记阶段\n\n在垃圾回收时，收集器处理对象的过程中\n\n黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的\n\n\n\n但是在并发标记过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark\n\n过程如下\n\n * 之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态\n * 在并发标记阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它\n\n\n\n# JDK 8u20 字符串去重\n\n过程\n\n * 将所有新分配的字符串（底层是char[]）放入一个队列\n * 当新生代回收时，G1并发检查是否有重复的字符串\n * 如果字符串的值一样，就让他们引用同一个字符串对象\n * 注意，其与String.intern的区别\n   * intern关注的是字符串对象\n   * 字符串去重关注的是char[]\n   * 在JVM内部，使用了不同的字符串标\n\n优点与缺点\n\n * 节省了大量内存\n * 新生代回收时间略微增加，导致略微多占用CPU\n\n# JDK 8u40 并发标记类卸载\n\n在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类\n\n# JDK 8u60 回收巨型对象\n\n * 一个对象大于region的一半时，就称为巨型对象\n * G1不会对巨型对象进行拷贝\n * 回收时被优先考虑\n * G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉\n\n\n\n\n# 5、GC 调优\n\n查看虚拟机参数命令\n\n"F:\\JAVA\\JDK8.0\\bin\\java" -XX:+PrintFlagsFinal -version | findstr "GC"\n\n\n1\n\n\n可以根据参数去查询具体的信息\n\n# 调优领域\n\n * 内存\n * 锁竞争\n * CPU占用\n * IO\n * GC\n\n# 确定目标\n\n低延迟/高吞吐量？ 选择合适的GC\n\n * CMS G1 ZGC\n * ParallelGC\n * Zing\n\n# 最快的GC是不发生GC\n\n首先排除减少因为自身编写的代码而引发的内存问题\n\n * 查看Full GC前后的内存占用，考虑以下几个问题\n   * 数据是不是太多？\n   * 数据表示是否太臃肿\n     * 对象图\n     * 对象大小\n   * 是否存在内存泄漏\n\n# 新生代调优\n\n * 新生代的特点\n   * 所有的new操作分配内存都是非常廉价的\n     * TLAB\n   * 死亡对象回收零代价\n   * 大部分对象用过即死（朝生夕死）\n   * MInor GC 所用时间远小于Full GC\n * 新生代内存越大越好么？\n   * 不是\n     * 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降\n     * 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长\n   * 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜\n\n# 幸存区调优\n\n * 幸存区需要能够保存 当前活跃对象+需要晋升的对象\n * 晋升阈值配置得当，让长时间存活的对象尽快晋升\n\n# 老年代调优\n\n\n# 四、类加载与字节码技术\n\n\n\n\n# 1、类文件结构\n\n首先获得.class字节码文件\n\n方法：\n\n * 在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java\n * java终端中，执行javac X:...\\XXX.java\n\n\n\n以下是字节码文件\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 \n0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 \n0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 \n0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e \n0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 \n0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 \n0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 \n0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f \n0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 \n0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 \n0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 \n0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 \n0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 \n0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 \n0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64\n0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e \n0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 \n0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 \n0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c \n0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 \n0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 \n0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f \n0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 \n0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 \n0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d \n0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a \n0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b \n0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 \n0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 \n0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 \n0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 \n0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 \n0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 \n0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a \n0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b \n0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 \n0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 \n0001120 00 00 02 00 14\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n根据 JVM 规范，类文件结构如下\n\nu4 \t\t\t magic\nu2             minor_version;    \nu2             major_version;    \nu2             constant_pool_count;    \ncp_info        constant_pool[constant_pool_count-1];    \nu2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   \nu2             fields_count;    \nfield_info     fields[fields_count];   \nu2             methods_count;    \nmethod_info    methods[methods_count];    \nu2             attributes_count;    \nattribute_info attributes[attributes_count];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 魔数\n\nu4 magic\n\n对应字节码文件的0~3个字节\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n\n# 版本\n\nu2 minor_version;\n\nu2 major_version;\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n\n34H = 52，代表JDK8\n\n# 常量池\n\n见资料文件\n\n…略\n\n\n# 2、字节码指令\n\n可参考\n\nhttps://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5\n\n# javap工具\n\nOracle 提供了 javap 工具来反编译 class 文件\n\njavap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class\nF:\\Thread_study>javap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day5\\Demo1.class\nClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class\n  Last modified 2020-6-6; size 434 bytes\n  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e\n  Compiled from "Demo1.java"\npublic class com.nyima.JVM.day5.Demo1\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#15         // java/lang/Object."<init>":()V\n   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = String             #18            // hello world\n   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #5 = Class              #21            // com/nyima/JVM/day5/Demo1\n   #6 = Class              #22            // java/lang/Object\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               main\n  #12 = Utf8               ([Ljava/lang/String;)V\n  #13 = Utf8               SourceFile\n  #14 = Utf8               Demo1.java\n  #15 = NameAndType        #7:#8          // "<init>":()V\n  #16 = Class              #23            // java/lang/System\n  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;\n  #18 = Utf8               hello world\n  #19 = Class              #26            // java/io/PrintStream\n  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V\n  #21 = Utf8               com/nyima/JVM/day5/Demo1\n  #22 = Utf8               java/lang/Object\n  #23 = Utf8               java/lang/System\n  #24 = Utf8               out\n  #25 = Utf8               Ljava/io/PrintStream;\n  #26 = Utf8               java/io/PrintStream\n  #27 = Utf8               println\n  #28 = Utf8               (Ljava/lang/String;)V\n{\n  public com.nyima.JVM.day5.Demo1();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         4: return\n      LineNumberTable:\n        line 7: 0\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #3                  // String hello world\n         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n\n         8: return\n      LineNumberTable:\n        line 9: 0\n        line 10: 8\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 图解方法执行流程\n\n代码\n\npublic class Demo3_1 {    \n\tpublic static void main(String[] args) {        \n\t\tint a = 10;        \n\t\tint b = Short.MAX_VALUE + 1;        \n\t\tint c = a + b;        \n\t\tSystem.out.println(c);   \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n常量池载入运行时常量池\n\n常量池也属于方法区，只不过这里单独提出来了\n\n\n\n方法字节码载入方法区\n\n（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位\n\n\n\n执行引擎开始执行字节码\n\nbipush 10\n\n * 将一个 byte 压入操作数栈\n   \n   （其长度会补齐 4 个字节），类似的指令还有\n   \n   * sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）\n   * ldc 将一个 int 压入操作数栈\n   * ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）\n   * 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池\n\n\n\nistore 1\n\n将操作数栈栈顶元素弹出，放入局部变量表的slot 1中\n\n对应代码中的\n\na = 10\n\n\n1\n\n\n\n\n\n\nldc #3\n\n读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中\n\n注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的\n\n\n\nistore 2\n\n将操作数栈中的元素弹出，放到局部变量表的2号位置\n\n\n\n\n\niload1 iload2\n\n将局部变量表中1号位置和2号位置的元素放入操作数栈中\n\n * 因为只能在操作数栈中执行运算操作\n\n\n\n\n\niadd\n\n将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中\n\n\n\n\n\nistore 3\n\n将操作数栈中的元素弹出，放入局部变量表的3号位置\n\n\n\n\n\ngetstatic #4\n\n在运行时常量池中找到#4，发现是一个对象\n\n在堆内存中找到该对象，并将其引用放入操作数栈中\n\n\n\n\n\niload 3\n\n将局部变量表中3号位置的元素压入操作数栈中\n\n\n\ninvokevirtual 5\n\n找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法\n\n生成新的栈帧（分配 locals、stack等）\n\n传递参数，执行新栈帧中的字节码\n\n\n\n执行完毕，弹出栈帧\n\n清除 main 操作数栈内容\n\n\n\nreturn 完成 main 方法调用，弹出 main 栈帧，程序结束\n\n# 通过字节码指令来分析问题\n\n代码\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tint i=0;\n\t\tint x=0;\n\t\twhile(i<10) {\n\t\t\tx = x++;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(x); //接过为0\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓\n\nCode:\n     stack=2, locals=3, args_size=1\t//操作数栈分配2个空间，局部变量表分配3个空间\n        0: iconst_0\t//准备一个常数0\n        1: istore_1\t//将常数0放入局部变量表的1号槽位 i=0\n        2: iconst_0\t//准备一个常数0\n        3: istore_2\t//将常数0放入局部变量的2号槽位 x=0\t\n        4: iload_1\t\t//将局部变量表1号槽位的数放入操作数栈中\n        5: bipush        10\t//将数字10放入操作数栈中，此时操作数栈中有2个数\n        7: if_icmpge     21\t//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空\n       10: iload_2\t\t//将局部变量2号槽位的数放入操作数栈中，放入的值是0\n       11: iinc          2, 1\t//将局部变量2号槽位的数加1，自增后，槽位中的值为1\n       14: istore_2\t//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0\n       15: iinc          1, 1 //1号槽位的值自增1\n       18: goto          4 //跳转到第4条指令\n       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       24: iload_2\n       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V\n       28: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 构造方法\n\n# cinit()V\n\npublic class Demo3 {\n\tstatic int i = 10;\n\n\tstatic {\n\t\ti = 20;\n\t}\n\n\tstatic {\n\t\ti = 30;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(i); //结果为30\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()V ：\n\nstack=1, locals=0, args_size=0\n         0: bipush        10\n         2: putstatic     #3                  // Field i:I\n         5: bipush        20\n         7: putstatic     #3                  // Field i:I\n        10: bipush        30\n        12: putstatic     #3                  // Field i:I\n        15: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# init()V\n\npublic class Demo4 {\n\tprivate String a = "s1";\n\n\t{\n\t\tb = 20;\n\t}\n\n\tprivate int b = 10;\n\n\t{\n\t\ta = "s2";\n\t}\n\n\tpublic Demo4(String a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDemo4 d = new Demo4("s3", 30);\n\t\tSystem.out.println(d.a);\n\t\tSystem.out.println(d.b);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后\n\nCode:\n     stack=2, locals=3, args_size=3\n        0: aload_0\n        1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n        4: aload_0\n        5: ldc           #2                  // String s1\n        7: putfield      #3                  // Field a:Ljava/lang/String;\n       10: aload_0\n       11: bipush        20\n       13: putfield      #4                  // Field b:I\n       16: aload_0\n       17: bipush        10\n       19: putfield      #4                  // Field b:I\n       22: aload_0\n       23: ldc           #5                  // String s2\n       25: putfield      #3                  // Field a:Ljava/lang/String;\n       //原始构造方法在最后执行\n       28: aload_0\n       29: aload_1\n       30: putfield      #3                  // Field a:Ljava/lang/String;\n       33: aload_0\n       34: iload_2\n       35: putfield      #4                  // Field b:I\n       38: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 方法调用\n\npublic class Demo5 {\n\tpublic Demo5() {\n\n\t}\n\n\tprivate void test1() {\n\n\t}\n\n\tprivate final void test2() {\n\n\t}\n\n\tpublic void test3() {\n\n\t}\n\n\tpublic static void test4() {\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDemo5 demo5 = new Demo5();\n\t\tdemo5.test1();\n\t\tdemo5.test2();\n\t\tdemo5.test3();\n\t\tDemo5.test4();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n不同方法在调用时，对应的虚拟机指令有所区别\n\n * 私有、构造、被final修饰的方法，在调用时都使用invokespecial指令\n * 普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定\n * 静态方法在调用时使用invokestatic指令\n\nCode:\n      stack=2, locals=2, args_size=1\n         0: new           #2                  // class com/nyima/JVM/day5/Demo5 \n         3: dup\n         4: invokespecial #3                  // Method "<init>":()V\n         7: astore_1\n         8: aload_1\n         9: invokespecial #4                  // Method test1:()V\n        12: aload_1\n        13: invokespecial #5                  // Method test2:()V\n        16: aload_1\n        17: invokevirtual #6                  // Method test3:()V\n        20: invokestatic  #7                  // Method test4:()V\n        23: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈\n * dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”😦)V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量\n * 终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定\n * 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】\n\n# 多态原理\n\n因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令\n\n在执行invokevirtual指令时，经历了以下几个步骤\n\n * 先通过栈帧中对象的引用找到对象\n * 分析对象头，找到对象实际的Class\n * Class结构中有vtable\n * 查询vtable找到方法的具体地址\n * 执行方法的字节码\n\n# 异常处理\n\n# try-catch\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t}catch (Exception e) {\n\t\t\ti = 20;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对应字节码指令\n\nCode:\n     stack=1, locals=3, args_size=1\n        0: iconst_0\n        1: istore_1\n        2: bipush        10\n        4: istore_1\n        5: goto          12\n        8: astore_2\n        9: bipush        20\n       11: istore_1\n       12: return\n     //多出来一个异常表\n     Exception table:\n        from    to  target type\n            2     5     8   Class java/lang/Exception\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号\n * 8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）\n\n# 多个single-catch\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t}catch (ArithmeticException e) {\n\t\t\ti = 20;\n\t\t}catch (Exception e) {\n\t\t\ti = 30;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对应的字节码\n\nCode:\n     stack=1, locals=3, args_size=1\n        0: iconst_0\n        1: istore_1\n        2: bipush        10\n        4: istore_1\n        5: goto          19\n        8: astore_2\n        9: bipush        20\n       11: istore_1\n       12: goto          19\n       15: astore_2\n       16: bipush        30\n       18: istore_1\n       19: return\n     Exception table:\n        from    to  target type\n            2     5     8   Class java/lang/ArithmeticException\n            2     5    15   Class java/lang/Exception\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用\n\n# finally\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t} catch (Exception e) {\n\t\t\ti = 20;\n\t\t} finally {\n\t\t\ti = 30;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对应字节码\n\nCode:\n     stack=1, locals=4, args_size=1\n        0: iconst_0\n        1: istore_1\n        //try块\n        2: bipush        10\n        4: istore_1\n        //try块执行完后，会执行finally    \n        5: bipush        30\n        7: istore_1\n        8: goto          27\n       //catch块     \n       11: astore_2 //异常信息放入局部变量表的2号槽位\n       12: bipush        20\n       14: istore_1\n       //catch块执行完后，会执行finally        \n       15: bipush        30\n       17: istore_1\n       18: goto          27\n       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   \n       21: astore_3\n       22: bipush        30\n       24: istore_1\n       25: aload_3\n       26: athrow  //抛出异常\n       27: return\n     Exception table:\n        from    to  target type\n            2     5    11   Class java/lang/Exception\n            2     5    21   any\n           11    15    21   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n可以看到 ﬁnally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程\n\n注意：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次\n\n# finally中的return\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tint i = Demo3.test();\n        //结果为20\n\t\tSystem.out.println(i);\n\t}\n\n\tpublic static int test() {\n\t\tint i;\n\t\ttry {\n\t\t\ti = 10;\n\t\t\treturn i;\n\t\t} finally {\n\t\t\ti = 20;\n\t\t\treturn i;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对应字节码\n\nCode:\n     stack=1, locals=3, args_size=0\n        0: bipush        10\n        2: istore_0\n        3: iload_0\n        4: istore_1  //暂存返回值\n        5: bipush        20\n        7: istore_0\n        8: iload_0\n        9: ireturn\t//ireturn会返回操作数栈顶的整型值20\n       //如果出现异常，还是会执行finally块中的内容，没有抛出异常\n       10: astore_2\n       11: bipush        20\n       13: istore_0\n       14: iload_0\n       15: ireturn\t//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！\n     Exception table:\n        from    to  target type\n            0     5    10   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准\n * 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子\n * 跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：如果在 ﬁnally 中出现了 return，会吞掉异常\n * 所以不要在finally中进行返回操作\n\n# 被吞掉的异常\n\npublic class Demo3 {\n   public static void main(String[] args) {\n      int i = Demo3.test();\n      //最终结果为20\n      System.out.println(i);\n   }\n\n   public static int test() {\n      int i;\n      try {\n         i = 10;\n         //这里应该会抛出异常\n         i = i/0;\n         return i;\n      } finally {\n         i = 20;\n         return i;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n会发现打印结果为20，并未抛出异常\n\n# finally不带return\n\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tint i = Demo4.test();\n\t\tSystem.out.println(i);\n\t}\n\n\tpublic static int test() {\n\t\tint i = 10;\n\t\ttry {\n\t\t\treturn i;\n\t\t} finally {\n\t\t\ti = 20;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n对应字节码\n\nCode:\n     stack=1, locals=3, args_size=0\n        0: bipush        10\n        2: istore_0 //赋值给i 10\n        3: iload_0\t//加载到操作数栈顶\n        4: istore_1 //加载到局部变量表的1号位置\n        5: bipush        20\n        7: istore_0 //赋值给i 20\n        8: iload_1 //加载局部变量表1号位置的数10到操作数栈\n        9: ireturn //返回操作数栈顶元素 10\n       10: astore_2\n       11: bipush        20\n       13: istore_0\n       14: aload_2 //加载异常\n       15: athrow //抛出异常\n     Exception table:\n        from    to  target type\n            3     5    10   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# Synchronized\n\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tint i = 10;\n\t\tLock lock = new Lock();\n\t\tsynchronized (lock) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\n\nclass Lock{}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对应字节码\n\nCode:\n     stack=2, locals=5, args_size=1\n        0: bipush        10\n        2: istore_1\n        3: new           #2                  // class com/nyima/JVM/day06/Lock\n        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗\n        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock."<init>":()V\n       10: astore_2 //剩下的一份放到局部变量表的2号位置\n       11: aload_2 //加载到操作数栈\n       12: dup //复制一份，放到操作数栈，用于加锁时消耗\n       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用\n       14: monitorenter //加锁\n       //锁住后代码块中的操作    \n       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       18: iload_1\n       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V\n       //加载局部变量表中三号槽位对象的引用，用于解锁    \n       22: aload_3    \n       23: monitorexit //解锁\n       24: goto          34\n       //异常操作    \n       27: astore        4\n       29: aload_3\n       30: monitorexit //解锁\n       31: aload         4\n       33: athrow\n       34: return\n     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      \n     Exception table:\n        from    to  target type\n           15    24    27   any\n           27    31    27   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 3、编译期处理\n\n所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利\n\n注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。\n\n# 默认构造函数\n\npublic class Candy1 {\n\n}\n\n\n1\n2\n3\n\n\n经过编译期优化后\n\npublic class Candy1 {\n   //这个无参构造器是java编译器帮我们加上的\n   public Candy1() {\n      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object." <init>":()V\n      super();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 自动拆装箱\n\n基本类型和其包装类型的相互转换过程，称为拆装箱\n\n在JDK 5以后，它们的转换可以在编译期自动完成\n\npublic class Demo2 {\n   public static void main(String[] args) {\n      Integer x = 1;\n      int y = x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n转换过程如下\n\npublic class Demo2 {\n   public static void main(String[] args) {\n      //基本类型赋值给包装类型，称为装箱\n      Integer x = Integer.valueOf(1);\n      //包装类型赋值给基本类型，称谓拆箱\n      int y = x.intValue();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 泛型集合取值\n\n泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：\n\npublic class Demo3 {\n   public static void main(String[] args) {\n      List<Integer> list = new ArrayList<>();\n      list.add(10);\n      Integer x = list.get(0);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对应字节码\n\nCode:\n    stack=2, locals=3, args_size=1\n       0: new           #2                  // class java/util/ArrayList\n       3: dup\n       4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V\n       7: astore_1\n       8: aload_1\n       9: bipush        10\n      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n      //这里进行了泛型擦除，实际调用的是add(Objcet o)\n      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\n\n      19: pop\n      20: aload_1\n      21: iconst_0\n      //这里也进行了泛型擦除，实际调用的是get(Object o)   \n      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;\n//这里进行了类型转换，将Object转换成了Integer\n      27: checkcast     #7                  // class java/lang/Integer\n      30: astore_2\n      31: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n所以调用get函数取值时，有一个类型转换的操作\n\nInteger x = (Integer) list.get(0);\n\n\n1\n\n\n如果要将返回结果赋值给一个int类型的变量，则还有自动拆箱的操作\n\nint x = (Integer) list.get(0).intValue();\n\n\n1\n\n\n# 可变参数\n\npublic class Demo4 {\n   public static void foo(String... args) {\n      //将args赋值给arr，可以看出String...实际就是String[] \n      String[] arr = args;\n      System.out.println(arr.length);\n   }\n\n   public static void main(String[] args) {\n      foo("hello", "world");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：\n\npublic class Demo4 {\n   public Demo4 {}\n\n    \n   public static void foo(String[] args) {\n      String[] arr = args;\n      System.out.println(arr.length);\n   }\n\n   public static void main(String[] args) {\n      foo(new String[]{"hello", "world"});\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，创建了一个空数组，而不是直接传递的null\n\n# foreach\n\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n        //数组赋初值的简化写法也是一种语法糖。\n\t\tint[] arr = {1, 2, 3, 4, 5};\n\t\tfor(int x : arr) {\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编译器会帮我们转换为\n\npublic class Demo5 {\n    public Demo5 {}\n\n\tpublic static void main(String[] args) {\n\t\tint[] arr = new int[]{1, 2, 3, 4, 5};\n\t\tfor(int i=0; i<arr.length; ++i) {\n\t\t\tint x = arr[i];\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果是集合使用foreach\n\npublic class Demo5 {\n   public static void main(String[] args) {\n      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n      for (Integer x : list) {\n         System.out.println(x);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n集合要使用foreach，需要该集合类实现了Iterable接口，因为集合的遍历需要用到迭代器Iterator\n\npublic class Demo5 {\n    public Demo5 {}\n    \n   public static void main(String[] args) {\n      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n      //获得该集合的迭代器\n      Iterator<Integer> iterator = list.iterator();\n      while(iterator.hasNext()) {\n         Integer x = iterator.next();\n         System.out.println(x);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# switch字符串\n\npublic class Demo6 {\n   public static void main(String[] args) {\n      String str = "hello";\n      switch (str) {\n         case "hello" :\n            System.out.println("h");\n            break;\n         case "world" :\n            System.out.println("w");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在编译器中执行的操作\n\npublic class Demo6 {\n   public Demo6() {\n      \n   }\n   public static void main(String[] args) {\n      String str = "hello";\n      int x = -1;\n      //通过字符串的hashCode+value来判断是否匹配\n      switch (str.hashCode()) {\n         //hello的hashCode\n         case 99162322 :\n            //再次比较，因为字符串的hashCode有可能相等\n            if(str.equals("hello")) {\n               x = 0;\n            }\n            break;\n         //world的hashCode\n         case 11331880 :\n            if(str.equals("world")) {\n               x = 1;\n            }\n            break;\n         default:\n            break;\n      }\n\n      //用第二个switch在进行输出判断\n      switch (x) {\n         case 0:\n            System.out.println("h");\n            break;\n         case 1:\n            System.out.println("w");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n过程说明：\n\n * 在编译期间，单个的switch被分为了两个\n   * 第一个用来匹配字符串，并给x赋值\n     * 字符串的匹配用到了字符串的hashCode，还用到了equals方法\n     * 使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）\n   * 第二个用来根据x的值来决定输出语句\n\n# switch枚举\n\npublic class Demo7 {\n   public static void main(String[] args) {\n      SEX sex = SEX.MALE;\n      switch (sex) {\n         case MALE:\n            System.out.println("man");\n            break;\n         case FEMALE:\n            System.out.println("woman");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\nenum SEX {\n   MALE, FEMALE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n编译器中执行的代码如下\n\npublic class Demo7 {\n   /**     \n    * 定义一个合成类（仅 jvm 使用，对我们不可见）     \n    * 用来映射枚举的 ordinal 与数组元素的关系     \n    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     \n    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     \n    */ \n   static class $MAP {\n      //数组大小即为枚举元素个数，里面存放了case用于比较的数字\n      static int[] map = new int[2];\n      static {\n         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1\n         map[SEX.MALE.ordinal()] = 1;\n         map[SEX.FEMALE.ordinal()] = 2;\n      }\n   }\n\n   public static void main(String[] args) {\n      SEX sex = SEX.MALE;\n      //将对应位置枚举元素的值赋给x，用于case操作\n      int x = $MAP.map[sex.ordinal()];\n      switch (x) {\n         case 1:\n            System.out.println("man");\n            break;\n         case 2:\n            System.out.println("woman");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\nenum SEX {\n   MALE, FEMALE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n# 枚举类\n\nenum SEX {\n   MALE, FEMALE;\n}\n\n\n1\n2\n3\n\n\n转换后的代码\n\npublic final class Sex extends Enum<Sex> {   \n   //对应枚举类中的元素\n   public static final Sex MALE;    \n   public static final Sex FEMALE;    \n   private static final Sex[] $VALUES;\n   \n    static {       \n    \t//调用构造函数，传入枚举元素的值及ordinal\n    \tMALE = new Sex("MALE", 0);    \n        FEMALE = new Sex("FEMALE", 1);   \n        $VALUES = new Sex[]{MALE, FEMALE}; \n   }\n \t\n   //调用父类中的方法\n    private Sex(String name, int ordinal) {     \n        super(name, ordinal);    \n    }\n   \n    public static Sex[] values() {  \n        return $VALUES.clone();  \n    }\n    public static Sex valueOf(String name) { \n        return Enum.valueOf(Sex.class, name);  \n    } \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 匿名内部类\n\npublic class Demo8 {\n   public static void main(String[] args) {\n      Runnable runnable = new Runnable() {\n         @Override\n         public void run() {\n            System.out.println("running...");\n         }\n      };\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n转换后的代码\n\npublic class Demo8 {\n   public static void main(String[] args) {\n      //用额外创建的类来创建匿名内部类对象\n      Runnable runnable = new Demo8$1();\n   }\n}\n\n//创建了一个额外的类，实现了Runnable接口\nfinal class Demo8$1 implements Runnable {\n   public Demo8$1() {}\n\n   @Override\n   public void run() {\n      System.out.println("running...");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果匿名内部类中引用了局部变量\n\npublic class Demo8 {\n   public static void main(String[] args) {\n      int x = 1;\n      Runnable runnable = new Runnable() {\n         @Override\n         public void run() {\n            System.out.println(x);\n         }\n      };\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n转化后代码\n\npublic class Demo8 {\n   public static void main(String[] args) {\n      int x = 1;\n      Runnable runnable = new Runnable() {\n         @Override\n         public void run() {\n            System.out.println(x);\n         }\n      };\n   }\n}\n\nfinal class Demo8$1 implements Runnable {\n   //多创建了一个变量\n   int val$x;\n   //变为了有参构造器\n   public Demo8$1(int x) {\n      this.val$x = x;\n   }\n\n   @Override\n   public void run() {\n      System.out.println(val$x);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4、类加载阶段\n\n# 加载\n\n * 将类的字节码载入\n   \n   方法区\n   \n   （1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：\n   \n   * _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用\n   * _super 即父类\n   * _ﬁelds 即成员变量\n   * _methods 即方法\n   * _constants 即常量池\n   * _class_loader 即类加载器\n   * _vtable 虚方法表\n   * _itable 接口方法\n\n * 如果这个类还有父类没有加载，先加载父类\n\n * 加载和链接可能是交替运行的\n\n\n\n * instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中\n * _java_mirror则是保存在堆内存中\n * InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址\n * 类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息\n\n# 链接\n\n# 验证\n\n验证类是否符合 JVM规范，安全性检查\n\n# 准备\n\n为 static 变量分配空间，设置默认值\n\n * static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了\n * static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成\n * 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成\n * 如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成\n\n# 解析\n\nHSDB的使用\n\n * 先获得要查看的进程ID\n\njps\n\n\n1\n\n * 打开HSDB\n\njava -cp F:\\JAVA\\JDK8.0\\lib\\sa-jdi.jar sun.jvm.hotspot.HSDB\n\n\n1\n\n * 运行时可能会报错，是因为缺少一个.dll的文件，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可\n\n\n\n * 定位需要的进程\n\n\n\n\n\n解析的含义\n\n将常量池中的符号引用解析为直接引用\n\n * 未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中\n\npublic class Demo1 {\n   public static void main(String[] args) throws IOException, ClassNotFoundException {\n      ClassLoader loader = Demo1.class.getClassLoader();\n      //只加载不解析\n      Class<?> c = loader.loadClass("com.nyima.JVM.day8.C");\n      //用于阻塞主线程\n      System.in.read();\n   }\n}\n\nclass C {\n   D d = new D();\n}\n\nclass D {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 打开HSDB\n   * 可以看到此时只加载了类C\n\n\n\n查看类C的常量池，可以看到类D未被解析，只是存在于常量池中的符号\n\n\n\n * 解析以后，会将常量池中的符号引用解析为直接引用\n   \n   * 可以看到，此时已加载并解析了类C和类D\n   \n   \n\n\n\n# 初始化\n\n初始化阶段就是执行类构造器clinit()方法的过程，虚拟机会保证这个类的『构造方法』的线程安全\n\n * clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的\n\n注意\n\n编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如\n\n\n\n# 发生时机\n\n类的初始化的懒惰的，以下情况会初始化\n\n * main 方法所在的类，总会被首先初始化\n * 首次访问这个类的静态变量或静态方法时\n * 子类初始化，如果父类还没初始化，会引发\n * 子类访问父类的静态变量，只会触发父类的初始化\n * Class.forName\n * new 会导致初始化\n\n以下情况不会初始化\n\n * 访问类的 static ﬁnal 静态常量（基本类型和字符串）\n * 类对象.class 不会触发初始化\n * 创建该类对象的数组\n * 类加载器的.loadClass方法\n * Class.forNamed的参数2为false时\n\n验证类是否被初始化，可以看改类的静态代码块是否被执行\n\n\n# 5、类加载器\n\nJava虚拟机设计团队有意把类加载阶段中的**“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”**（ClassLoader）\n\n# 类与类加载器\n\n类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等\n\n以JDK 8为例\n\n名称                                  加载的类                    说明\nBootstrap ClassLoader（启动类加载器）       JAVA_HOME/jre/lib       无法直接访问\nExtension ClassLoader(拓展类加载器)       JAVA_HOME/jre/lib/ext   上级为Bootstrap，显示为null\nApplication ClassLoader(应用程序类加载器)   classpath               上级为Extension\n自定义类加载器                             自定义                     上级为Application\n\n# 启动类加载器\n\n可通过在控制台输入指令，使得类被启动类加器加载\n\n# 拓展类加载器\n\n如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载\n\n# 双亲委派模式\n\n双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则\n\nloadClass源码\n\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 首先查找该类是否已经被该类加载器加载过了\n        Class<?> c = findLoadedClass(name);\n        //如果没有被加载过\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    //看是否被启动类加载器加载过\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n                //捕获异常，但不做任何处理\n            }\n\n            if (c == null) {\n                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常\n                //然后让应用类加载器去找classpath下找该类\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // 记录时间\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 自定义类加载器\n\n# 使用场景\n\n * 想加载非 classpath 随意路径中的类文件\n * 通过接口来使用实现，希望解耦时，常用在框架设计\n * 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器\n\n# 步骤\n\n * 继承ClassLoader父类\n * 要遵从双亲委派机制，重写 ﬁndClass 方法\n   * 不是重写loadClass方法，否则不会走双亲委派机制\n * 读取类文件的字节码\n * 调用父类的 deﬁneClass 方法来加载类\n * 使用者调用该类加载器的 loadClass 方法\n\n# 破坏双亲委派模式\n\n * 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代\n   * 建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法\n * 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的\n   * 如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式\n * 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的\n   * 这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等\n\n\n# 6、运行期优化\n\n# 分层编译\n\nJVM 将执行状态分成了 5 个层次：\n\n * 0层：解释执行，用解释器将字节码翻译为机器码\n * 1层：使用 C1 即时编译器编译执行（不带 proﬁling）\n * 2层：使用 C1 即时编译器编译执行（带基本的profiling）\n * 3层：使用 C1 即时编译器编译执行（带完全的profiling）\n * 4层：使用 C2 即时编译器编译执行\n\nproﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等\n\n# 即时编译器（JIT）与解释器的区别\n\n * 解释器\n   * 将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释\n   * 是将字节码解释为针对所有平台都通用的机器码\n * 即时编译器\n   * 将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译\n   * 根据平台类型，生成平台特定的机器码\n\n对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码\n\n# 逃逸分析\n\n逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术\n\n逃逸分析的 JVM 参数如下：\n\n * 开启逃逸分析：-XX:+DoEscapeAnalysis\n * 关闭逃逸分析：-XX:-DoEscapeAnalysis\n * 显示分析结果：-XX:+PrintEscapeAnalysis\n\n逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数\n\n对象逃逸状态\n\n全局逃逸（GlobalEscape）\n\n * 即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：\n   * 对象是一个静态变量\n   * 对象是一个已经发生逃逸的对象\n   * 对象作为当前方法的返回值\n\n参数逃逸（ArgEscape）\n\n * 即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的\n\n没有逃逸\n\n * 即方法中的对象没有发生逃逸\n\n逃逸分析优化\n\n针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化\n\n锁消除\n\n我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁\n\n例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作\n\n锁消除的 JVM 参数如下：\n\n * 开启锁消除：-XX:+EliminateLocks\n * 关闭锁消除：-XX:-EliminateLocks\n\n锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上\n\n标量替换\n\n首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象\n\n对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。\n\n这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能\n\n标量替换的 JVM 参数如下：\n\n * 开启标量替换：-XX:+EliminateAllocations\n * 关闭标量替换：-XX:-EliminateAllocations\n * 显示标量替换详情：-XX:+PrintEliminateAllocations\n\n标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上\n\n栈上分配\n\n当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能\n\n# 方法内联\n\n# 内联函数\n\n内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换\n\n# JVM内联函数\n\nC++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的，如\n\npublic final void doSomething() {  \n        // to do something  \n}\n\n\n1\n2\n3\n\n\n总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数\n\nJVM内建有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。\n\n第二个原因则更重要：方法内联\n\n如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：\n\nprivate int add4(int x1, int x2, int x3, int x4) { \n\t\t//这里调用了add2方法\n        return add2(x1, x2) + add2(x3, x4);  \n    }  \n\n    private int add2(int x1, int x2) {  \n        return x1 + x2;  \n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方法调用被替换后\n\nprivate int add4(int x1, int x2, int x3, int x4) {  \n    \t//被替换为了方法本身\n        return x1 + x2 + x3 + x4;  \n    }\n\n\n1\n2\n3\n4\n\n\n# 反射优化\n\npublic class Reflect1 {\n   public static void foo() {\n      System.out.println("foo...");\n   }\n\n   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n      Method foo = Demo3.class.getMethod("foo");\n      for(int i = 0; i<=16; i++) {\n         foo.invoke(null);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfoo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现\n\ninvoke方法源码\n\n@CallerSensitive\npublic Object invoke(Object obj, Object... args)\n    throws IllegalAccessException, IllegalArgumentException,\n       InvocationTargetException\n{\n    if (!override) {\n        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n            Class<?> caller = Reflection.getCallerClass();\n            checkAccess(caller, clazz, obj, modifiers);\n        }\n    }\n    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类\n    MethodAccessor ma = methodAccessor;             // read volatile\n    if (ma == null) {\n        ma = acquireMethodAccessor();\n    }\n    return ma.invoke(obj, args);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl\n\nNativeMethodAccessorImpl源码\n\nclass NativeMethodAccessorImpl extends MethodAccessorImpl {\n    private final Method method;\n    private DelegatingMethodAccessorImpl parent;\n    private int numInvocations;\n\n    NativeMethodAccessorImpl(Method var1) {\n        this.method = var1;\n    }\n\t\n\t//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一\n\t//如果numInvocation>ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法\n    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {\n        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {\n            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());\n            this.parent.setDelegate(var3);\n        }\n\n        return invoke0(this.method, var1, var2);\n    }\n\n    void setParent(DelegatingMethodAccessorImpl var1) {\n        this.parent = var1;\n    }\n\n    private static native Object invoke0(Method var0, Object var1, Object[] var2);\n}\n//ReflectionFactory.inflationThreshold()方法的返回值\nprivate static int inflationThreshold = 15;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 一开始if条件不满足，就会调用本地方法invoke0\n * 随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率\n   * 这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()\n\n\n\n\n# 五、内存模型\n\n前往JUC',normalizedContent:'# 一、什么是jvm\n\n\n# 定义\n\njava virtual machine，java程序的运行环境（java二进制字节码的运行环境）\n\n\n# 好处\n\n * 一次编写，到处运行\n * 自动内存管理，垃圾回收机制\n * 数组下标越界检查\n\n\n# 比较\n\njvm jre jdk的区别\n\n\n\n\n# 二、内存结构\n\n\n# 整体架构\n\n\n\n\n# 1、程序计数器\n\n# 作用\n\n用于保存jvm中下一条所要执行的指令的地址\n\n# 特点\n\n * 线程私有\n   * cpu会为每个线程分配时间片，当当前线程的时间片使用完以后，cpu就会去执行另一个线程中的代码\n   * 程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\n * 不会存在内存溢出\n\n\n# 2、虚拟机栈\n\n# 定义\n\n * 每个线程运行需要的内存空间，称为虚拟机栈\n * 每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存\n * 每个线程只能有一个活动栈帧，对应着当前正在执行的方法\n\n# 演示\n\n代码\n\npublic class main {\n\tpublic static void main(string[] args) {\n\t\tmethod1();\n\t}\n\n\tprivate static void method1() {\n\t\tmethod2(1, 2);\n\t}\n\n\tprivate static int method2(int a, int b) {\n\t\tint c = a + b;\n\t\treturn c;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点\n\n# 问题辨析\n\n * 垃圾回收是否涉及栈内存？\n   * 不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n * 栈内存的分配越大越好吗？\n   * 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\n * 方法内的局部变量是否是线程安全的？\n   * 如果方法内局部变量没有逃离方法的作用范围，则是线程安全的\n   * 如果如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题\n\n# 内存溢出\n\njava.lang.stackoverflowerror 栈内存溢出\n\n发生原因\n\n * 虚拟机栈中，栈帧过多（无限递归）\n * 每个栈帧所占用过大\n\n# 线程运行诊断\n\ncpu占用过高\n\n * linux环境下运行某些程序的时候，可能导致cpu的占用过高，这时需要定位占用cpu过高的线程\n   * top命令，查看是哪个进程占用cpu过高\n   * ps h -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用cpu过高\n   * jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16进制的，需要转换\n\n\n# 3、本地方法栈\n\n一些带有native关键字的方法就是需要java去调用本地的c或者c++方法，因为java有时候没法直接和操作系统底层交互，所以需要用到本地方法\n\n\n# 4、堆\n\n# 定义\n\n通过new关键字创建的对象都会被放在堆内存\n\n# 特点\n\n * 所有线程共享，堆内存中的对象都需要考虑线程安全问题\n * 有垃圾回收机制\n\n# 堆内存溢出\n\njava.lang.outofmemoryerror ：java heap space. 堆内存溢出\n\n# 堆内存诊断\n\njps\n\njmap\n\njconsole\n\njvirsalvm\n\n\n# 5、方法区\n\n# 结构\n\n\n\n# 内存溢出\n\n * 1.8以前会导致永久代内存溢出\n * 1.8以后会导致元空间内存溢出\n\n# 常量池\n\n二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）\n\n通过反编译来查看类的信息\n\n * 获得对应类的.class文件\n   \n   * 在jdk对应的bin目录下运行cmd，也可以在idea控制台输入\n     \n     \n   \n   * 输入 javac 对应类的绝对路径\n     \n     f:\\java\\jdk8.0\\bin>javac f:\\thread_study\\src\\com\\nyima\\jvm\\day01\\main.java\n     \n     \n     1\n     \n     \n     输入完成后，对应的目录下就会出现类的.class文件\n\n * 在控制台输入 javap -v 类的绝对路径\n   \n   javap -v f:\\thread_study\\src\\com\\nyima\\jvm\\day01\\main.class\n   \n   \n   1\n   \n\n * 然后能在控制台看到反编译以后类的信息了\n   \n   * 类的基本信息\n     \n     \n   \n   * 常量池\n     \n     \n     \n     \n   \n   * 虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）\n     \n     \n\n# 运行时常量池\n\n * 常量池\n   * 就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息\n * 运行时常量池\n   * 常量池是*.class文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n# 常量池与串池的关系\n\n# 串池stringtable\n\n特征\n\n * 常量池中的字符串仅是符号，只有在被用到时才会转化为对象\n * 利用串池的机制，来避免重复创建字符串对象\n * 字符串变量拼接的原理是stringbuilder\n * 字符串常量拼接的原理是编译器优化\n * 可以使用intern方法，主动将串池中还没有的字符串对象放入串池中\n * 注意：无论是串池还是堆里面的字符串，都是对象\n\n用来放字符串对象且里面的元素不重复\n\npublic class stringtablestudy {\n\tpublic static void main(string[] args) {\n\t\tstring a = "a"; \n\t\tstring b = "b";\n\t\tstring ab = "ab";\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，还没有成为java字符串\n\n0: ldc           #2                  // string a\n2: astore_1\n3: ldc           #3                  // string b\n5: astore_2\n6: ldc           #4                  // string ab\n8: astore_3\n9: return\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，并放入串池中（hashtable结构 不可扩容）\n\n当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中\n\n当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中\n\n最终stringtable [“a”, “b”, “ab”]\n\n注意：字符串对象的创建都是懒惰的，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。\n\n使用拼接字符串变量对象创建字符串的过程\n\npublic class stringtablestudy {\n\tpublic static void main(string[] args) {\n\t\tstring a = "a";\n\t\tstring b = "b";\n\t\tstring ab = "ab";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tstring ab2 = a+b; \n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n反编译后的结果\n\n\t code:\n      stack=2, locals=5, args_size=1\n         0: ldc           #2                  // string a\n         2: astore_1\n         3: ldc           #3                  // string b\n         5: astore_2\n         6: ldc           #4                  // string ab\n         8: astore_3\n         9: new           #5                  // class java/lang/stringbuilder\n        12: dup\n        13: invokespecial #6                  // method java/lang/stringbuilder."<init>":()v\n        16: aload_1\n        17: invokevirtual #7                  // method java/lang/stringbuilder.append:(ljava/lang/string\n;)ljava/lang/stringbuilder;\n        20: aload_2\n        21: invokevirtual #7                  // method java/lang/stringbuilder.append:(ljava/lang/string\n;)ljava/lang/stringbuilder;\n        24: invokevirtual #8                  // method java/lang/stringbuilder.tostring:()ljava/lang/str\ning;\n        27: astore        4\n        29: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过拼接的方式来创建字符串的过程是：stringbuilder().append(“a”).append(“b”).tostring()\n\n最后的tostring方法的返回值是一个新的字符串，但字符串的值和拼接的字符串一致，但是两个不同的字符串，一个存在于串池之中，一个存在于堆内存之中\n\nstring ab = "ab";\nstring ab2 = a+b;\n//结果为false,因为ab是存在于串池之中，ab2是由stringbuffer的tostring方法所返回的一个对象，存在于堆内存之中\nsystem.out.println(ab == ab2);\n\n\n1\n2\n3\n4\n\n\n使用拼接字符串常量对象的方法创建字符串\n\npublic class stringtablestudy {\n\tpublic static void main(string[] args) {\n\t\tstring a = "a";\n\t\tstring b = "b";\n\t\tstring ab = "ab";\n\t\tstring ab2 = a+b;\n\t\t//使用拼接字符串的方法创建字符串\n\t\tstring ab3 = "a" + "b";\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n反编译后的结果\n\n \t  code:\n      stack=2, locals=6, args_size=1\n         0: ldc           #2                  // string a\n         2: astore_1\n         3: ldc           #3                  // string b\n         5: astore_2\n         6: ldc           #4                  // string ab\n         8: astore_3\n         9: new           #5                  // class java/lang/stringbuilder\n        12: dup\n        13: invokespecial #6                  // method java/lang/stringbuilder."<init>":()v\n        16: aload_1\n        17: invokevirtual #7                  // method java/lang/stringbuilder.append:(ljava/lang/string\n;)ljava/lang/stringbuilder;\n        20: aload_2\n        21: invokevirtual #7                  // method java/lang/stringbuilder.append:(ljava/lang/string\n;)ljava/lang/stringbuilder;\n        24: invokevirtual #8                  // method java/lang/stringbuilder.tostring:()ljava/lang/str\ning;\n        27: astore        4\n        //ab3初始化时直接从串池中获取字符串\n        29: ldc           #4                  // string ab\n        31: astore        5\n        33: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 使用拼接字符串常量的方法来创建新的字符串时，因为内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。\n * 使用拼接字符串变量的方法来创建新的字符串时，因为内容是变量，只能在运行期确定它的值，所以需要使用stringbuilder来创建\n\n# intern方法 1.8\n\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n * 如果串池中没有该字符串对象，则放入成功\n * 如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n\n注意：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象\n\n例1\n\npublic class main {\n\tpublic static void main(string[] args) {\n\t\t//"a" "b" 被放入串池中，str则存在于堆内存之中\n\t\tstring str = new string("a") + new string("b");\n\t\t//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象\n\t\tstring st2 = str.intern();\n\t\t//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回\n\t\tstring str3 = "ab";\n\t\t//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true\n\t\tsystem.out.println(str == st2);\n\t\tsystem.out.println(str == str3);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例2\n\npublic class main {\n\tpublic static void main(string[] args) {\n        //此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中\n\t\tstring str3 = "ab";\n        //"a" "b" 被放入串池中，str则存在于堆内存之中\n\t\tstring str = new string("a") + new string("b");\n        //此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"\n\t\tstring str2 = str.intern();\n        //false\n\t\tsystem.out.println(str == str2);\n        //false\n\t\tsystem.out.println(str == str3);\n        //true\n\t\tsystem.out.println(str2 == str3);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# intern方法 1.6\n\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n * 如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中\n * 如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n\n注意：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象\n\n# stringtable 垃圾回收\n\nstringtable在内存紧张时，会发生垃圾回收\n\n# stringtable调优\n\n * 因为stringtable是由hashtable实现的，所以可以适当增加hashtable桶的个数，来减少字符串放入串池所需要的时间\n   \n   -xx:stringtablesize=xxxx\n   \n   \n   1\n   \n\n * 考虑是否需要将字符串对象入池\n   \n   可以通过intern方法减少重复入池\n\n\n# 6、直接内存\n\n * 属于操作系统，常见于nio操作时，用于数据缓冲区\n * 分配回收成本较高，但读写性能高\n * 不受jvm内存回收管理\n\n# 文件读写流程\n\n\n\n使用了directbuffer\n\n\n\n直接内存是操作系统和java代码都可以访问的一块区域，无需将代码从系统内存复制到java堆内存，从而提高了效率\n\n# 释放原理\n\n直接内存的回收不是通过jvm的垃圾回收来释放的，而是通过unsafe.freememory来手动释放\n\n通过\n\n//通过bytebuffer申请1m的直接内存\nbytebuffer bytebuffer = bytebuffer.allocatedirect(_1m);\n\n\n1\n2\n\n\n申请直接内存，但jvm并不能回收直接内存中的内容，它是如何实现回收的呢？\n\nallocatedirect的实现\n\npublic static bytebuffer allocatedirect(int capacity) {\n    return new directbytebuffer(capacity);\n}\n\n\n1\n2\n3\n\n\ndirectbytebuffer类\n\ndirectbytebuffer(int cap) {   // package-private\n   \n    super(-1, 0, cap, cap);\n    boolean pa = vm.isdirectmemorypagealigned();\n    int ps = bits.pagesize();\n    long size = math.max(1l, (long)cap + (pa ? ps : 0));\n    bits.reservememory(size, cap);\n\n    long base = 0;\n    try {\n        base = unsafe.allocatememory(size); //申请内存\n    } catch (outofmemoryerror x) {\n        bits.unreservememory(size, cap);\n        throw x;\n    }\n    unsafe.setmemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n        // round up to page boundary\n        address = base + ps - (base & (ps - 1));\n    } else {\n        address = base;\n    }\n    cleaner = cleaner.create(this, new deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象\n    att = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这里调用了一个cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是directbytebuffer）被回收以后，就会调用cleaner的clean方法，来清除直接内存中占用的内存\n\npublic void clean() {\n       if (remove(this)) {\n           try {\n               this.thunk.run(); //调用run方法\n           } catch (final throwable var2) {\n               accesscontroller.doprivileged(new privilegedaction<void>() {\n                   public void run() {\n                       if (system.err != null) {\n                           (new error("cleaner terminated abnormally", var2)).printstacktrace();\n                       }\n\n                       system.exit(1);\n                       return null;\n                   }\n               });\n           }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对应对象的run方法\n\npublic void run() {\n    if (address == 0) {\n        // paranoia\n        return;\n    }\n    unsafe.freememory(address); //释放直接内存中占用的内存\n    address = 0;\n    bits.unreservememory(size, capacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 直接内存的回收机制总结\n\n * 使用了unsafe类来完成直接内存的分配回收，回收需要主动调用freememory方法\n * bytebuffer的实现内部使用了cleaner（虚引用）来检测bytebuffer。一旦bytebuffer被垃圾回收，那么会由referencehandler来调用cleaner的clean方法调用freememory来释放内存\n\n\n# 三、垃圾回收\n\n\n# 1、如何判断对象可以回收\n\n# 引用计数法\n\n弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放\n\n\n\n# 可达性分析算法\n\n * jvm中的垃圾回收器通过可达性分析来探索所有存活的对象\n * 扫描堆中的对象，看能否沿着gc root对象为起点的引用链找到该对象，如果找不到，则表示可以回收\n * 可以作为gc root的对象\n   * 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n   * 方法区中类静态属性引用的对象\n   * 方法区中常量引用的对象\n   * 本地方法栈中jni（即一般说的native方法）引用的对象\n\n# 五种引用\n\n\n\n# 强引用\n\n只有gc root都不引用该对象时，才会回收强引用对象\n\n * 如上图b、c对象都不引用a1对象时，a1对象才会被回收\n\n# 软引用\n\n当gc root指向软引用对象时，在内存不足时，会回收软引用所引用的对象\n\n * 如上图如果b对象不再引用a2对象且内存不足时，软引用所引用的a2对象就会被回收\n\n# 软引用的使用\n\npublic class demo1 {\n\tpublic static void main(string[] args) {\n\t\tfinal int _4m = 4*1024*1024;\n\t\t//使用软引用对象 list和softreference是强引用，而softreference和byte数组则是软引用\n\t\tlist<softreference<byte[]>> list = new arraylist<>();\n\t\tsoftreference<byte[]> ref= new softreference<>(new byte[_4m]);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，软引用本身不会被清理\n\n如果想要清理软引用，需要使用引用队列\n\npublic class demo1 {\n\tpublic static void main(string[] args) {\n\t\tfinal int _4m = 4*1024*1024;\n\t\t//使用引用队列，用于移除引用为空的软引用对象\n\t\treferencequeue<byte[]> queue = new referencequeue<>();\n\t\t//使用软引用对象 list和softreference是强引用，而softreference和byte数组则是软引用\n\t\tlist<softreference<byte[]>> list = new arraylist<>();\n\t\tsoftreference<byte[]> ref= new softreference<>(new byte[_4m]);\n\n\t\t//遍历引用队列，如果有元素，则移除\n\t\treference<? extends byte[]> poll = queue.poll();\n\t\twhile(poll != null) {\n\t\t\t//引用队列不为空，则从集合中移除该元素\n\t\t\tlist.remove(poll);\n\t\t\t//移动到引用队列中的下一个元素\n\t\t\tpoll = queue.poll();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n**大概思路为：**查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）\n\n# 弱引用\n\n只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象\n\n * 如上图如果b对象不再引用a3对象，则a3对象会被回收\n\n弱引用的使用和软引用类似，只是将 softreference 换为了 weakreference\n\n# 虚引用\n\n当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法\n\n * 虚引用的一个体现是释放直接内存所分配的内存，当引用的对象bytebuffer被垃圾回收以后，虚引用对象cleaner就会被放入引用队列中，然后调用cleaner的clean方法来释放直接内存\n * 如上图，b对象不再引用bytebuffer对象，bytebuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象cleaner放入引用队列中，然后调用它的clean方法来释放直接内存\n\n# 终结器引用\n\n所有的类都继承自object类，object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了\n\n * 如上图，b对象不再引用a4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了\n\n# 引用队列\n\n * 软引用和弱引用可以配合引用队列\n   * 在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象\n * 虚引用和终结器引用必须配合引用队列\n   * 虚引用和终结器引用在使用时会关联一个引用队列\n\n\n# 2、垃圾回收算法\n\n# 标记-清除\n\n\n\n定义：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间\n\n * 这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接覆盖这段内存\n\n缺点：容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢\n\n# 标记-整理\n\n\n\n标记-整理 会将不被gc root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低\n\n# 复制\n\n\n\n\n\n\n\n\n\n将内存分为等大小的两个区域，from和to（to中为空）。先将被gc root引用的对象从from放入to中，再回收不被gc root引用的对象。然后交换from和to。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。\n\n\n# 3、分代回收\n\n\n\n# 回收流程\n\n新创建的对象都被放在了新生代的伊甸园中\n\n\n\n当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 minor gc\n\nminor gc 会将伊甸园和幸存区from存活的对象先复制到 幸存区 to中， 并让其寿命加1，再交换两个幸存区\n\n\n\n\n\n\n\n再次创建对象，若新生代的伊甸园又满了，则会再次触发 minor gc（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区to中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1\n\n\n\n如果幸存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中\n\n\n\n如果新生代老年代中的内存都满了，就会先触发minor gc，再触发full gc，扫描新生代和老年代中所有不再使用的对象并回收\n\n# gc 分析\n\n# 大对象处理策略\n\n当遇到一个较大的对象时，就算新生代的伊甸园为空，也无法容纳该对象时，会将该对象直接晋升为老年代\n\n# 线程内存溢出\n\n某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行\n\n这是因为当一个线程抛出oom异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行，进程依然正常\n\n\n# 4、垃圾回收器\n\n# 相关概念\n\n并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n\n并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个cpu上\n\n吞吐量：即cpu用于运行用户代码的时间与cpu总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%\n\n# 串行\n\n * 单线程\n * 内存较小，个人电脑（cpu核数较少）\n\n\n\n安全点：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象\n\n因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态\n\n# serial 收集器\n\nserial收集器是最基本的、发展历史最悠久的收集器\n\n特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个cpu的环境来说，serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（stop the world）\n\n# parnew 收集器\n\nparnew收集器其实就是serial收集器的多线程版本\n\n特点：多线程、parnew收集器默认开启的收集线程数与cpu的数量相同，在cpu非常多的环境中，可以使用-xx:parallelgcthreads参数来限制垃圾收集的线程数。和serial收集器一样存在stop the world问题\n\n# serial old 收集器\n\nserial old是serial收集器的老年代版本\n\n特点：同样是单线程收集器，采用标记-整理算法\n\n# 吞吐量优先\n\n * 多线程\n * 堆内存较大，多核cpu\n * 单位时间内，stw（stop the world，停掉其他所有工作线程）时间最短\n * jdk1.8默认使用的垃圾回收器\n\n\n\n# parallel scavenge 收集器\n\n与吞吐量关系密切，故也称为吞吐量优先收集器\n\n特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与parnew收集器类似）\n\n该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：gc自适应调节策略（与parnew收集器最重要的一个区别）\n\ngc自适应调节策略：parallel scavenge收集器可设置-xx:+useadptivesizepolicy参数。当开关打开时不需要手动指定新生代的大小（-xmn）、eden与survivor区的比例（-xx:survivorration）、晋升老年代的对象年龄（-xx:pretenuresizethreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为gc的自适应调节策略。\n\nparallel scavenge收集器使用两个参数控制吞吐量：\n\n * xx:maxgcpausemillis 控制最大的垃圾收集停顿时间\n * xx:gcratio 直接设置吞吐量的大小\n\n# parallel old 收集器\n\n是parallel scavenge收集器的老年代版本\n\n特点：多线程，采用标记-整理算法（老年代没有幸存区）\n\n# 响应时间优先\n\n * 多线程\n * 堆内存较大，多核cpu\n * 尽可能让单次stw时间变短（尽量不影响其他线程运行）\n\n\n\n# cms 收集器\n\nconcurrent mark sweep，一种以获取最短回收停顿时间为目标的老年代收集器\n\n特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片\n\n应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务\n\ncms收集器的运行过程分为下列4步：\n\n初始标记：标记gc roots能直接到的对象。速度很快但是仍存在stop the world问题\n\n并发标记：进行gc roots tracing 的过程，找出存活对象且用户线程可并发执行\n\n重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在stop the world问题\n\n并发清除：对标记的对象进行清除回收\n\ncms收集器的内存回收过程是与用户线程一起并发执行的\n\n# g1\n\n# 定义：\n\ngarbage first\n\njdk 9以后默认使用，而且替代了cms 收集器\n\n\n\n# 适用场景\n\n * 同时注重吞吐量和低延迟（响应时间）\n * 超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域\n * 整体上是标记-整理算法，两个区域之间是复制算法\n\n相关参数：jdk8 并不是默认开启的，所需要参数开启\n\n\n\n# g1垃圾回收阶段\n\n\n\n新生代伊甸园垃圾回收—–>内存不足，新生代回收+并发标记—–>回收新生代伊甸园、幸存区、老年代内存——>新生代伊甸园垃圾回收(重新开始)\n\n# young collection\n\n分区算法region\n\n分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 gc 产生的停顿时间\n\ne：伊甸园 s：幸存区 o：老年代\n\n * 会stw\n\n\n\n\n\n\n\n# young collection + cm\n\ncm：并发标记\n\n * 在 young gc 时会对 gc root 进行初始标记\n * 在老年代占用堆内存的比例达到阈值时，对进行并发标记（不会stw），阈值可以根据用户来进行设定\n\n\n\n# mixed collection\n\n会对e s o 进行全面的回收\n\n * 最终标记\n * 拷贝存活\n\n-xx:maxgcpausemills:xxx 用于指定最长的停顿时间\n\n问：为什么有的老年代被拷贝了，有的没拷贝？\n\n因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）\n\n\n\n# full gc\n\ng1在老年代内存不足时（老年代所占内存超过阈值）\n\n * 如果垃圾产生速度慢于垃圾回收速度，不会触发full gc，还是并发地进行清理\n * 如果垃圾产生速度快于垃圾回收速度，便会触发full gc\n\n# young collection 跨代引用\n\n * 新生代回收的跨代引用（老年代引用新生代）问题\n\n\n\n * 卡表与remembered set\n   * remembered set 存在于e中，用于保存新生代对象对应的脏卡\n     * 脏卡：o被划分为多个区域（一个区域512k），如果该区域引用了新生代对象，则该区域被称为脏卡\n * 在引用变更时通过post-write barried + dirty card queue\n * concurrent refinement threads 更新 remembered set\n\n\n\n# remark\n\n重新标记阶段\n\n在垃圾回收时，收集器处理对象的过程中\n\n黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的\n\n\n\n但是在并发标记过程中，有可能a被处理了以后未引用c，但该处理过程还未结束，在处理过程结束之前a引用了c，这时就会用到remark\n\n过程如下\n\n * 之前c未被引用，这时a引用了c，就会给c加一个写屏障，写屏障的指令会被执行，将c放入一个队列当中，并将c变为 处理中 状态\n * 在并发标记阶段结束以后，重新标记阶段会stw，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它\n\n\n\n# jdk 8u20 字符串去重\n\n过程\n\n * 将所有新分配的字符串（底层是char[]）放入一个队列\n * 当新生代回收时，g1并发检查是否有重复的字符串\n * 如果字符串的值一样，就让他们引用同一个字符串对象\n * 注意，其与string.intern的区别\n   * intern关注的是字符串对象\n   * 字符串去重关注的是char[]\n   * 在jvm内部，使用了不同的字符串标\n\n优点与缺点\n\n * 节省了大量内存\n * 新生代回收时间略微增加，导致略微多占用cpu\n\n# jdk 8u40 并发标记类卸载\n\n在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类\n\n# jdk 8u60 回收巨型对象\n\n * 一个对象大于region的一半时，就称为巨型对象\n * g1不会对巨型对象进行拷贝\n * 回收时被优先考虑\n * g1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉\n\n\n\n\n# 5、gc 调优\n\n查看虚拟机参数命令\n\n"f:\\java\\jdk8.0\\bin\\java" -xx:+printflagsfinal -version | findstr "gc"\n\n\n1\n\n\n可以根据参数去查询具体的信息\n\n# 调优领域\n\n * 内存\n * 锁竞争\n * cpu占用\n * io\n * gc\n\n# 确定目标\n\n低延迟/高吞吐量？ 选择合适的gc\n\n * cms g1 zgc\n * parallelgc\n * zing\n\n# 最快的gc是不发生gc\n\n首先排除减少因为自身编写的代码而引发的内存问题\n\n * 查看full gc前后的内存占用，考虑以下几个问题\n   * 数据是不是太多？\n   * 数据表示是否太臃肿\n     * 对象图\n     * 对象大小\n   * 是否存在内存泄漏\n\n# 新生代调优\n\n * 新生代的特点\n   * 所有的new操作分配内存都是非常廉价的\n     * tlab\n   * 死亡对象回收零代价\n   * 大部分对象用过即死（朝生夕死）\n   * minor gc 所用时间远小于full gc\n * 新生代内存越大越好么？\n   * 不是\n     * 新生代内存太小：频繁触发minor gc，会stw，会使得吞吐量下降\n     * 新生代内存太大：老年代内存占比有所降低，会更频繁地触发full gc。而且触发minor gc时，清理新生代所花费的时间会更长\n   * 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜\n\n# 幸存区调优\n\n * 幸存区需要能够保存 当前活跃对象+需要晋升的对象\n * 晋升阈值配置得当，让长时间存活的对象尽快晋升\n\n# 老年代调优\n\n\n# 四、类加载与字节码技术\n\n\n\n\n# 1、类文件结构\n\n首先获得.class字节码文件\n\n方法：\n\n * 在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java\n * java终端中，执行javac x:...\\xxx.java\n\n\n\n以下是字节码文件\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 \n0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 \n0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 \n0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e \n0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 \n0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 \n0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 \n0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f \n0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 \n0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 \n0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 \n0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 \n0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 \n0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 \n0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64\n0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e \n0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 \n0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 \n0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c \n0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 \n0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 \n0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f \n0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 \n0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 \n0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d \n0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a \n0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b \n0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 \n0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 \n0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 \n0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 \n0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 \n0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 \n0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a \n0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b \n0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 \n0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 \n0001120 00 00 02 00 14\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n根据 jvm 规范，类文件结构如下\n\nu4 \t\t\t magic\nu2             minor_version;    \nu2             major_version;    \nu2             constant_pool_count;    \ncp_info        constant_pool[constant_pool_count-1];    \nu2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   \nu2             fields_count;    \nfield_info     fields[fields_count];   \nu2             methods_count;    \nmethod_info    methods[methods_count];    \nu2             attributes_count;    \nattribute_info attributes[attributes_count];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 魔数\n\nu4 magic\n\n对应字节码文件的0~3个字节\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n\n# 版本\n\nu2 minor_version;\n\nu2 major_version;\n\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n\n34h = 52，代表jdk8\n\n# 常量池\n\n见资料文件\n\n…略\n\n\n# 2、字节码指令\n\n可参考\n\nhttps://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5\n\n# javap工具\n\noracle 提供了 javap 工具来反编译 class 文件\n\njavap -v f:\\thread_study\\src\\com\\nyima\\jvm\\day01\\main.class\nf:\\thread_study>javap -v f:\\thread_study\\src\\com\\nyima\\jvm\\day5\\demo1.class\nclassfile /f:/thread_study/src/com/nyima/jvm/day5/demo1.class\n  last modified 2020-6-6; size 434 bytes\n  md5 checksum df1dce65bf6fb0b4c1de318051f4a67e\n  compiled from "demo1.java"\npublic class com.nyima.jvm.day5.demo1\n  minor version: 0\n  major version: 52\n  flags: acc_public, acc_super\nconstant pool:\n   #1 = methodref          #6.#15         // java/lang/object."<init>":()v\n   #2 = fieldref           #16.#17        // java/lang/system.out:ljava/io/printstream;\n   #3 = string             #18            // hello world\n   #4 = methodref          #19.#20        // java/io/printstream.println:(ljava/lang/string;)v\n   #5 = class              #21            // com/nyima/jvm/day5/demo1\n   #6 = class              #22            // java/lang/object\n   #7 = utf8               <init>\n   #8 = utf8               ()v\n   #9 = utf8               code\n  #10 = utf8               linenumbertable\n  #11 = utf8               main\n  #12 = utf8               ([ljava/lang/string;)v\n  #13 = utf8               sourcefile\n  #14 = utf8               demo1.java\n  #15 = nameandtype        #7:#8          // "<init>":()v\n  #16 = class              #23            // java/lang/system\n  #17 = nameandtype        #24:#25        // out:ljava/io/printstream;\n  #18 = utf8               hello world\n  #19 = class              #26            // java/io/printstream\n  #20 = nameandtype        #27:#28        // println:(ljava/lang/string;)v\n  #21 = utf8               com/nyima/jvm/day5/demo1\n  #22 = utf8               java/lang/object\n  #23 = utf8               java/lang/system\n  #24 = utf8               out\n  #25 = utf8               ljava/io/printstream;\n  #26 = utf8               java/io/printstream\n  #27 = utf8               println\n  #28 = utf8               (ljava/lang/string;)v\n{\n  public com.nyima.jvm.day5.demo1();\n    descriptor: ()v\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<init>":()v\n         4: return\n      linenumbertable:\n        line 7: 0\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // field java/lang/system.out:ljava/io/printstream;\n         3: ldc           #3                  // string hello world\n         5: invokevirtual #4                  // method java/io/printstream.println:(ljava/lang/string;)v\n\n         8: return\n      linenumbertable:\n        line 9: 0\n        line 10: 8\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 图解方法执行流程\n\n代码\n\npublic class demo3_1 {    \n\tpublic static void main(string[] args) {        \n\t\tint a = 10;        \n\t\tint b = short.max_value + 1;        \n\t\tint c = a + b;        \n\t\tsystem.out.println(c);   \n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n常量池载入运行时常量池\n\n常量池也属于方法区，只不过这里单独提出来了\n\n\n\n方法字节码载入方法区\n\n（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位\n\n\n\n执行引擎开始执行字节码\n\nbipush 10\n\n * 将一个 byte 压入操作数栈\n   \n   （其长度会补齐 4 个字节），类似的指令还有\n   \n   * sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）\n   * ldc 将一个 int 压入操作数栈\n   * ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）\n   * 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池\n\n\n\nistore 1\n\n将操作数栈栈顶元素弹出，放入局部变量表的slot 1中\n\n对应代码中的\n\na = 10\n\n\n1\n\n\n\n\n\n\nldc #3\n\n读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中\n\n注意 short.max_value 是 32767，所以 32768 = short.max_value + 1 实际是在编译期间计算好的\n\n\n\nistore 2\n\n将操作数栈中的元素弹出，放到局部变量表的2号位置\n\n\n\n\n\niload1 iload2\n\n将局部变量表中1号位置和2号位置的元素放入操作数栈中\n\n * 因为只能在操作数栈中执行运算操作\n\n\n\n\n\niadd\n\n将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中\n\n\n\n\n\nistore 3\n\n将操作数栈中的元素弹出，放入局部变量表的3号位置\n\n\n\n\n\ngetstatic #4\n\n在运行时常量池中找到#4，发现是一个对象\n\n在堆内存中找到该对象，并将其引用放入操作数栈中\n\n\n\n\n\niload 3\n\n将局部变量表中3号位置的元素压入操作数栈中\n\n\n\ninvokevirtual 5\n\n找到常量池 #5 项，定位到方法区 java/io/printstream.println:(i)v 方法\n\n生成新的栈帧（分配 locals、stack等）\n\n传递参数，执行新栈帧中的字节码\n\n\n\n执行完毕，弹出栈帧\n\n清除 main 操作数栈内容\n\n\n\nreturn 完成 main 方法调用，弹出 main 栈帧，程序结束\n\n# 通过字节码指令来分析问题\n\n代码\n\npublic class demo2 {\n\tpublic static void main(string[] args) {\n\t\tint i=0;\n\t\tint x=0;\n\t\twhile(i<10) {\n\t\t\tx = x++;\n\t\t\ti++;\n\t\t}\n\t\tsystem.out.println(x); //接过为0\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓\n\ncode:\n     stack=2, locals=3, args_size=1\t//操作数栈分配2个空间，局部变量表分配3个空间\n        0: iconst_0\t//准备一个常数0\n        1: istore_1\t//将常数0放入局部变量表的1号槽位 i=0\n        2: iconst_0\t//准备一个常数0\n        3: istore_2\t//将常数0放入局部变量的2号槽位 x=0\t\n        4: iload_1\t\t//将局部变量表1号槽位的数放入操作数栈中\n        5: bipush        10\t//将数字10放入操作数栈中，此时操作数栈中有2个数\n        7: if_icmpge     21\t//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空\n       10: iload_2\t\t//将局部变量2号槽位的数放入操作数栈中，放入的值是0\n       11: iinc          2, 1\t//将局部变量2号槽位的数加1，自增后，槽位中的值为1\n       14: istore_2\t//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0\n       15: iinc          1, 1 //1号槽位的值自增1\n       18: goto          4 //跳转到第4条指令\n       21: getstatic     #2                  // field java/lang/system.out:ljava/io/printstream;\n       24: iload_2\n       25: invokevirtual #3                  // method java/io/printstream.println:(i)v\n       28: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 构造方法\n\n# cinit()v\n\npublic class demo3 {\n\tstatic int i = 10;\n\n\tstatic {\n\t\ti = 20;\n\t}\n\n\tstatic {\n\t\ti = 30;\n\t}\n\n\tpublic static void main(string[] args) {\n\t\tsystem.out.println(i); //结果为30\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()v ：\n\nstack=1, locals=0, args_size=0\n         0: bipush        10\n         2: putstatic     #3                  // field i:i\n         5: bipush        20\n         7: putstatic     #3                  // field i:i\n        10: bipush        30\n        12: putstatic     #3                  // field i:i\n        15: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# init()v\n\npublic class demo4 {\n\tprivate string a = "s1";\n\n\t{\n\t\tb = 20;\n\t}\n\n\tprivate int b = 10;\n\n\t{\n\t\ta = "s2";\n\t}\n\n\tpublic demo4(string a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tpublic static void main(string[] args) {\n\t\tdemo4 d = new demo4("s3", 30);\n\t\tsystem.out.println(d.a);\n\t\tsystem.out.println(d.b);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后\n\ncode:\n     stack=2, locals=3, args_size=3\n        0: aload_0\n        1: invokespecial #1                  // method java/lang/object."<init>":()v\n        4: aload_0\n        5: ldc           #2                  // string s1\n        7: putfield      #3                  // field a:ljava/lang/string;\n       10: aload_0\n       11: bipush        20\n       13: putfield      #4                  // field b:i\n       16: aload_0\n       17: bipush        10\n       19: putfield      #4                  // field b:i\n       22: aload_0\n       23: ldc           #5                  // string s2\n       25: putfield      #3                  // field a:ljava/lang/string;\n       //原始构造方法在最后执行\n       28: aload_0\n       29: aload_1\n       30: putfield      #3                  // field a:ljava/lang/string;\n       33: aload_0\n       34: iload_2\n       35: putfield      #4                  // field b:i\n       38: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 方法调用\n\npublic class demo5 {\n\tpublic demo5() {\n\n\t}\n\n\tprivate void test1() {\n\n\t}\n\n\tprivate final void test2() {\n\n\t}\n\n\tpublic void test3() {\n\n\t}\n\n\tpublic static void test4() {\n\n\t}\n\n\tpublic static void main(string[] args) {\n\t\tdemo5 demo5 = new demo5();\n\t\tdemo5.test1();\n\t\tdemo5.test2();\n\t\tdemo5.test3();\n\t\tdemo5.test4();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n不同方法在调用时，对应的虚拟机指令有所区别\n\n * 私有、构造、被final修饰的方法，在调用时都使用invokespecial指令\n * 普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定\n * 静态方法在调用时使用invokestatic指令\n\ncode:\n      stack=2, locals=2, args_size=1\n         0: new           #2                  // class com/nyima/jvm/day5/demo5 \n         3: dup\n         4: invokespecial #3                  // method "<init>":()v\n         7: astore_1\n         8: aload_1\n         9: invokespecial #4                  // method test1:()v\n        12: aload_1\n        13: invokespecial #5                  // method test2:()v\n        16: aload_1\n        17: invokevirtual #6                  // method test3:()v\n        20: invokestatic  #7                  // method test4:()v\n        23: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈\n * dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”😦)v （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量\n * 终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定\n * 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】\n\n# 多态原理\n\n因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令\n\n在执行invokevirtual指令时，经历了以下几个步骤\n\n * 先通过栈帧中对象的引用找到对象\n * 分析对象头，找到对象实际的class\n * class结构中有vtable\n * 查询vtable找到方法的具体地址\n * 执行方法的字节码\n\n# 异常处理\n\n# try-catch\n\npublic class demo1 {\n\tpublic static void main(string[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t}catch (exception e) {\n\t\t\ti = 20;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对应字节码指令\n\ncode:\n     stack=1, locals=3, args_size=1\n        0: iconst_0\n        1: istore_1\n        2: bipush        10\n        4: istore_1\n        5: goto          12\n        8: astore_2\n        9: bipush        20\n       11: istore_1\n       12: return\n     //多出来一个异常表\n     exception table:\n        from    to  target type\n            2     5     8   class java/lang/exception\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 可以看到多出来一个 exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号\n * 8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）\n\n# 多个single-catch\n\npublic class demo1 {\n\tpublic static void main(string[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t}catch (arithmeticexception e) {\n\t\t\ti = 20;\n\t\t}catch (exception e) {\n\t\t\ti = 30;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对应的字节码\n\ncode:\n     stack=1, locals=3, args_size=1\n        0: iconst_0\n        1: istore_1\n        2: bipush        10\n        4: istore_1\n        5: goto          19\n        8: astore_2\n        9: bipush        20\n       11: istore_1\n       12: goto          19\n       15: astore_2\n       16: bipush        30\n       18: istore_1\n       19: return\n     exception table:\n        from    to  target type\n            2     5     8   class java/lang/arithmeticexception\n            2     5    15   class java/lang/exception\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 因为异常出现时，只能进入 exception table 中一个分支，所以局部变量表 slot 2 位置被共用\n\n# finally\n\npublic class demo2 {\n\tpublic static void main(string[] args) {\n\t\tint i = 0;\n\t\ttry {\n\t\t\ti = 10;\n\t\t} catch (exception e) {\n\t\t\ti = 20;\n\t\t} finally {\n\t\t\ti = 30;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n对应字节码\n\ncode:\n     stack=1, locals=4, args_size=1\n        0: iconst_0\n        1: istore_1\n        //try块\n        2: bipush        10\n        4: istore_1\n        //try块执行完后，会执行finally    \n        5: bipush        30\n        7: istore_1\n        8: goto          27\n       //catch块     \n       11: astore_2 //异常信息放入局部变量表的2号槽位\n       12: bipush        20\n       14: istore_1\n       //catch块执行完后，会执行finally        \n       15: bipush        30\n       17: istore_1\n       18: goto          27\n       //出现异常，但未被exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   \n       21: astore_3\n       22: bipush        30\n       24: istore_1\n       25: aload_3\n       26: athrow  //抛出异常\n       27: return\n     exception table:\n        from    to  target type\n            2     5    11   class java/lang/exception\n            2     5    21   any\n           11    15    21   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n可以看到 ﬁnally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程\n\n注意：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次\n\n# finally中的return\n\npublic class demo3 {\n\tpublic static void main(string[] args) {\n\t\tint i = demo3.test();\n        //结果为20\n\t\tsystem.out.println(i);\n\t}\n\n\tpublic static int test() {\n\t\tint i;\n\t\ttry {\n\t\t\ti = 10;\n\t\t\treturn i;\n\t\t} finally {\n\t\t\ti = 20;\n\t\t\treturn i;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对应字节码\n\ncode:\n     stack=1, locals=3, args_size=0\n        0: bipush        10\n        2: istore_0\n        3: iload_0\n        4: istore_1  //暂存返回值\n        5: bipush        20\n        7: istore_0\n        8: iload_0\n        9: ireturn\t//ireturn会返回操作数栈顶的整型值20\n       //如果出现异常，还是会执行finally块中的内容，没有抛出异常\n       10: astore_2\n       11: bipush        20\n       13: istore_0\n       14: iload_0\n       15: ireturn\t//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！\n     exception table:\n        from    to  target type\n            0     5    10   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准\n * 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子\n * 跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：如果在 ﬁnally 中出现了 return，会吞掉异常\n * 所以不要在finally中进行返回操作\n\n# 被吞掉的异常\n\npublic class demo3 {\n   public static void main(string[] args) {\n      int i = demo3.test();\n      //最终结果为20\n      system.out.println(i);\n   }\n\n   public static int test() {\n      int i;\n      try {\n         i = 10;\n         //这里应该会抛出异常\n         i = i/0;\n         return i;\n      } finally {\n         i = 20;\n         return i;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n会发现打印结果为20，并未抛出异常\n\n# finally不带return\n\npublic class demo4 {\n\tpublic static void main(string[] args) {\n\t\tint i = demo4.test();\n\t\tsystem.out.println(i);\n\t}\n\n\tpublic static int test() {\n\t\tint i = 10;\n\t\ttry {\n\t\t\treturn i;\n\t\t} finally {\n\t\t\ti = 20;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n对应字节码\n\ncode:\n     stack=1, locals=3, args_size=0\n        0: bipush        10\n        2: istore_0 //赋值给i 10\n        3: iload_0\t//加载到操作数栈顶\n        4: istore_1 //加载到局部变量表的1号位置\n        5: bipush        20\n        7: istore_0 //赋值给i 20\n        8: iload_1 //加载局部变量表1号位置的数10到操作数栈\n        9: ireturn //返回操作数栈顶元素 10\n       10: astore_2\n       11: bipush        20\n       13: istore_0\n       14: aload_2 //加载异常\n       15: athrow //抛出异常\n     exception table:\n        from    to  target type\n            3     5    10   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# synchronized\n\npublic class demo5 {\n\tpublic static void main(string[] args) {\n\t\tint i = 10;\n\t\tlock lock = new lock();\n\t\tsynchronized (lock) {\n\t\t\tsystem.out.println(i);\n\t\t}\n\t}\n}\n\nclass lock{}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对应字节码\n\ncode:\n     stack=2, locals=5, args_size=1\n        0: bipush        10\n        2: istore_1\n        3: new           #2                  // class com/nyima/jvm/day06/lock\n        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗\n        7: invokespecial #3                  // method com/nyima/jvm/day06/lock."<init>":()v\n       10: astore_2 //剩下的一份放到局部变量表的2号位置\n       11: aload_2 //加载到操作数栈\n       12: dup //复制一份，放到操作数栈，用于加锁时消耗\n       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用\n       14: monitorenter //加锁\n       //锁住后代码块中的操作    \n       15: getstatic     #4                  // field java/lang/system.out:ljava/io/printstream;\n       18: iload_1\n       19: invokevirtual #5                  // method java/io/printstream.println:(i)v\n       //加载局部变量表中三号槽位对象的引用，用于解锁    \n       22: aload_3    \n       23: monitorexit //解锁\n       24: goto          34\n       //异常操作    \n       27: astore        4\n       29: aload_3\n       30: monitorexit //解锁\n       31: aload         4\n       33: athrow\n       34: return\n     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      \n     exception table:\n        from    to  target type\n           15    24    27   any\n           27    31    27   any\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 3、编译期处理\n\n所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利\n\n注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。\n\n# 默认构造函数\n\npublic class candy1 {\n\n}\n\n\n1\n2\n3\n\n\n经过编译期优化后\n\npublic class candy1 {\n   //这个无参构造器是java编译器帮我们加上的\n   public candy1() {\n      //即调用父类 object 的无参构造方法，即调用 java/lang/object." <init>":()v\n      super();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 自动拆装箱\n\n基本类型和其包装类型的相互转换过程，称为拆装箱\n\n在jdk 5以后，它们的转换可以在编译期自动完成\n\npublic class demo2 {\n   public static void main(string[] args) {\n      integer x = 1;\n      int y = x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n转换过程如下\n\npublic class demo2 {\n   public static void main(string[] args) {\n      //基本类型赋值给包装类型，称为装箱\n      integer x = integer.valueof(1);\n      //包装类型赋值给基本类型，称谓拆箱\n      int y = x.intvalue();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 泛型集合取值\n\n泛型也是在 jdk 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 object 类型来处理：\n\npublic class demo3 {\n   public static void main(string[] args) {\n      list<integer> list = new arraylist<>();\n      list.add(10);\n      integer x = list.get(0);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对应字节码\n\ncode:\n    stack=2, locals=3, args_size=1\n       0: new           #2                  // class java/util/arraylist\n       3: dup\n       4: invokespecial #3                  // method java/util/arraylist."<init>":()v\n       7: astore_1\n       8: aload_1\n       9: bipush        10\n      11: invokestatic  #4                  // method java/lang/integer.valueof:(i)ljava/lang/integer;\n      //这里进行了泛型擦除，实际调用的是add(objcet o)\n      14: invokeinterface #5,  2            // interfacemethod java/util/list.add:(ljava/lang/object;)z\n\n      19: pop\n      20: aload_1\n      21: iconst_0\n      //这里也进行了泛型擦除，实际调用的是get(object o)   \n      22: invokeinterface #6,  2            // interfacemethod java/util/list.get:(i)ljava/lang/object;\n//这里进行了类型转换，将object转换成了integer\n      27: checkcast     #7                  // class java/lang/integer\n      30: astore_2\n      31: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n所以调用get函数取值时，有一个类型转换的操作\n\ninteger x = (integer) list.get(0);\n\n\n1\n\n\n如果要将返回结果赋值给一个int类型的变量，则还有自动拆箱的操作\n\nint x = (integer) list.get(0).intvalue();\n\n\n1\n\n\n# 可变参数\n\npublic class demo4 {\n   public static void foo(string... args) {\n      //将args赋值给arr，可以看出string...实际就是string[] \n      string[] arr = args;\n      system.out.println(arr.length);\n   }\n\n   public static void main(string[] args) {\n      foo("hello", "world");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可变参数 string… args 其实是一个 string[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：\n\npublic class demo4 {\n   public demo4 {}\n\n    \n   public static void foo(string[] args) {\n      string[] arr = args;\n      system.out.println(arr.length);\n   }\n\n   public static void main(string[] args) {\n      foo(new string[]{"hello", "world"});\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new string[]{})，创建了一个空数组，而不是直接传递的null\n\n# foreach\n\npublic class demo5 {\n\tpublic static void main(string[] args) {\n        //数组赋初值的简化写法也是一种语法糖。\n\t\tint[] arr = {1, 2, 3, 4, 5};\n\t\tfor(int x : arr) {\n\t\t\tsystem.out.println(x);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编译器会帮我们转换为\n\npublic class demo5 {\n    public demo5 {}\n\n\tpublic static void main(string[] args) {\n\t\tint[] arr = new int[]{1, 2, 3, 4, 5};\n\t\tfor(int i=0; i<arr.length; ++i) {\n\t\t\tint x = arr[i];\n\t\t\tsystem.out.println(x);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果是集合使用foreach\n\npublic class demo5 {\n   public static void main(string[] args) {\n      list<integer> list = arrays.aslist(1, 2, 3, 4, 5);\n      for (integer x : list) {\n         system.out.println(x);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n集合要使用foreach，需要该集合类实现了iterable接口，因为集合的遍历需要用到迭代器iterator\n\npublic class demo5 {\n    public demo5 {}\n    \n   public static void main(string[] args) {\n      list<integer> list = arrays.aslist(1, 2, 3, 4, 5);\n      //获得该集合的迭代器\n      iterator<integer> iterator = list.iterator();\n      while(iterator.hasnext()) {\n         integer x = iterator.next();\n         system.out.println(x);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# switch字符串\n\npublic class demo6 {\n   public static void main(string[] args) {\n      string str = "hello";\n      switch (str) {\n         case "hello" :\n            system.out.println("h");\n            break;\n         case "world" :\n            system.out.println("w");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在编译器中执行的操作\n\npublic class demo6 {\n   public demo6() {\n      \n   }\n   public static void main(string[] args) {\n      string str = "hello";\n      int x = -1;\n      //通过字符串的hashcode+value来判断是否匹配\n      switch (str.hashcode()) {\n         //hello的hashcode\n         case 99162322 :\n            //再次比较，因为字符串的hashcode有可能相等\n            if(str.equals("hello")) {\n               x = 0;\n            }\n            break;\n         //world的hashcode\n         case 11331880 :\n            if(str.equals("world")) {\n               x = 1;\n            }\n            break;\n         default:\n            break;\n      }\n\n      //用第二个switch在进行输出判断\n      switch (x) {\n         case 0:\n            system.out.println("h");\n            break;\n         case 1:\n            system.out.println("w");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n过程说明：\n\n * 在编译期间，单个的switch被分为了两个\n   * 第一个用来匹配字符串，并给x赋值\n     * 字符串的匹配用到了字符串的hashcode，还用到了equals方法\n     * 使用hashcode是为了提高比较效率，使用equals是防止有hashcode冲突（如bm和c.）\n   * 第二个用来根据x的值来决定输出语句\n\n# switch枚举\n\npublic class demo7 {\n   public static void main(string[] args) {\n      sex sex = sex.male;\n      switch (sex) {\n         case male:\n            system.out.println("man");\n            break;\n         case female:\n            system.out.println("woman");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\nenum sex {\n   male, female;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n编译器中执行的代码如下\n\npublic class demo7 {\n   /**     \n    * 定义一个合成类（仅 jvm 使用，对我们不可见）     \n    * 用来映射枚举的 ordinal 与数组元素的关系     \n    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     \n    * 即 male 的 ordinal()=0，female 的 ordinal()=1     \n    */ \n   static class $map {\n      //数组大小即为枚举元素个数，里面存放了case用于比较的数字\n      static int[] map = new int[2];\n      static {\n         //ordinal即枚举元素对应所在的位置，male为0，female为1\n         map[sex.male.ordinal()] = 1;\n         map[sex.female.ordinal()] = 2;\n      }\n   }\n\n   public static void main(string[] args) {\n      sex sex = sex.male;\n      //将对应位置枚举元素的值赋给x，用于case操作\n      int x = $map.map[sex.ordinal()];\n      switch (x) {\n         case 1:\n            system.out.println("man");\n            break;\n         case 2:\n            system.out.println("woman");\n            break;\n         default:\n            break;\n      }\n   }\n}\n\nenum sex {\n   male, female;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n# 枚举类\n\nenum sex {\n   male, female;\n}\n\n\n1\n2\n3\n\n\n转换后的代码\n\npublic final class sex extends enum<sex> {   \n   //对应枚举类中的元素\n   public static final sex male;    \n   public static final sex female;    \n   private static final sex[] $values;\n   \n    static {       \n    \t//调用构造函数，传入枚举元素的值及ordinal\n    \tmale = new sex("male", 0);    \n        female = new sex("female", 1);   \n        $values = new sex[]{male, female}; \n   }\n \t\n   //调用父类中的方法\n    private sex(string name, int ordinal) {     \n        super(name, ordinal);    \n    }\n   \n    public static sex[] values() {  \n        return $values.clone();  \n    }\n    public static sex valueof(string name) { \n        return enum.valueof(sex.class, name);  \n    } \n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 匿名内部类\n\npublic class demo8 {\n   public static void main(string[] args) {\n      runnable runnable = new runnable() {\n         @override\n         public void run() {\n            system.out.println("running...");\n         }\n      };\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n转换后的代码\n\npublic class demo8 {\n   public static void main(string[] args) {\n      //用额外创建的类来创建匿名内部类对象\n      runnable runnable = new demo8$1();\n   }\n}\n\n//创建了一个额外的类，实现了runnable接口\nfinal class demo8$1 implements runnable {\n   public demo8$1() {}\n\n   @override\n   public void run() {\n      system.out.println("running...");\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果匿名内部类中引用了局部变量\n\npublic class demo8 {\n   public static void main(string[] args) {\n      int x = 1;\n      runnable runnable = new runnable() {\n         @override\n         public void run() {\n            system.out.println(x);\n         }\n      };\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n转化后代码\n\npublic class demo8 {\n   public static void main(string[] args) {\n      int x = 1;\n      runnable runnable = new runnable() {\n         @override\n         public void run() {\n            system.out.println(x);\n         }\n      };\n   }\n}\n\nfinal class demo8$1 implements runnable {\n   //多创建了一个变量\n   int val$x;\n   //变为了有参构造器\n   public demo8$1(int x) {\n      this.val$x = x;\n   }\n\n   @override\n   public void run() {\n      system.out.println(val$x);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 4、类加载阶段\n\n# 加载\n\n * 将类的字节码载入\n   \n   方法区\n   \n   （1.8后为元空间，在本地内存中）中，内部采用 c++ 的 instanceklass 描述 java 类，它的重要 ﬁeld 有：\n   \n   * _java_mirror 即 java 的类镜像，例如对 string 来说，它的镜像类就是 string.class，作用是把 klass 暴露给 java 使用\n   * _super 即父类\n   * _ﬁelds 即成员变量\n   * _methods 即方法\n   * _constants 即常量池\n   * _class_loader 即类加载器\n   * _vtable 虚方法表\n   * _itable 接口方法\n\n * 如果这个类还有父类没有加载，先加载父类\n\n * 加载和链接可能是交替运行的\n\n\n\n * instanceklass保存在方法区。jdk 8以后，方法区位于元空间中，而元空间又位于本地内存中\n * _java_mirror则是保存在堆内存中\n * instanceklass和*.class(java镜像类)互相保存了对方的地址\n * 类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceklass，从而获取类的各种信息\n\n# 链接\n\n# 验证\n\n验证类是否符合 jvm规范，安全性检查\n\n# 准备\n\n为 static 变量分配空间，设置默认值\n\n * static变量在jdk 7以前是存储与instanceklass末尾。但在jdk 7以后就存储在_java_mirror末尾了\n * static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成\n * 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成\n * 如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成\n\n# 解析\n\nhsdb的使用\n\n * 先获得要查看的进程id\n\njps\n\n\n1\n\n * 打开hsdb\n\njava -cp f:\\java\\jdk8.0\\lib\\sa-jdi.jar sun.jvm.hotspot.hsdb\n\n\n1\n\n * 运行时可能会报错，是因为缺少一个.dll的文件，我们在jdk的安装目录中找到该文件，复制到缺失的文件下即可\n\n\n\n * 定位需要的进程\n\n\n\n\n\n解析的含义\n\n将常量池中的符号引用解析为直接引用\n\n * 未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中\n\npublic class demo1 {\n   public static void main(string[] args) throws ioexception, classnotfoundexception {\n      classloader loader = demo1.class.getclassloader();\n      //只加载不解析\n      class<?> c = loader.loadclass("com.nyima.jvm.day8.c");\n      //用于阻塞主线程\n      system.in.read();\n   }\n}\n\nclass c {\n   d d = new d();\n}\n\nclass d {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 打开hsdb\n   * 可以看到此时只加载了类c\n\n\n\n查看类c的常量池，可以看到类d未被解析，只是存在于常量池中的符号\n\n\n\n * 解析以后，会将常量池中的符号引用解析为直接引用\n   \n   * 可以看到，此时已加载并解析了类c和类d\n   \n   \n\n\n\n# 初始化\n\n初始化阶段就是执行类构造器clinit()方法的过程，虚拟机会保证这个类的『构造方法』的线程安全\n\n * clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的\n\n注意\n\n编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如\n\n\n\n# 发生时机\n\n类的初始化的懒惰的，以下情况会初始化\n\n * main 方法所在的类，总会被首先初始化\n * 首次访问这个类的静态变量或静态方法时\n * 子类初始化，如果父类还没初始化，会引发\n * 子类访问父类的静态变量，只会触发父类的初始化\n * class.forname\n * new 会导致初始化\n\n以下情况不会初始化\n\n * 访问类的 static ﬁnal 静态常量（基本类型和字符串）\n * 类对象.class 不会触发初始化\n * 创建该类对象的数组\n * 类加载器的.loadclass方法\n * class.fornamed的参数2为false时\n\n验证类是否被初始化，可以看改类的静态代码块是否被执行\n\n\n# 5、类加载器\n\njava虚拟机设计团队有意把类加载阶段中的**“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”**（classloader）\n\n# 类与类加载器\n\n类加载器虽然只用于实现类的加载动作，但它在java程序中起到的作用却远超类加载阶段\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等\n\n以jdk 8为例\n\n名称                                  加载的类                    说明\nbootstrap classloader（启动类加载器）       java_home/jre/lib       无法直接访问\nextension classloader(拓展类加载器)       java_home/jre/lib/ext   上级为bootstrap，显示为null\napplication classloader(应用程序类加载器)   classpath               上级为extension\n自定义类加载器                             自定义                     上级为application\n\n# 启动类加载器\n\n可通过在控制台输入指令，使得类被启动类加器加载\n\n# 拓展类加载器\n\n如果classpath和java_home/jre/lib/ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载\n\n# 双亲委派模式\n\n双亲委派模式，即调用类加载器classloader 的 loadclass 方法时，查找类的规则\n\nloadclass源码\n\nprotected class<?> loadclass(string name, boolean resolve)\n    throws classnotfoundexception\n{\n    synchronized (getclassloadinglock(name)) {\n        // 首先查找该类是否已经被该类加载器加载过了\n        class<?> c = findloadedclass(name);\n        //如果没有被加载过\n        if (c == null) {\n            long t0 = system.nanotime();\n            try {\n                //看是否被它的上级加载器加载过了 extension的上级是bootstarp，但它显示为null\n                if (parent != null) {\n                    c = parent.loadclass(name, false);\n                } else {\n                    //看是否被启动类加载器加载过\n                    c = findbootstrapclassornull(name);\n                }\n            } catch (classnotfoundexception e) {\n                // classnotfoundexception thrown if class not found\n                // from the non-null parent class loader\n                //捕获异常，但不做任何处理\n            }\n\n            if (c == null) {\n                //如果还是没有找到，先让拓展类加载器调用findclass方法去找到该类，如果还是没找到，就抛出异常\n                //然后让应用类加载器去找classpath下找该类\n                long t1 = system.nanotime();\n                c = findclass(name);\n\n                // 记录时间\n                sun.misc.perfcounter.getparentdelegationtime().addtime(t1 - t0);\n                sun.misc.perfcounter.getfindclasstime().addelapsedtimefrom(t1);\n                sun.misc.perfcounter.getfindclasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveclass(c);\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 自定义类加载器\n\n# 使用场景\n\n * 想加载非 classpath 随意路径中的类文件\n * 通过接口来使用实现，希望解耦时，常用在框架设计\n * 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器\n\n# 步骤\n\n * 继承classloader父类\n * 要遵从双亲委派机制，重写 ﬁndclass 方法\n   * 不是重写loadclass方法，否则不会走双亲委派机制\n * 读取类文件的字节码\n * 调用父类的 deﬁneclass 方法来加载类\n * 使用者调用该类加载器的 loadclass 方法\n\n# 破坏双亲委派模式\n\n * 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即jdk1.2面世以前的“远古”时代\n   * 建议用户重写findclass()方法，在类加载器中的loadclass()方法中也会调用该方法\n * 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的\n   * 如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式\n * 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的\n   * 这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（hot swap）、模块热部署（hot deployment）等\n\n\n# 6、运行期优化\n\n# 分层编译\n\njvm 将执行状态分成了 5 个层次：\n\n * 0层：解释执行，用解释器将字节码翻译为机器码\n * 1层：使用 c1 即时编译器编译执行（不带 proﬁling）\n * 2层：使用 c1 即时编译器编译执行（带基本的profiling）\n * 3层：使用 c1 即时编译器编译执行（带完全的profiling）\n * 4层：使用 c2 即时编译器编译执行\n\nproﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等\n\n# 即时编译器（jit）与解释器的区别\n\n * 解释器\n   * 将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释\n   * 是将字节码解释为针对所有平台都通用的机器码\n * 即时编译器\n   * 将一些字节码编译为机器码，并存入 code cache，下次遇到相同的代码，直接执行，无需再编译\n   * 根据平台类型，生成平台特定的机器码\n\n对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 interpreter < c1 < c2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码\n\n# 逃逸分析\n\n逃逸分析（escape analysis）简单来讲就是，java hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 java 堆上分配内存的一项技术\n\n逃逸分析的 jvm 参数如下：\n\n * 开启逃逸分析：-xx:+doescapeanalysis\n * 关闭逃逸分析：-xx:-doescapeanalysis\n * 显示分析结果：-xx:+printescapeanalysis\n\n逃逸分析技术在 java se 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数\n\n对象逃逸状态\n\n全局逃逸（globalescape）\n\n * 即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：\n   * 对象是一个静态变量\n   * 对象是一个已经发生逃逸的对象\n   * 对象作为当前方法的返回值\n\n参数逃逸（argescape）\n\n * 即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的\n\n没有逃逸\n\n * 即方法中的对象没有发生逃逸\n\n逃逸分析优化\n\n针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化\n\n锁消除\n\n我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁\n\n例如，stringbuffer 和 vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作\n\n锁消除的 jvm 参数如下：\n\n * 开启锁消除：-xx:+eliminatelocks\n * 关闭锁消除：-xx:-eliminatelocks\n\n锁消除在 jdk8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上\n\n标量替换\n\n首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象\n\n对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。\n\n这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能\n\n标量替换的 jvm 参数如下：\n\n * 开启标量替换：-xx:+eliminateallocations\n * 关闭标量替换：-xx:-eliminateallocations\n * 显示标量替换详情：-xx:+printeliminateallocations\n\n标量替换同样在 jdk8 中都是默认开启的，并且都要建立在逃逸分析的基础上\n\n栈上分配\n\n当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 gc 压力，提高了应用程序性能\n\n# 方法内联\n\n# 内联函数\n\n内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换\n\n# jvm内联函数\n\nc++是否为内联函数由自己决定，java由编译器决定。java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被jvm内联的，如\n\npublic final void dosomething() {  \n        // to do something  \n}\n\n\n1\n2\n3\n\n\n总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数\n\njvm内建有许多运行时优化。首先短方法更利于jvm推断。流程更明显，作用域更短，副作用也更明显。如果是长方法jvm可能直接就跪了。\n\n第二个原因则更重要：方法内联\n\n如果jvm监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：\n\nprivate int add4(int x1, int x2, int x3, int x4) { \n\t\t//这里调用了add2方法\n        return add2(x1, x2) + add2(x3, x4);  \n    }  \n\n    private int add2(int x1, int x2) {  \n        return x1 + x2;  \n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方法调用被替换后\n\nprivate int add4(int x1, int x2, int x3, int x4) {  \n    \t//被替换为了方法本身\n        return x1 + x2 + x3 + x4;  \n    }\n\n\n1\n2\n3\n4\n\n\n# 反射优化\n\npublic class reflect1 {\n   public static void foo() {\n      system.out.println("foo...");\n   }\n\n   public static void main(string[] args) throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n      method foo = demo3.class.getmethod("foo");\n      for(int i = 0; i<=16; i++) {\n         foo.invoke(null);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfoo.invoke 前面 0 ~ 15 次调用使用的是 methodaccessor 的 nativemethodaccessorimpl 实现\n\ninvoke方法源码\n\n@callersensitive\npublic object invoke(object obj, object... args)\n    throws illegalaccessexception, illegalargumentexception,\n       invocationtargetexception\n{\n    if (!override) {\n        if (!reflection.quickcheckmemberaccess(clazz, modifiers)) {\n            class<?> caller = reflection.getcallerclass();\n            checkaccess(caller, clazz, obj, modifiers);\n        }\n    }\n    //methodaccessor是一个接口，有3个实现类，其中有一个是抽象类\n    methodaccessor ma = methodaccessor;             // read volatile\n    if (ma == null) {\n        ma = acquiremethodaccessor();\n    }\n    return ma.invoke(obj, args);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n会由delegatingmehodaccessorimpl去调用nativemethodaccessorimpl\n\nnativemethodaccessorimpl源码\n\nclass nativemethodaccessorimpl extends methodaccessorimpl {\n    private final method method;\n    private delegatingmethodaccessorimpl parent;\n    private int numinvocations;\n\n    nativemethodaccessorimpl(method var1) {\n        this.method = var1;\n    }\n\t\n\t//每次进行反射调用，会让numinvocation与reflectionfactory.inflationthreshold的值（15）进行比较，并使使得numinvocation的值加一\n\t//如果numinvocation>reflectionfactory.inflationthreshold，则会调用本地方法invoke0方法\n    public object invoke(object var1, object[] var2) throws illegalargumentexception, invocationtargetexception {\n        if (++this.numinvocations > reflectionfactory.inflationthreshold() && !reflectutil.isvmanonymousclass(this.method.getdeclaringclass())) {\n            methodaccessorimpl var3 = (methodaccessorimpl)(new methodaccessorgenerator()).generatemethod(this.method.getdeclaringclass(), this.method.getname(), this.method.getparametertypes(), this.method.getreturntype(), this.method.getexceptiontypes(), this.method.getmodifiers());\n            this.parent.setdelegate(var3);\n        }\n\n        return invoke0(this.method, var1, var2);\n    }\n\n    void setparent(delegatingmethodaccessorimpl var1) {\n        this.parent = var1;\n    }\n\n    private static native object invoke0(method var0, object var1, object[] var2);\n}\n//reflectionfactory.inflationthreshold()方法的返回值\nprivate static int inflationthreshold = 15;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 一开始if条件不满足，就会调用本地方法invoke0\n * 随着numinvocation的增大，当它大于reflectionfactory.inflationthreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率\n   * 这时会从反射调用变为正常调用，即直接调用 reflect1.foo()\n\n\n\n\n# 五、内存模型\n\n前往juc',charsets:{cjk:!0},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"Java基础",frontmatter:{title:"Java基础",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/f9a6a6/"},regularPath:"/01.Java/Java%E5%9F%BA%E7%A1%80.html",relativePath:"01.Java/Java基础.md",key:"v-64d333aa",path:"/pages/f9a6a6/",headers:[{level:3,title:"Java 8大基本数据类型",slug:"java-8大基本数据类型",normalizedTitle:"java 8大基本数据类型",charIndex:2},{level:3,title:"Object类中常见的方法",slug:"object类中常见的方法",normalizedTitle:"object类中常见的方法",charIndex:631},{level:3,title:"面向对象三大特征",slug:"面向对象三大特征",normalizedTitle:"面向对象三大特征",charIndex:1987},{level:3,title:"深拷贝与浅拷贝",slug:"深拷贝与浅拷贝",normalizedTitle:"深拷贝与浅拷贝",charIndex:2182},{level:3,title:"String、StringBuffer、StringBuilder",slug:"string、stringbuffer、stringbuilder",normalizedTitle:"string、stringbuffer、stringbuilder",charIndex:2307},{level:3,title:"== 和 equals()",slug:"和-equals",normalizedTitle:"== 和 equals()",charIndex:3518},{level:3,title:"hashCode() 与 equals()",slug:"hashcode-与-equals",normalizedTitle:"hashcode() 与 equals()",charIndex:4647}],headersStr:"Java 8大基本数据类型 Object类中常见的方法 面向对象三大特征 深拷贝与浅拷贝 String、StringBuffer、StringBuilder == 和 equals() hashCode() 与 equals()",content:"# Java 8大基本数据类型\n\nJava 中有 8 种基本数据类型，分别为：\n\n 1. 6 种数字类型：\n    * 4 种整数型：byte、short、int、long\n    * 2 种浮点型：float、double\n 2. 1 种字符类型：char\n 3. 1 种布尔型：boolean。\n\n这 8 种基本数据类型的默认值以及所占空间的大小如下：\n\n基本类型      位数   字节   默认值       取值范围\nbyte      8    1    0         -128 ~ 127\nshort     16   2    0         -32768 ~ 32767\nint       32   4    0         -2147483648 ~ 2147483647\nlong      64   8    0L        -9223372036854775808 ~ 9223372036854775807\nchar      16   2    'u0000'   0 ~ 65535\nfloat     32   4    0f        1.4E-45 ~ 3.4028235E38\ndouble    64   8    0d        4.9E-324 ~ 1.7976931348623157E308\nboolean   1         false     true、false\n\n\n# Object类中常见的方法\n\n//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。\npublic final native Class<?> getClass()\n\n//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。\npublic native int hashCode() \n\n//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。\npublic boolean equals(Object obj)\n\n//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n//实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable { }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 面向对象三大特征\n\n封装：\n\n封装是指把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息private。但是可以提供一些可以被外界访问的方法来操作属性set/get方法。\n\n继承：\n\n不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。\n\n多态：\n\n表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。\n\n\n# 深拷贝与浅拷贝\n\n * 浅拷贝：浅拷贝会在堆上创建一个新的对象，如果对象内部存在引用类型，浅拷贝直接复制内部对象的引用地址。也就是说拷贝对象和原对象共用同一个地址。\n\n * 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n\n\n# String、StringBuffer、StringBuilder\n\n可变性\n\nString是不可变的\n\n 1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。\n 2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。\n\nStringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，没有使用 final 和 private 关键字修饰， AbstractStringBuilder 类还提供了很多修改字符串的方法比如 常见的append 方法。\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n  \t//...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n线程安全性\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。\n\nAbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n\n性能\n\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险\n\n\n# == 和 equals()\n\n== 对于基本类型和引用类型的作用效果是不同的：\n\n * 对于基本数据类型来说，== 比较的是值。\n * 对于引用数据类型来说，== 比较的是对象的内存地址。\n\nequals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。\n\nObject 类 equals() 方法：\n\npublic boolean equals(Object obj) {\n     return (this == obj);\n}\n\n\n1\n2\n3\n\n\nequals() 方法存在两种使用情况：\n\n * 类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。\n * 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\nString类equals()方法：\n\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# hashCode() 与 equals()\n\nhashCode() 有什么用？\n\nhashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。\n\nhashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。\n\npublic native int hashCode();\n\n\n1\n\n\n为什么要有hashCode？\n\n以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？\n\n> 《Head First Java》\n> \n> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n\n总结 ：\n\n * equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。\n * 两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。",normalizedContent:"# java 8大基本数据类型\n\njava 中有 8 种基本数据类型，分别为：\n\n 1. 6 种数字类型：\n    * 4 种整数型：byte、short、int、long\n    * 2 种浮点型：float、double\n 2. 1 种字符类型：char\n 3. 1 种布尔型：boolean。\n\n这 8 种基本数据类型的默认值以及所占空间的大小如下：\n\n基本类型      位数   字节   默认值       取值范围\nbyte      8    1    0         -128 ~ 127\nshort     16   2    0         -32768 ~ 32767\nint       32   4    0         -2147483648 ~ 2147483647\nlong      64   8    0l        -9223372036854775808 ~ 9223372036854775807\nchar      16   2    'u0000'   0 ~ 65535\nfloat     32   4    0f        1.4e-45 ~ 3.4028235e38\ndouble    64   8    0d        4.9e-324 ~ 1.7976931348623157e308\nboolean   1         false     true、false\n\n\n# object类中常见的方法\n\n//native方法，用于返回当前运行时对象的class对象，使用了final关键字修饰，故不允许子类重写。\npublic final native class<?> getclass()\n\n//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如jdk中的hashmap。\npublic native int hashcode() \n\n//用于比较2个对象的内存地址是否相等，string类对该方法进行了重写用户比较字符串的值是否相等。\npublic boolean equals(object obj)\n\n//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getclass() == x.getclass() 为true。object本身没有实现cloneable接口，所以不重写clone方法并且进行调用的话会发生clonenotsupportedexception异常。\nprotected native object clone() throws clonenotsupportedexception\n\n//返回类的名字@实例的哈希码的16进制的字符串。建议object所有的子类都重写这个方法。\npublic string tostring()\n\n//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyall()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws interruptedexception\n\n//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws interruptedexception\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws interruptedexception\n\n//实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws throwable { }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 面向对象三大特征\n\n封装：\n\n封装是指把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息private。但是可以提供一些可以被外界访问的方法来操作属性set/get方法。\n\n继承：\n\n不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。\n\n多态：\n\n表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。\n\n\n# 深拷贝与浅拷贝\n\n * 浅拷贝：浅拷贝会在堆上创建一个新的对象，如果对象内部存在引用类型，浅拷贝直接复制内部对象的引用地址。也就是说拷贝对象和原对象共用同一个地址。\n\n * 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n\n\n# string、stringbuffer、stringbuilder\n\n可变性\n\nstring是不可变的\n\n 1. 保存字符串的数组被 final 修饰且为私有的，并且string 类没有提供/暴露修改这个字符串的方法。\n 2. string 类被 final 修饰导致其不能被继承，进而避免了子类破坏 string 不可变。\n\nstringbuilder 与 stringbuffer 都继承自 abstractstringbuilder 类，在 abstractstringbuilder 中也是使用字符数组保存字符串，没有使用 final 和 private 关键字修饰， abstractstringbuilder 类还提供了很多修改字符串的方法比如 常见的append 方法。\n\nabstract class abstractstringbuilder implements appendable, charsequence {\n    char[] value;\n    public abstractstringbuilder append(string str) {\n        if (str == null)\n            return appendnull();\n        int len = str.length();\n        ensurecapacityinternal(count + len);\n        str.getchars(0, len, value, count);\n        count += len;\n        return this;\n    }\n  \t//...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n线程安全性\n\nstring 中的对象是不可变的，也就可以理解为常量，线程安全。\n\nabstractstringbuilder 是 stringbuilder 与 stringbuffer 的公共父类，定义了一些字符串的基本操作，如 expandcapacity、append、insert、indexof 等公共方法。stringbuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。stringbuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n\n性能\n\n每次对 string 类型进行改变的时候，都会生成一个新的 string 对象，然后将指针指向新的 string 对象。stringbuffer 每次都会对 stringbuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 stringbuilder 相比使用 stringbuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险\n\n\n# == 和 equals()\n\n== 对于基本类型和引用类型的作用效果是不同的：\n\n * 对于基本数据类型来说，== 比较的是值。\n * 对于引用数据类型来说，== 比较的是对象的内存地址。\n\nequals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于object类中，而object类是所有类的直接或间接父类，因此所有的类都有equals()方法。\n\nobject 类 equals() 方法：\n\npublic boolean equals(object obj) {\n     return (this == obj);\n}\n\n\n1\n2\n3\n\n\nequals() 方法存在两种使用情况：\n\n * 类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 object类equals()方法。\n * 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\nstring类equals()方法：\n\npublic boolean equals(object anobject) {\n    if (this == anobject) {\n        return true;\n    }\n    if (anobject instanceof string) {\n        string anotherstring = (string)anobject;\n        int n = value.length;\n        if (n == anotherstring.value.length) {\n            char v1[] = value;\n            char v2[] = anotherstring.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# hashcode() 与 equals()\n\nhashcode() 有什么用？\n\nhashcode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。\n\nhashcode()定义在 jdk 的 object 类中，这就意味着 java 中的任何类都包含有 hashcode() 函数。另外需要注意的是： object 的 hashcode() 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。\n\npublic native int hashcode();\n\n\n1\n\n\n为什么要有hashcode？\n\n以“hashset 如何检查重复”为例子来说明为什么要有 hashcode？\n\n> 《head first java》\n> \n> 当你把对象加入 hashset 时，hashset 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，hashset 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，hashset 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n\n总结 ：\n\n * equals 方法判断两个对象是相等的，那这两个对象的 hashcode 值也要相等。\n * 两个对象有相同的 hashcode 值，他们也不一定是相等的（哈希碰撞）。",charsets:{cjk:!0},lastUpdated:"2022/05/24, 15:05:00",lastUpdatedTimestamp:1653405625e3},{title:"Java并发",frontmatter:{title:"Java并发",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/f2ec12/"},regularPath:"/01.Java/Java%E5%B9%B6%E5%8F%91.html",relativePath:"01.Java/Java并发.md",key:"v-648c7cfe",path:"/pages/f2ec12/",headers:[{level:2,title:"1、进程与线程",slug:"_1、进程与线程",normalizedTitle:"1、进程与线程",charIndex:45},{level:3,title:"进程",slug:"进程",normalizedTitle:"进程",charIndex:47},{level:3,title:"线程",slug:"线程",normalizedTitle:"线程",charIndex:50},{level:3,title:"二者对比",slug:"二者对比",normalizedTitle:"二者对比",charIndex:427},{level:2,title:"2、并发与并行",slug:"_2、并发与并行",normalizedTitle:"2、并发与并行",charIndex:1378},{level:3,title:"3、应用",slug:"_3、应用",normalizedTitle:"3、应用",charIndex:1542},{level:2,title:"1、创建一个线程（非主线程）",slug:"_1、创建一个线程-非主线程",normalizedTitle:"1、创建一个线程（非主线程）",charIndex:2238},{level:3,title:"方法一：通过继承Thread创建线程",slug:"方法一-通过继承thread创建线程",normalizedTitle:"方法一：通过继承thread创建线程",charIndex:2257},{level:3,title:"方法二：使用Runnable配合Thread(推荐)",slug:"方法二-使用runnable配合thread-推荐",normalizedTitle:"方法二：使用runnable配合thread(推荐)",charIndex:2725},{level:3,title:"方法三：使用FutureTask与Thread结合",slug:"方法三-使用futuretask与thread结合",normalizedTitle:"方法三：使用futuretask与thread结合",charIndex:4143},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5254},{level:2,title:"2、原理之线程运行",slug:"_2、原理之线程运行",normalizedTitle:"2、原理之线程运行",charIndex:5450},{level:2,title:"3、常用方法",slug:"_3、常用方法",normalizedTitle:"3、常用方法",charIndex:6025},{level:3,title:"(1)start() vs run()",slug:"_1-start-vs-run",normalizedTitle:"(1)start() vs run()",charIndex:6036},{level:3,title:"(2)sleep()与yield()",slug:"_2-sleep-与yield",normalizedTitle:"(2)sleep()与yield()",charIndex:6164},{level:3,title:"(3)join()方法",slug:"_3-join-方法",normalizedTitle:"(3)join()方法",charIndex:6860},{level:3,title:"(4)interrupt()方法",slug:"_4-interrupt-方法",normalizedTitle:"(4)interrupt()方法",charIndex:7106},{level:3,title:"(5)不推荐使用的打断方法",slug:"_5-不推荐使用的打断方法",normalizedTitle:"(5)不推荐使用的打断方法",charIndex:8638},{level:3,title:"(6)守护线程",slug:"_6-守护线程",normalizedTitle:"(6)守护线程",charIndex:8736},{level:2,title:"4、线程的状态",slug:"_4、线程的状态",normalizedTitle:"4、线程的状态",charIndex:8998},{level:3,title:"(1)五种状态",slug:"_1-五种状态",normalizedTitle:"(1)五种状态",charIndex:9010},{level:3,title:"(2)六种状态",slug:"_2-六种状态",normalizedTitle:"(2)六种状态",charIndex:9431},{level:2,title:"1、共享带来的问题",slug:"_1、共享带来的问题",normalizedTitle:"1、共享带来的问题",charIndex:9807},{level:3,title:"(1)临界区 Critical Section",slug:"_1-临界区-critical-section",normalizedTitle:"(1)临界区 critical section",charIndex:9821},{level:3,title:"(2)竞态条件 Race Condition",slug:"_2-竞态条件-race-condition",normalizedTitle:"(2)竞态条件 race condition",charIndex:10169},{level:2,title:"2、synchronized 解决方案",slug:"_2、synchronized-解决方案",normalizedTitle:"2、synchronized 解决方案",charIndex:10241},{level:3,title:"(1)解决手段",slug:"_1-解决手段",normalizedTitle:"(1)解决手段",charIndex:10265},{level:3,title:"(2)synchronized语法",slug:"_2-synchronized语法",normalizedTitle:"(2)synchronized语法",charIndex:10507},{level:3,title:"(3)synchronized加在方法上",slug:"_3-synchronized加在方法上",normalizedTitle:"(3)synchronized加在方法上",charIndex:11330},{level:2,title:"3、变量的线程安全分析",slug:"_3、变量的线程安全分析",normalizedTitle:"3、变量的线程安全分析",charIndex:11922},{level:3,title:"常见线程安全类",slug:"常见线程安全类",normalizedTitle:"常见线程安全类",charIndex:12328},{level:3,title:"不可变类线程安全性",slug:"不可变类线程安全性",normalizedTitle:"不可变类线程安全性",charIndex:12583},{level:2,title:"4、Monitor概念",slug:"_4、monitor概念",normalizedTitle:"4、monitor概念",charIndex:12771},{level:3,title:"(1)原理之Monitor",slug:"_1-原理之monitor",normalizedTitle:"(1)原理之monitor",charIndex:12787},{level:2,title:"5、Synchronized原理进阶",slug:"_5、synchronized原理进阶",normalizedTitle:"5、synchronized原理进阶",charIndex:13299},{level:3,title:"对象头格式",slug:"对象头格式",normalizedTitle:"对象头格式",charIndex:13322},{level:3,title:"(1)轻量级锁（用于优化Monitor这类的重量级锁）",slug:"_1-轻量级锁-用于优化monitor这类的重量级锁",normalizedTitle:"(1)轻量级锁（用于优化monitor这类的重量级锁）",charIndex:13334},{level:3,title:"(2)锁膨胀",slug:"_2-锁膨胀",normalizedTitle:"(2)锁膨胀",charIndex:13675},{level:3,title:"(3)自旋优化",slug:"_3-自旋优化",normalizedTitle:"(3)自旋优化",charIndex:13894},{level:3,title:"(4)偏向锁(用于优化轻量级锁重入)",slug:"_4-偏向锁-用于优化轻量级锁重入",normalizedTitle:"(4)偏向锁(用于优化轻量级锁重入)",charIndex:13998},{level:3,title:"(5)批量重偏向",slug:"_5-批量重偏向",normalizedTitle:"(5)批量重偏向",charIndex:14690},{level:3,title:"(6)批量撤销",slug:"_6-批量撤销",normalizedTitle:"(6)批量撤销",charIndex:14828},{level:2,title:"6、Wait/Notify",slug:"_6、wait-notify",normalizedTitle:"6、wait/notify",charIndex:14875},{level:3,title:"(1)原理",slug:"_1-原理",normalizedTitle:"(1)原理",charIndex:12787},{level:3,title:"(2)Wait与Sleep的区别",slug:"_2-wait与sleep的区别",normalizedTitle:"(2)wait与sleep的区别",charIndex:15560},{level:3,title:"(3)优雅地使用wait/notify",slug:"_3-优雅地使用wait-notify",normalizedTitle:"(3)优雅地使用wait/notify",charIndex:15785},{level:2,title:"7、模式之保护性暂停",slug:"_7、模式之保护性暂停",normalizedTitle:"7、模式之保护性暂停",charIndex:16241},{level:3,title:"(1)定义",slug:"_1-定义",normalizedTitle:"(1)定义",charIndex:16256},{level:3,title:"(2)举例",slug:"_2-举例",normalizedTitle:"(2)举例",charIndex:16268},{level:3,title:"(3)join源码——使用保护性暂停模式",slug:"_3-join源码-使用保护性暂停模式",normalizedTitle:"(3)join源码——使用保护性暂停模式",charIndex:18093},{level:2,title:"8、park/unpark",slug:"_8、park-unpark",normalizedTitle:"8、park/unpark",charIndex:18838},{level:3,title:"(1)基本使用",slug:"_1-基本使用",normalizedTitle:"(1)基本使用",charIndex:18856},{level:3,title:"(2)特点",slug:"_2-特点",normalizedTitle:"(2)特点",charIndex:19362},{level:3,title:"(3)原理",slug:"_3-原理",normalizedTitle:"(3)原理",charIndex:19614},{level:2,title:"9、线程中的状态转换",slug:"_9、线程中的状态转换",normalizedTitle:"9、线程中的状态转换",charIndex:20154},{level:3,title:"情况一：NEW –> RUNNABLE",slug:"情况一-new-runnable",normalizedTitle:"情况一：new –&gt; runnable",charIndex:null},{level:3,title:"情况二： RUNNABLE  WAITING",slug:"情况二-runnable-waiting",normalizedTitle:"情况二： runnable  waiting",charIndex:null},{level:3,title:"情况三：RUNNABLE  WAITING",slug:"情况三-runnable-waiting",normalizedTitle:"情况三：runnable  waiting",charIndex:null},{level:3,title:"情况四： RUNNABLE  WAITING",slug:"情况四-runnable-waiting",normalizedTitle:"情况四： runnable  waiting",charIndex:null},{level:3,title:"情况五： RUNNABLE  TIMED_WAITING",slug:"情况五-runnable-timed-waiting",normalizedTitle:"情况五： runnable  timed_waiting",charIndex:null},{level:3,title:"情况六：RUNNABLE  TIMED_WAITING",slug:"情况六-runnable-timed-waiting",normalizedTitle:"情况六：runnable  timed_waiting",charIndex:null},{level:3,title:"情况七：RUNNABLE  TIMED_WAITING",slug:"情况七-runnable-timed-waiting",normalizedTitle:"情况七：runnable  timed_waiting",charIndex:null},{level:3,title:"情况八：RUNNABLE  TIMED_WAITING",slug:"情况八-runnable-timed-waiting",normalizedTitle:"情况八：runnable  timed_waiting",charIndex:null},{level:3,title:"情况九：RUNNABLE  BLOCKED",slug:"情况九-runnable-blocked",normalizedTitle:"情况九：runnable  blocked",charIndex:null},{level:3,title:"情况十： RUNNABLE  TERMINATED",slug:"情况十-runnable-terminated",normalizedTitle:"情况十： runnable  terminated",charIndex:null},{level:2,title:"10、多把锁",slug:"_10、多把锁",normalizedTitle:"10、多把锁",charIndex:22013},{level:2,title:"11、活跃性",slug:"_11、活跃性",normalizedTitle:"11、活跃性",charIndex:22176},{level:3,title:"(1)定义",slug:"_1-定义-2",normalizedTitle:"(1)定义",charIndex:16256},{level:3,title:"(2)死锁",slug:"_2-死锁",normalizedTitle:"(2)死锁",charIndex:22229},{level:3,title:"(3)活锁",slug:"_3-活锁",normalizedTitle:"(3)活锁",charIndex:24007},{level:3,title:"(4)饥饿",slug:"_4-饥饿",normalizedTitle:"(4)饥饿",charIndex:24186},{level:2,title:"12、ReentrantLock",slug:"_12、reentrantlock",normalizedTitle:"12、reentrantlock",charIndex:24244},{level:2,title:"13、同步模式之顺序控制",slug:"_13、同步模式之顺序控制",normalizedTitle:"13、同步模式之顺序控制",charIndex:31838},{level:3,title:"Wait/Notify版本",slug:"wait-notify版本",normalizedTitle:"wait/notify版本",charIndex:31855},{level:3,title:"交替输出",slug:"交替输出",normalizedTitle:"交替输出",charIndex:32445},{level:2,title:"14、ThreadLocal",slug:"_14、threadlocal",normalizedTitle:"14、threadlocal",charIndex:35133},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:35152},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:990},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:3970},{level:2,title:"15、InheritableThreadLocal",slug:"_15、inheritablethreadlocal",normalizedTitle:"15、inheritablethreadlocal",charIndex:40218},{level:3,title:"简介",slug:"简介-2",normalizedTitle:"简介",charIndex:35152},{level:3,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:990},{level:3,title:"原理",slug:"原理-2",normalizedTitle:"原理",charIndex:3970},{level:2,title:"1、JAVA内存模型（JMM）",slug:"_1、java内存模型-jmm",normalizedTitle:"1、java内存模型（jmm）",charIndex:44626},{level:2,title:"2、可见性",slug:"_2、可见性",normalizedTitle:"2、可见性",charIndex:44838},{level:2,title:"3、有序性",slug:"_3、有序性",normalizedTitle:"3、有序性",charIndex:48797},{level:3,title:"指令重排",slug:"指令重排",normalizedTitle:"指令重排",charIndex:48807},{level:3,title:"指令重排序优化",slug:"指令重排序优化",normalizedTitle:"指令重排序优化",charIndex:48884},{level:3,title:"支持流水线的处理器",slug:"支持流水线的处理器",normalizedTitle:"支持流水线的处理器",charIndex:49281},{level:3,title:"解决办法",slug:"解决办法",normalizedTitle:"解决办法",charIndex:49501},{level:2,title:"4、内存屏障",slug:"_4、内存屏障",normalizedTitle:"4、内存屏障",charIndex:49567},{level:2,title:"5、volatile 原理",slug:"_5、volatile-原理",normalizedTitle:"5、volatile 原理",charIndex:49756},{level:3,title:"如何保证可见性",slug:"如何保证可见性",normalizedTitle:"如何保证可见性",charIndex:49882},{level:3,title:"如何保证有序性",slug:"如何保证有序性",normalizedTitle:"如何保证有序性",charIndex:49998},{level:3,title:"实现原理之Lock前缀",slug:"实现原理之lock前缀",normalizedTitle:"实现原理之lock前缀",charIndex:50182},{level:2,title:"1、无锁解决线程安全问题",slug:"_1、无锁解决线程安全问题",normalizedTitle:"1、无锁解决线程安全问题",charIndex:50782},{level:2,title:"2、CAS与volatile",slug:"_2、cas与volatile",normalizedTitle:"2、cas与volatile",charIndex:52689},{level:3,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:52847},{level:3,title:"volatile",slug:"volatile",normalizedTitle:"volatile",charIndex:45365},{level:3,title:"效率问题",slug:"效率问题",normalizedTitle:"效率问题",charIndex:53524},{level:3,title:"CAS特点",slug:"cas特点",normalizedTitle:"cas特点",charIndex:53562},{level:2,title:"3、原子整数",slug:"_3、原子整数",normalizedTitle:"3、原子整数",charIndex:53892},{level:2,title:"4、原子引用",slug:"_4、原子引用",normalizedTitle:"4、原子引用",charIndex:55258},{level:2,title:"5、ABA问题",slug:"_5、aba问题",normalizedTitle:"5、aba问题",charIndex:56757},{level:3,title:"AtomicStampedReference",slug:"atomicstampedreference",normalizedTitle:"atomicstampedreference",charIndex:57762},{level:3,title:"AtomicMarkableReference",slug:"atomicmarkablereference",normalizedTitle:"atomicmarkablereference",charIndex:58940},{level:3,title:"两者的区别",slug:"两者的区别",normalizedTitle:"两者的区别",charIndex:6e4},{level:2,title:"6、原子数组",slug:"_6、原子数组",normalizedTitle:"6、原子数组",charIndex:60114},{level:3,title:"lamba表达式的使用",slug:"lamba表达式的使用",normalizedTitle:"lamba表达式的使用",charIndex:60191},{level:2,title:"7、原子更新器",slug:"_7、原子更新器",normalizedTitle:"7、原子更新器",charIndex:60311},{level:3,title:"原子更新器初始化过程",slug:"原子更新器初始化过程",normalizedTitle:"原子更新器初始化过程",charIndex:61149},{level:2,title:"8、LongAdder原理",slug:"_8、longadder原理",normalizedTitle:"8、longadder原理",charIndex:64763},{level:3,title:"原理之伪共享",slug:"原理之伪共享",normalizedTitle:"原理之伪共享",charIndex:64781},{level:2,title:"9、Unsafe",slug:"_9、unsafe",normalizedTitle:"9、unsafe",charIndex:65832},{level:3,title:"1、不可变",slug:"_1、不可变",normalizedTitle:"1、不可变",charIndex:66951},{level:3,title:"2、不可变设计",slug:"_2、不可变设计",normalizedTitle:"2、不可变设计",charIndex:67006},{level:2,title:"1、自定义线程池",slug:"_1、自定义线程池",normalizedTitle:"1、自定义线程池",charIndex:68823},{level:3,title:"图解",slug:"图解",normalizedTitle:"图解",charIndex:68836},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:181},{level:2,title:"2、ThreadPoolExecutor",slug:"_2、threadpoolexecutor",normalizedTitle:"2、threadpoolexecutor",charIndex:74590},{level:3,title:"继承关系",slug:"继承关系",normalizedTitle:"继承关系",charIndex:74615},{level:3,title:"线程池状态",slug:"线程池状态",normalizedTitle:"线程池状态",charIndex:74626},{level:3,title:"线程池属性",slug:"线程池属性",normalizedTitle:"线程池属性",charIndex:76100},{level:3,title:"构造方法极其参数",slug:"构造方法极其参数",normalizedTitle:"构造方法极其参数",charIndex:76526},{level:3,title:"FixedThreadPool",slug:"fixedthreadpool",normalizedTitle:"fixedthreadpool",charIndex:78938},{level:3,title:"CachedThreadPool",slug:"cachedthreadpool",normalizedTitle:"cachedthreadpool",charIndex:80155},{level:3,title:"SingleThread",slug:"singlethread",normalizedTitle:"singlethread",charIndex:80624},{level:3,title:"执行任务",slug:"执行任务",normalizedTitle:"执行任务",charIndex:70139},{level:3,title:"停止",slug:"停止",normalizedTitle:"停止",charIndex:7327}],headersStr:"1、进程与线程 进程 线程 二者对比 2、并发与并行 3、应用 1、创建一个线程（非主线程） 方法一：通过继承Thread创建线程 方法二：使用Runnable配合Thread(推荐) 方法三：使用FutureTask与Thread结合 总结 2、原理之线程运行 3、常用方法 (1)start() vs run() (2)sleep()与yield() (3)join()方法 (4)interrupt()方法 (5)不推荐使用的打断方法 (6)守护线程 4、线程的状态 (1)五种状态 (2)六种状态 1、共享带来的问题 (1)临界区 Critical Section (2)竞态条件 Race Condition 2、synchronized 解决方案 (1)解决手段 (2)synchronized语法 (3)synchronized加在方法上 3、变量的线程安全分析 常见线程安全类 不可变类线程安全性 4、Monitor概念 (1)原理之Monitor 5、Synchronized原理进阶 对象头格式 (1)轻量级锁（用于优化Monitor这类的重量级锁） (2)锁膨胀 (3)自旋优化 (4)偏向锁(用于优化轻量级锁重入) (5)批量重偏向 (6)批量撤销 6、Wait/Notify (1)原理 (2)Wait与Sleep的区别 (3)优雅地使用wait/notify 7、模式之保护性暂停 (1)定义 (2)举例 (3)join源码——使用保护性暂停模式 8、park/unpark (1)基本使用 (2)特点 (3)原理 9、线程中的状态转换 情况一：NEW –> RUNNABLE 情况二： RUNNABLE  WAITING 情况三：RUNNABLE  WAITING 情况四： RUNNABLE  WAITING 情况五： RUNNABLE  TIMED_WAITING 情况六：RUNNABLE  TIMED_WAITING 情况七：RUNNABLE  TIMED_WAITING 情况八：RUNNABLE  TIMED_WAITING 情况九：RUNNABLE  BLOCKED 情况十： RUNNABLE  TERMINATED 10、多把锁 11、活跃性 (1)定义 (2)死锁 (3)活锁 (4)饥饿 12、ReentrantLock 13、同步模式之顺序控制 Wait/Notify版本 交替输出 14、ThreadLocal 简介 使用 原理 15、InheritableThreadLocal 简介 使用 原理 1、JAVA内存模型（JMM） 2、可见性 3、有序性 指令重排 指令重排序优化 支持流水线的处理器 解决办法 4、内存屏障 5、volatile 原理 如何保证可见性 如何保证有序性 实现原理之Lock前缀 1、无锁解决线程安全问题 2、CAS与volatile 工作流程 volatile 效率问题 CAS特点 3、原子整数 4、原子引用 5、ABA问题 AtomicStampedReference AtomicMarkableReference 两者的区别 6、原子数组 lamba表达式的使用 7、原子更新器 原子更新器初始化过程 8、LongAdder原理 原理之伪共享 9、Unsafe 1、不可变 2、不可变设计 1、自定义线程池 图解 代码 2、ThreadPoolExecutor 继承关系 线程池状态 线程池属性 构造方法极其参数 FixedThreadPool CachedThreadPool SingleThread 执行任务 停止",content:'本篇笔记根据\n\n黑马java并发编程教程\n\n学习而做的笔记\n\n\n# 一、基本概念\n\n\n# 1、进程与线程\n\n\n# 进程\n\n * 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。\n * 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\n * 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）\n\n\n# 线程\n\n * 一个进程之内可以分为一到多个线程。\n * 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。\n * Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器\n\n\n# 二者对比\n\n * 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享\n   * 进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）\n   * 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP\n * 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低\n\n# 进程和线程的切换\n\n上下文切换\n\n内核为每一个进程维持一个上下文。**上下文就是内核重新启动一个被抢占的进程所需的状态。**包括以下内容：\n\n * 通用目的寄存器\n * 浮点寄存器\n * 程序计数器\n * 用户栈\n * 状态寄存器\n * 内核栈\n * 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表\n\n进程切换和线程切换的主要区别\n\n最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换\n\n页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快\n\n而且还可能出现缺页中断，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间\n\n为什么TLB能加快访问速度\n\n快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查\n\n\n# 2、并发与并行\n\n并发是一个CPU在不同的时间去不同线程中执行指令。\n\n并行是多个CPU同时处理不同的线程。\n\n引用 Rob Pike 的一段描述：\n\n * 并发（concurrent）是同一时间应对（dealing with）多件事情的能力\n * 并行（parallel）是同一时间动手做（doing）多件事情的能力\n\n\n# 3、应用\n\n# 应用之异步调用（案例1）\n\n以调用方角度来讲，如果\n\n * 需要等待结果返回，才能继续运行就是同步\n * 不需要等待结果返回，就能继续运行就是异步\n\n\\1) 设计 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停… \\2) 结论\n\n * 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程\n * tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞\n * tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程\n\n结论\n\n 1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活\n 2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的\n    * 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）\n    * 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义\n 3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化\n\n\n# 二、线程的创建\n\n\n# 1、创建一个线程（非主线程）\n\n\n# 方法一：通过继承Thread创建线程\n\npublic class CreateThread {\n\tpublic static void main(String[] args) {\n\t\tThread myThread = new MyThread();\n        // 启动线程\n\t\tmyThread.start();\n\t}\n}\n\nclass MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println("my thread running...");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码\n\n\n# 方法二：使用Runnable配合Thread(推荐)\n\npublic class Test2 {\n\tpublic static void main(String[] args) {\n\t\t//创建线程任务\n\t\tRunnable r = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println("Runnable running");\n\t\t\t}\n\t\t};\n\t\t//将Runnable对象传给Thread\n\t\tThread t = new Thread(r);\n\t\t//启动线程\n\t\tt.start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n或者\n\npublic class CreateThread2 {\n   private static class MyRunnable implements Runnable {\n\n      @Override\n      public void run() {\n         System.out.println("my runnable running...");\n      }\n   }\n\n   public static void main(String[] args) {\n      MyRunnable myRunnable = new MyRunnable();\n      Thread thread = new Thread(myRunnable);\n      thread.start();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可\n\n# 方法二的简化：使用lambda表达式简化操作\n\n当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的\n\n所以方法二中的代码可以被简化为\n\npublic class Test2 {\n\tpublic static void main(String[] args) {\n\t\t//创建线程任务\n\t\tRunnable r = () -> {\n            //直接写方法体即可\n\t\t\tSystem.out.println("Runnable running");\n\t\t\tSystem.out.println("Hello Thread");\n\t\t};\n\t\t//将Runnable对象传给Thread\n\t\tThread t = new Thread(r);\n\t\t//启动线程\n\t\tt.start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以再Runnable上使用Alt+Enter\n\n\n\n# 原理之 Thread 与 Runnable 的关系\n\n分析 Thread 的源码，理清它与 Runnable 的关系 小结\n\n * 方法1 是把线程和任务合并在了一起\n * 方法2 是把线程和任务分开了\n * 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活\n\n\n# 方法三：使用FutureTask与Thread结合\n\n使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）\n\npublic class Test3 {\n\tpublic static void main(String[] args) throws ExecutionException, InterruptedException {\n        //需要传入一个Callable对象\n\t\tFutureTask<Integer> task = new FutureTask<Integer>(new Callable<Integer>() {\n\t\t\t@Override\n\t\t\tpublic Integer call() throws Exception {\n\t\t\t\tSystem.out.println("线程执行!");\n\t\t\t\tThread.sleep(1000);\n\t\t\t\treturn 100;\n\t\t\t}\n\t\t});\n\n\t\tThread r1 = new Thread(task, "t2");\n\t\tr1.start();\n\t\t//获取线程中方法执行后的返回结果\n\t\tSystem.out.println(task.get());\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n或\n\npublic class UseFutureTask {\n   public static void main(String[] args) throws ExecutionException, InterruptedException {\n      FutureTask<String> futureTask = new FutureTask<>(new MyCall());\n      Thread thread = new Thread(futureTask);\n      thread.start();\n      // 获得线程运行后的返回值\n      System.out.println(futureTask.get());\n   }\n}\n\nclass MyCall implements Callable<String> {\n   @Override\n   public String call() throws Exception {\n      return "hello world";\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 总结\n\n使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以\n\n\n# 2、原理之线程运行\n\n# 栈与栈帧\n\nJava Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？\n\n * 其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存\n * 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存\n * 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n\n# 线程上下文切换（Thread Context Switch）\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码\n\n * 线程的 cpu 时间片用完\n * 垃圾回收 有更高优先级的线程需要运行\n * 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的\n\n * 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等\n * Context Switch 频繁发生会影响性能\n\n\n# 3、常用方法\n\n\n# (1)start() vs run()\n\n被创建的Thread对象直接调用重写的run方法时， run方法是在主线程中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，需要使用Thread对象的start方法。\n\n\n# (2)sleep()与yield()\n\n# sleep (使线程阻塞)\n\n 1. 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），可通过state()方法查看\n\n 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException\n\n 3. 睡眠结束后的线程未必会立刻得到执行\n\n 4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 。如：\n    \n    //休眠一秒\n    TimeUnit.SECONDS.sleep(1);\n    //休眠一分钟\n    TimeUnit.MINUTES.sleep(1);\n    \n    \n    1\n    2\n    3\n    4\n    \n\n# yield （让出当前线程）\n\n 1. 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态（仍然有可能被执行），然后调度执行其它线程\n 2. 具体的实现依赖于操作系统的任务调度器\n\n# 线程优先级\n\n * 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它\n\n * 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用\n\n * 设置方法：\n   \n   thread1.setPriority(Thread.MAX_PRIORITY); //设置为优先级最高\n   \n   \n   1\n   \n\n\n# (3)join()方法\n\n用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。\n\n如在主线程中调用ti.join()，则是主线程等待t1线程结束\n\nThread thread = new Thread();\n//等待thread线程执行结束\nthread.join();\n//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms\nthread.join(1000);\n\n\n1\n2\n3\n4\n5\n\n\n\n# (4)interrupt()方法\n\n用于打断阻塞(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。\n\n * 如果一个线程在在运行中被打断，打断标记会被置为true。\n * 如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false\n\n//用于查看打断标记，返回值被boolean类型\nt1.isInterrupted();\n\n\n1\n2\n\n\n正常运行的线程在被打断后，不会停止，会继续执行。如果要让线程在被打断后停下来，需要使用打断标记来判断。\n\nwhile(true) {\n    if(Thread.currentThread().isInterrupted()) {\n        break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# interrupt方法的应用——两阶段终止模式\n\n当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来优雅的停止线程二。\n\n\n\n代码\n\npublic class Test7 {\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tMonitor monitor = new Monitor();\n\t\tmonitor.start();\n\t\tThread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass Monitor {\n\n\tThread monitor;\n\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n                    //判断当前线程是否被打断了\n\t\t\t\t\tif(Thread.currentThread().isInterrupted()) {\n\t\t\t\t\t\tSystem.out.println("处理后续任务");\n                        //终止线程执行\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# (5)不推荐使用的打断方法\n\n * stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）\n * suspend（暂停线程）/resume（恢复线程）方法\n\n\n# (6)守护线程\n\n当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。\n\n//将线程设置为守护线程, 默认为false\nmonitor.setDaemon(true);\n\n\n1\n2\n\n\n守护线程的应用\n\n * 垃圾回收器线程就是一种守护线程\n * Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求\n\n\n# 4、线程的状态\n\n\n# (1)五种状态\n\n这是从 操作系统 层面来描述的\n\n\n\n * 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）\n * 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行\n * 【运行状态】指获取了 CPU 时间片运行中的状态\n   * 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换\n * 【阻塞状态】\n   * 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】\n   * 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】\n   * 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们\n * 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态\n\n\n# (2)六种状态\n\n这是从 Java API 层面来描述的 根据 Thread.State 枚举，分为六种状态\n\n\n\n * NEW 线程刚被创建，但是还没有调用 start() 方法\n * RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）\n * BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。\n * TERMINATED 当线程代码运行结束\n\n\n# 三、共享模型之管程\n\n\n# 1、共享带来的问题\n\n\n# (1)临界区 Critical Section\n\n * 一个程序运行多个线程本身是没有问题的\n * 问题出在多个线程访问共享资源\n   * 多个线程读共享资源其实也没有问题\n   * 在多个线程对共享资源读写操作时发生指令交错，就会出现问题\n * 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区\n\nstatic int counter = 0;\n \nstatic void increment() \n// 临界区 \n{   \n    counter++; \n}\n \nstatic void decrement() \n// 临界区 \n{ \n    counter--; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# (2)竞态条件 Race Condition\n\n多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件\n\n\n# 2、synchronized 解决方案\n\n\n# (1)解决手段\n\n为了避免临界区的竞态条件发生，有多种手段可以达到目的。\n\n * 阻塞式的解决方案：synchronized，Lock\n * 非阻塞式的解决方案：原子变量\n\n本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的**【对象锁】**，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换\n\n\n# (2)synchronized语法\n\nsynchronized(对象) {\n\t//临界区\n}\n\n\n1\n2\n3\n\n\n例：\n\nstatic int counter = 0; \n//创建一个公共对象，作为对象锁的对象\nstatic final Object room = new Object();\n \npublic static void main(String[] args) throws InterruptedException {    \n\tThread t1 = new Thread(() -> {        \n    for (int i = 0; i < 5000; i++) {            \n        synchronized (room) {     \n        counter++;            \n       \t }       \n \t   }    \n    }, "t1");\n \n    Thread t2 = new Thread(() -> {       \n        for (int i = 0; i < 5000; i++) {         \n            synchronized (room) {            \n            counter--;          \n            }    \n        } \n    }, "t2");\n \n    t1.start();    \n    t2.start(); \n    t1.join();   \n    t2.join();    \n    log.debug("{}",counter); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# (3)synchronized加在方法上\n\n * 加在成员方法上\n   \n   public class Demo {\n   \t//在方法上加上synchronized关键字\n   \tpublic synchronized void test() {\n   \t\n   \t}\n   \t//等价于\n   \tpublic void test() {\n   \t\tsynchronized(this) {\n   \t\t\n   \t\t}\n   \t}\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 加在静态方法上\n   \n   public class Demo {\n   \t//在静态方法上加上synchronized关键字\n   \tpublic synchronized static void test() {\n   \t\n   \t}\n   \t//等价于\n   \tpublic void test() {\n   \t\tsynchronized(Demo.class) {\n   \t\t\n   \t\t}\n   \t}\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 3、变量的线程安全分析\n\n# 成员变量和静态变量是否线程安全？\n\n * 如果它们没有共享，则线程安全\n * 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况\n   * 如果只有读操作，则线程安全\n   * 如果有读写操作，则这段代码是临界区，需要考虑线程安全\n\n# 局部变量是否线程安全？\n\n * 局部变量是线程安全的\n\n * 但局部变量引用的对象则未必 （要看该对象\n   \n   是否被共享\n   \n   且被执行了读写操作）\n   \n   * 如果该对象没有逃离方法的作用范围，它是线程安全的\n   * 如果该对象逃离方法的作用范围，需要考虑线程安全\n\n * 局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享\n\n\n\n * 如果调用的对象被共享，且执行了读写操作，则线程不安全\n\n\n\n * 如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。\n\n\n\n\n# 常见线程安全类\n\n * String\n * Integer\n * StringBuﬀer\n * Random\n * Vector （List的线程安全实现类）\n * Hashtable （Hash的线程安全实现类）\n * java.util.concurrent 包下的类\n\n这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的\n\n * 它们的每个方法是原子的（都被加上了synchronized）\n * 但注意它们多个方法的组合不是原子的，所以可能会出现线程安全问题\n\n\n\n\n# 不可变类线程安全性\n\nString、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的\n\n有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？\n\n这是因为这些方法的返回值都创建了一个新的对象，而不是直接改变String、Integer对象本身。\n\n\n# 4、Monitor概念\n\n\n# (1)原理之Monitor\n\n\n\n * 当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)是否绑定了Monitor。\n   \n   * 如果没有绑定，则会先去去与Monitor绑定，并且将Owner设为当前线程。\n   \n   * 如果\n     \n     已经绑定\n     \n     ，则会去查询该Monitor是否已经有了Owner\n     \n     * 如果没有，则Owner与将当前线程绑定\n     * 如果有，则放入EntryList，进入阻塞状态(blocked)\n\n * 当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于阻塞状态的线程会被叫醒并竞争，此时的竞争是非公平的\n\n * 注意：\n   \n   * 对象在使用了synchronized后与Monitor绑定时，会将对象头中的Mark Word置为Monitor指针。\n   * 每个对象都会绑定一个唯一的Monitor，如果synchronized中所指定的对象(obj)不同，则会绑定不同的Monitor\n\n\n# 5、Synchronized原理进阶\n\n\n# 对象头格式\n\n\n\n\n# (1)轻量级锁（用于优化Monitor这类的重量级锁）\n\n轻量级锁使用场景：当一个对象被多个线程所访问，但访问的时间是错开的（不存在竞争），此时就可以使用轻量级锁来优化。\n\n * 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）\n   \n   \n\n * 让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存\n\n\n\n * 如果cas替换成功，则将Object的对象头替换为锁记录的地址和状态 00（轻量级锁状态），并由该线程给对象加锁\n\n\n\n\n# (2)锁膨胀\n\n * 如果一个线程在给一个对象加轻量级锁时，cas替换操作失败（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入锁膨胀过程\n\n\n\n * 此时便会给对象加上重量级锁（使用Monitor）\n   \n   * 将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)\n   \n   * 并且该线程放入入EntryList中，并进入阻塞状态(blocked)\n     \n     \n\n\n# (3)自旋优化\n\n重量级锁竞争时，还可以使用自选来优化，如果当前线程在自旋成功（使用锁的线程退出了同步块，释放了锁），这时就可以避免线程进入阻塞状态。\n\n * 第一种情况\n\n\n\n * 第二种情况\n\n\n\n\n# (4)偏向锁(用于优化轻量级锁重入)\n\n轻量级锁在没有竞争时，每次重入（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。\n\n所以引入了偏向锁对性能进行优化：在第一次cas时会将线程的ID写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。\n\n\n\n# 偏向状态\n\n * Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）\n * Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）\n * Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后两位为状态（00）\n * Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，后两位为状态(10)\n\n\n\n * 如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101\n * 但是偏向锁默认是有延迟的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态\n * 如果没有开启偏向锁，对象的Mark Word后三位应该是001\n\n# 撤销偏向\n\n以下几种情况会使对象的偏向锁失效\n\n * 调用对象的hashCode方法\n * 多个线程使用该对象\n * 调用了wait/notify方法（调用wait方法会导致锁膨胀而使用重量级锁）\n\n\n# (5)批量重偏向\n\n * 如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2\n   * 重偏向会重置Thread ID\n * 当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。\n\n\n# (6)批量撤销\n\n当撤销偏向锁的阈值超过40以后，就会将整个类的对象都改为不可偏向的\n\n\n# 6、Wait/Notify\n\n\n# (1)原理\n\n\n\n * 锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。\n\n * 处于BLOCKED和WAITING状态的线程都为\n   \n   阻塞\n   \n   状态，CPU都不会分给他们时间片。但是有所区别：\n   \n   * BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态\n   * WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态\n\n * BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。\n\n注：只有当对象被锁以后，才能调用wait和notify方法\n\npublic class Test1 {\n\tfinal static Object LOCK = new Object();\n\tpublic static void main(String[] args) throws InterruptedException {\n        //只有在对象被锁住后才能调用wait方法\n\t\tsynchronized (LOCK) {\n\t\t\tLOCK.wait();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# (2)Wait与Sleep的区别\n\n不同点\n\n * Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。\n * Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁\n * Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）\n\n相同点\n\n * 阻塞状态都为TIMED_WAITING\n\n\n# (3)优雅地使用wait/notify\n\n什么时候适合使用wait\n\n * 当线程不满足某些条件，需要暂停运行时，可以使用wait。这样会将对象的锁释放，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。\n\n使用wait/notify需要注意什么\n\n * 当有多个线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了notify方法，可能会造成虚假唤醒（唤醒的不是满足条件的等待线程），这时就需要使用notifyAll方法\n\nsynchronized (LOCK) {\n\twhile(//不满足条件，一直等待，避免虚假唤醒) {\n\t\tLOCK.wait();\n\t}\n\t//满足条件后再运行\n}\n\nsynchronized (LOCK) {\n\t//唤醒所有等待线程\n\tLOCK.notifyAll();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7、模式之保护性暂停\n\n\n# (1)定义\n\n\n\n\n# (2)举例\n\npublic class Test2 {\n\tpublic static void main(String[] args) {\n\t\tString hello = "hello thread!";\n\t\tGuarded guarded = new Guarded();\n\t\tnew Thread(()->{\n\t\t\tSystem.out.println("想要得到结果");\n\t\t\tsynchronized (guarded) {\n\t\t\t\tSystem.out.println("结果是："+guarded.getResponse());\n\t\t\t}\n\t\t\tSystem.out.println("得到结果");\n\t\t}).start();\n\n\t\tnew Thread(()->{\n\t\t\tSystem.out.println("设置结果");\n\t\t\tsynchronized (guarded) {\n\t\t\t\tguarded.setResponse(hello);\n\t\t\t}\n\t\t}).start();\n\t}\n}\n\nclass Guarded {\n\t/**\n\t * 要返回的结果\n\t */\n\tprivate Object response;\n\t\n    //优雅地使用wait/notify\n\tpublic Object getResponse() {\n\t\t//如果返回结果为空就一直等待，避免虚假唤醒\n\t\twhile(response == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.wait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn response;\n\t}\n\n\tpublic void setResponse(Object response) {\n\t\tthis.response = response;\n\t\tsynchronized (this) {\n\t\t\t//唤醒休眠的线程\n\t\t\tthis.notifyAll();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "Guarded{" +\n\t\t\t\t"response=" + response +\n\t\t\t\t\'}\';\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n带超时判断的暂停\n\npublic Object getResponse(long time) {\n\t\tsynchronized (this) {\n\t\t\t//获取开始时间\n\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t//用于保存已经等待了的时间\n\t\t\tlong passedTime = 0;\n\t\t\twhile(response == null) {\n\t\t\t\t//看经过的时间-开始时间是否超过了指定时间\n\t\t\t\tlong waitTime = time -passedTime;\n\t\t\t\tif(waitTime <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n                   \t//等待剩余时间\n\t\t\t\t\tthis.wait(waitTime);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t//获取当前时间\n\t\t\t\tpassedTime = System.currentTimeMillis()-currentTime\t\t\n            }\n\t\t}\n\t\treturn response;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# (3)join源码——使用保护性暂停模式\n\npublic final synchronized void join(long millis)\n    throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n\n        if (millis < 0) {\n            throw new IllegalArgumentException("timeout value is negative");\n        }\n\n        if (millis == 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            while (isAlive()) {\n                long delay = millis - now;\n                if (delay <= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 8、park/unpark\n\n\n# (1)基本使用\n\npark/unpark都是LockSupport类中的的方法\n\n//暂停线程运行\nLockSupport.park;\n\n//恢复线程运行\nLockSupport.unpark(thread);\npublic static void main(String[] args) throws InterruptedException {\n\t\tThread thread = new Thread(()-> {\n\t\t\tSystem.out.println("park");\n            //暂停线程运行\n\t\t\tLockSupport.park();\n\t\t\tSystem.out.println("resume");\n\t\t}, "t1");\n\t\tthread.start();\n\n\t\tThread.sleep(1000);\n\t\tSystem.out.println("unpark");\n    \t//恢复线程运行\n\t\tLockSupport.unpark(thread);\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# (2)特点\n\n与wait/notify的区别\n\n * wait，notify 和 notifyAll 必须配合Object Monitor一起使用，而park，unpark不必\n * park ，unpark 是以线程为单位来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确\n * park & unpark 可以先 unpark，而 wait & notify 不能先 notify\n * park不会释放锁，而wait会释放锁\n\n\n# (3)原理\n\n每个线程都有一个自己的Park对象，并且该对象**_counter, _cond,__mutex**组成\n\n * 先调用park再调用unpark时\n   \n   * 先调用park\n     \n     * 线程运行时，会将Park对象中的**_counter的值设为0**；\n     * 调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中\n     * 放入阻塞队列中后，会再次将counter设置为0\n   \n   * 然后调用unpark\n     \n     * 调用unpark方法后，会将counter的值设置为1\n     \n     * 去唤醒阻塞队列cond中的线程\n     \n     * 线程继续运行并将counter的值设为0\n       \n       \n\n\n\n * 先调用unpark，再调用park\n   * 调用unpark\n     * 会将counter设置为1（运行时0）\n   * 调用park方法\n     * 查看counter是否为0\n     * 因为unpark已经把counter设置为1，所以此时将counter设置为0，但不放入阻塞队列cond中\n\n\n\n\n# 9、线程中的状态转换\n\n\n\n\n# 情况一：NEW –> RUNNABLE\n\n * 当调用了t.start()方法时，由 NEW –> RUNNABLE\n\n\n# 情况二： RUNNABLE <–> WAITING\n\n * 当调用了t 线程用 synchronized(obj) 获取了对象锁后\n   * 调用 obj.wait() 方法时，t 线程从 RUNNABLE –> WAITING\n   * 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时\n     * 竞争锁成功，t 线程从 WAITING –> RUNNABLE\n     * 竞争锁失败，t 线程从 WAITING –> BLOCKED\n\n\n# 情况三：RUNNABLE <–> WAITING\n\n * 当前线程\n   \n   调用 t.join() 方法时，当前线程从 RUNNABLE –> WAITING\n   \n   * 注意是当前线程在t 线程对象的监视器上等待\n\n * t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –> RUNNABLE\n\n\n# 情况四： RUNNABLE <–> WAITING\n\n * 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –> WAITING\n * 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –> RUNNABLE\n\n\n# 情况五： RUNNABLE <–> TIMED_WAITING\n\nt 线程用 synchronized(obj) 获取了对象锁后\n\n * 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –> TIMED_WAITING\n * t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时\n   * 竞争锁成功，t 线程从 TIMED_WAITING –> RUNNABLE\n   * 竞争锁失败，t 线程从 TIMED_WAITING –> BLOCKED\n\n\n# 情况六：RUNNABLE <–> TIMED_WAITING\n\n * 当前线程调用 t.join\n   \n   (long n\n   \n   ) 方法时，当前线程从 RUNNABLE –> TIMED_WAITING\n   \n   * 注意是当前线程在t 线程对象的监视器上等待\n\n * 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –> RUNNABLE\n\n\n# 情况七：RUNNABLE <–> TIMED_WAITING\n\n * 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –> TIMED_WAITING\n * 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –> RUNNABLE\n\n\n# 情况八：RUNNABLE <–> TIMED_WAITING\n\n * 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –> TIMED_WAITING\n * 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–> RUNNABLE\n\n\n# 情况九：RUNNABLE <–> BLOCKED\n\n * t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –> BLOCKED\n * 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它失败的线程仍然 BLOCKED\n\n\n# 情况十： RUNNABLE <–> TERMINATED\n\n当前线程所有代码运行完毕，进入 TERMINATED\n\n\n# 10、多把锁\n\n将锁的粒度细分\n\nclass BigRoom {\n    //额外创建对象来作为锁\n\tprivate final Object studyRoom = new Object();\n\tprivate final Object bedRoom = new Object();\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 11、活跃性\n\n\n# (1)定义\n\n因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性\n\n\n# (2)死锁\n\n有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁\n\n如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁\n\npublic static void main(String[] args) {\n\t\tfinal Object A = new Object();\n\t\tfinal Object B = new Object();\n\t\tnew Thread(()->{\n\t\t\tsynchronized (A) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(2000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (B) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\tnew Thread(()->{\n\t\t\tsynchronized (B) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (A) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 发生死锁的必要条件\n\n * 互斥条件\n   * 在一段时间内，一种资源只能被一个进程所使用\n * 请求和保持条件\n   * 进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源\n * 不可抢占条件\n   * 进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放\n * 循环等待条件\n   * 发生死锁时，必然存在一个进程——资源的循环链。\n\n# 定位死锁的方法\n\n * jps+jstack ThreadID\n   \n   * 在JAVA控制台中的Terminal中输入jps指令可以查看运行中的线程ID，使用jstack ThreadID可以查看线程状态。\n     \n     \n   \n   F:\\Thread_study>jps\n   20672 RemoteMavenServer36\n   22880 Jps\n   4432 Launcher\n   5316 Test5\n   20184 KotlinCompileDaemon\n   11132\n   \n   F:\\Thread_study>jstack 5316\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 打印的结果\n   \n   //找到一个java级别的死锁\n   Found one Java-level deadlock:\n   =============================\n   "Thread-1":\n     waiting to lock monitor 0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),\n     which is held by "Thread-0"\n   "Thread-0":\n     waiting to lock monitor 0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),\n     which is held by "Thread-1"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * jconsole检测死锁\n   \n   \n   \n   \n\n# 哲学家就餐问题\n\n\n\n# 避免死锁的方法\n\n在线程使用锁对象时**，顺序加锁**即可避免死锁\n\n\n\n\n# (3)活锁\n\n活锁出现在两个线程互相改变对方的结束条件，后谁也无法结束。\n\n# 避免活锁的方法\n\n在线程执行时，中途给予不同的间隔时间即可。\n\n# 死锁与活锁的区别\n\n * 死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。\n * 活锁是因为线程间修改了对方的结束条件，而导致代码一直在运行，却一直运行不完的现象。\n\n\n# (4)饥饿\n\n某些线程因为优先级太低，导致一直无法获得资源的现象。\n\n在使用顺序加锁时，可能会出现饥饿现象\n\n\n# 12、ReentrantLock\n\n和synchronized相比具有的的特点\n\n * 可中断\n * 可以设置超时时间\n * 可以设置为公平锁 (先到先得)\n * 支持多个条件变量( 具有多个waitset)\n\n基本语法\n\n//获取ReentrantLock对象\nprivate ReentrantLock lock = new ReentrantLock();\n//加锁\nlock.lock();\ntry {\n\t//需要执行的代码\n}finally {\n\t//释放锁\n\tlock.unlock();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 可重入\n\n * 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁\n * 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住\n\n# 可打断\n\n如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败\n\n简而言之就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行\n\npublic static void main(String[] args) {\n\t\tReentrantLock lock = new ReentrantLock();\n\t\tThread t1 = new Thread(()-> {\n\t\t\ttry {\n\t\t\t\t//加锁，可打断锁\n\t\t\t\tlock.lockInterruptibly();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n                //被打断，返回，不再向下执行\n\t\t\t\treturn;\n\t\t\t}finally {\n\t\t\t\t//释放锁\n\t\t\t\tlock.unlock();\n\t\t\t}\n\n\t\t});\n\n\t\tlock.lock();\n\t\ttry {\n\t\t\tt1.start();\n\t\t\tThread.sleep(1000);\n\t\t\t//打断\n\t\t\tt1.interrupt();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 锁超时\n\n使用lock.tryLock方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。\n\n并且tryLock方法可以指定等待时间，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位\n\n简而言之就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行\n\n不设置等待时间\n\npublic static void main(String[] args) {\n\t\tReentrantLock lock = new ReentrantLock();\n\t\tThread t1 = new Thread(()-> {\n            //未设置等待时间，一旦获取失败，直接返回false\n\t\t\tif(!lock.tryLock()) {\n\t\t\t\tSystem.out.println("获取失败");\n                //获取失败，不再向下执行，返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println("得到了锁");\n\t\t\tlock.unlock();\n\t\t});\n\n\n\t\tlock.lock();\n\t\ttry{\n\t\t\tt1.start();\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n设置等待时间\n\npublic static void main(String[] args) {\n\t\tReentrantLock lock = new ReentrantLock();\n\t\tThread t1 = new Thread(()-> {\n\t\t\ttry {\n\t\t\t\t//判断获取锁是否成功，最多等待1秒\n\t\t\t\tif(!lock.tryLock(1, TimeUnit.SECONDS)) {\n\t\t\t\t\tSystem.out.println("获取失败");\n\t\t\t\t\t//获取失败，不再向下执行，直接返回\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\t//被打断，不再向下执行，直接返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println("得到了锁");\n\t\t\t//释放锁\n\t\t\tlock.unlock();\n\t\t});\n\n\n\t\tlock.lock();\n\t\ttry{\n\t\t\tt1.start();\n\t\t\t//打断等待\n\t\t\tt1.interrupt();\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 公平锁\n\n在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。\n\n//默认是不公平锁，需要在创建时指定为公平锁\nReentrantLock lock = new ReentrantLock(true);\n\n\n1\n2\n\n\n# 条件变量\n\nsynchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待\n\nReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比\n\n * synchronized 是那些不满足条件的线程都在一间休息室等消息\n * 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒\n\n使用要点：\n\n * await 前需要获得锁\n * await 执行后，会释放锁，进入 conditionObject 等待\n * await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁\n * 竞争 lock 锁成功后，从 await 后继续执\n\nstatic Boolean judge = false;\npublic static void main(String[] args) throws InterruptedException {\n\tReentrantLock lock = new ReentrantLock();\n\t//获得条件变量\n\tCondition condition = lock.newCondition();\n\tnew Thread(()->{\n\t\tlock.lock();\n\t\ttry{\n\t\t\twhile(!judge) {\n\t\t\t\tSystem.out.println("不满足条件，等待...");\n\t\t\t\t//等待\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println("执行完毕！");\n\t\t\tlock.unlock();\n\t\t}\n\t}).start();\n\n\tnew Thread(()->{\n\t\tlock.lock();\n\t\ttry {\n\t\t\tThread.sleep(1);\n\t\t\tjudge = true;\n\t\t\t//释放\n\t\t\tcondition.signal();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\n\t}).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 通过Lock与AQS实现可重入锁\n\npublic class MyLock implements Lock {\n   private static class Sync extends AbstractQueuedSynchronizer {\n      @Override\n      protected boolean tryAcquire(int arg) {\n         if (getExclusiveOwnerThread() == null) {\n            if (compareAndSetState(0, 1)) {\n               setExclusiveOwnerThread(Thread.currentThread());\n               return true;\n            }\n            return false;\n         }\n\n         if (getExclusiveOwnerThread() == Thread.currentThread()) {\n            int state = getState();\n            compareAndSetState(state, state + 1);\n            return true;\n         }\n\n         return false;\n      }\n\n      @Override\n      protected boolean tryRelease(int arg) {\n         if (getState() <= 0) {\n            throw new IllegalMonitorStateException();\n         }\n\n         if (getExclusiveOwnerThread() != Thread.currentThread()) {\n            throw new IllegalMonitorStateException();\n         }\n\n         int state = getState();\n         if (state == 1) {\n            setExclusiveOwnerThread(null);\n            compareAndSetState(state, 0);\n         } else {\n            compareAndSetState(state, state - 1);\n         }\n         return true;\n      }\n\n      @Override\n      protected boolean isHeldExclusively() {\n         return getState() >= 1;\n      }\n\n      public Condition newCondition() {\n         return new ConditionObject();\n      }\n\n   }\n\n   Sync sync = new Sync();\n\n   @Override\n   public void lock() {\n      sync.acquire(1);\n   }\n\n   @Override\n   public void lockInterruptibly() throws InterruptedException {\n      sync.acquireInterruptibly(1);\n   }\n\n   @Override\n   public boolean tryLock() {\n      return sync.tryAcquire(1);\n   }\n\n   @Override\n   public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n      return sync.tryAcquireNanos(1, time);\n   }\n\n   @Override\n   public void unlock() {\n      sync.release(1);\n   }\n\n   @Override\n   public Condition newCondition() {\n      return sync.newCondition();\n   }\n}\n\nclass Main {\n   static int num = 0;\n   public static void main(String[] args) throws InterruptedException, IOException {\n      MyLock lock = new MyLock();\n\n      Object syncLock = new Object();\n\n      Thread t1 = new Thread(() -> {\n         for (int i = 0; i < 10000; i++) {\n            lock.lock();\n            try {\n               lock.lock();\n               try {\n                  lock.lock();\n                  try {\n                     num++;\n                  } finally {\n                     lock.unlock();\n                  }\n               } finally {\n                  lock.unlock();\n               }\n            } finally {\n               lock.unlock();\n            }\n         }\n      });\n\n      Thread t2 = new Thread(() -> {\n         for (int i = 0; i < 10000; i++) {\n            lock.lock();\n            try {\n               lock.lock();\n               try {\n                  lock.lock();\n                  try {\n                     num--;\n                  } finally {\n                     lock.unlock();\n                  }\n               } finally {\n                  lock.unlock();\n               }\n            } finally {\n               lock.unlock();\n            }\n         }\n      });\n\n      t1.start();\n      t2.start();\n      t1.join();\n      t2.join();\n\n      int x = 0;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n\n\n\n# 13、同步模式之顺序控制\n\n\n# Wait/Notify版本\n\nstatic final Object LOCK = new Object();\n//判断先执行的内容是否执行完毕\nstatic Boolean judge = false;\npublic static void main(String[] args) {\n\tnew Thread(()->{\n\t\tsynchronized (LOCK) {\n\t\t\twhile (!judge) {\n\t\t\t\ttry {\n\t\t\t\t\tLOCK.wait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println("2");\n\t\t}\n\t}).start();\n\n\tnew Thread(()->{\n\t\tsynchronized (LOCK) {\n\t\t\tSystem.out.println("1");\n\t\t\tjudge = true;\n               //执行完毕，唤醒所有等待线程\n\t\t\tLOCK.notifyAll();\n\t\t}\n\t}).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 交替输出\n\nwait/notify版本\n\npublic class Test4 {\n\tstatic Symbol symbol = new Symbol();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(()->{\n\t\t\tsymbol.run("a", 1, 2);\n\t\t}).start();\n\n\t\tnew Thread(()->{\n\t\t\tsymbol.run("b", 2, 3);\n\n\t\t}).start();\n\t\tsymbol.run("c", 3, 1);\n\t\tnew Thread(()->{\n\n\t\t}).start();\n\t}\n}\n\nclass Symbol {\n\tpublic synchronized void run(String str, int flag, int nextFlag) {\n\t\tfor(int i=0; i<loopNumber; i++) {\n\t\t\twhile(flag != this.flag) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.wait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(str);\n\t\t\t//设置下一个运行的线程标记\n\t\t\tthis.flag = nextFlag;\n\t\t\t//唤醒所有线程\n\t\t\tthis.notifyAll();\n\t\t}\n\t}\n\n\t/**\n\t * 线程的执行标记， 1->a 2->b 3->c\n\t */\n\tprivate int flag = 1;\n\tprivate int loopNumber = 5;\n\n\tpublic int getFlag() {\n\t\treturn flag;\n\t}\n\n\tpublic void setFlag(int flag) {\n\t\tthis.flag = flag;\n\t}\n\n\tpublic int getLoopNumber() {\n\t\treturn loopNumber;\n\t}\n\n\tpublic void setLoopNumber(int loopNumber) {\n\t\tthis.loopNumber = loopNumber;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nawait/signal版本\n\npublic class Test5 {\n\tstatic AwaitSignal awaitSignal = new AwaitSignal();\n\tstatic Condition conditionA = awaitSignal.newCondition();\n\tstatic Condition conditionB = awaitSignal.newCondition();\n\tstatic Condition conditionC = awaitSignal.newCondition();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(()->{\n\t\t\tawaitSignal.run("a", conditionA, conditionB);\n\t\t}).start();\n\n\t\tnew Thread(()->{\n\t\t\tawaitSignal.run("b", conditionB, conditionC);\n\t\t}).start();\n\n\t\tnew Thread(()->{\n\t\t\tawaitSignal.run("c", conditionC, conditionA);\n\t\t}).start();\n\n\n\t\ttry {\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tawaitSignal.lock();\n\t\ttry {\n            //唤醒一个等待的线程\n\t\t\tconditionA.signal();\n\t\t}finally {\n\t\t\tawaitSignal.unlock();\n\t\t}\n\t}\n}\n\nclass AwaitSignal extends ReentrantLock{\n\tpublic void run(String str, Condition thisCondition, Condition nextCondition) {\n\t\tfor(int i=0; i<loopNumber; i++) {\n\t\t\tlock();\n\t\t\ttry {\n                //全部进入等待状态\n\t\t\t\tthisCondition.await();\n\t\t\t\tSystem.out.print(str);\n\t\t\t\tnextCondition.signal();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\tunlock();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int loopNumber=5;\n\n\tpublic int getLoopNumber() {\n\t\treturn loopNumber;\n\t}\n\n\tpublic void setLoopNumber(int loopNumber) {\n\t\tthis.loopNumber = loopNumber;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 14、ThreadLocal\n\n\n# 简介\n\nThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题\n\n\n# 使用\n\npublic class ThreadLocalStudy {\n   public static void main(String[] args) {\n      // 创建ThreadLocal变量\n      ThreadLocal<String> stringThreadLocal = new ThreadLocal<>();\n      ThreadLocal<User> userThreadLocal = new ThreadLocal<>();\n\n      // 创建两个线程，分别使用上面的两个ThreadLocal变量\n      Thread thread1 = new Thread(()->{\n         // stringThreadLocal第一次赋值\n         stringThreadLocal.set("thread1 stringThreadLocal first");\n         // stringThreadLocal第二次赋值\n         stringThreadLocal.set("thread1 stringThreadLocal second");\n         // userThreadLocal赋值\n         userThreadLocal.set(new User("Nyima", 20));\n\n         // 取值\n         System.out.println(stringThreadLocal.get());\n         System.out.println(userThreadLocal.get());\n          \n          // 移除\n\t\t userThreadLocal.remove();\n\t\t System.out.println(userThreadLocal.get());\n      });\n\n      Thread thread2 = new Thread(()->{\n         // stringThreadLocal第一次赋值\n         stringThreadLocal.set("thread2 stringThreadLocal first");\n         // stringThreadLocal第二次赋值\n         stringThreadLocal.set("thread2 stringThreadLocal second");\n         // userThreadLocal赋值\n         userThreadLocal.set(new User("Hulu", 20));\n\n         // 取值\n         System.out.println(stringThreadLocal.get());\n         System.out.println(userThreadLocal.get());\n      });\n\n      // 启动线程\n      thread1.start();\n      thread2.start();\n   }\n}\n\nclass User {\n   String name;\n   int age;\n\n   public User(String name, int age) {\n      this.name = name;\n      this.age = age;\n   }\n\n   @Override\n   public String toString() {\n      return "User{" +\n            "name=\'" + name + \'\\\'\' +\n            ", age=" + age +\n            \'}\';\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n运行结果\n\nthread1 stringThreadLocal second\nthread2 stringThreadLocal second\nUser{name=\'Nyima\', age=20}\nUser{name=\'Hulu\', age=20}\nnull\n\n\n1\n2\n3\n4\n5\n\n\n从运行结果可以看出\n\n * 每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的\n   * 从线程1和线程2的打印结果可以看出\n * ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的\n   * stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果\n * ThreadLocal可以进行以下几个操作\n   * set 设置值\n   * get 取出值\n   * remove 移除值\n\n\n# 原理\n\n# Thread中的threadLocals\n\npublic class Thread implements Runnable {\n ...\n\n ThreadLocal.ThreadLocalMap threadLocals = null;\n\n // 放在后面说\n ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n\n ...\n}\nstatic class ThreadLocalMap {\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论\n\n# ThreadLocal中的方法\n\nset方法\n\npublic void set(T value) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    \n    // 获得ThreadLocalMap对象 \n    // 这里的get会返回Thread类中的threadLocals\n    ThreadLocalMap map = getMap(t);\n    \n    // 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入\n    if (map != null)\n        // ThreadLocal自生的引用作为key，传入的值作为value\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果未创建\n\nvoid createMap(Thread t, T firstValue) {\n    // 创建的同时设置想放入的值\n    // hreadLocal自生的引用作为key，传入的值作为value\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n\n1\n2\n3\n4\n5\n\n\nget方法\n\npublic T get() {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n\t// 获取当前线程的threadLocals变量\n    ThreadLocalMap map = getMap(t);\n    \n    // 判断threadLocals是否被初始化了\n    if (map != null) {\n        // 已经初始化则直接返回\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // 否则就创建threadLocals\n    return setInitialValue();\n}\nprivate T setInitialValue() {\n    // 这个方法返回是null\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    \n    // 无论map创建与否，最终value的值都为null\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\nprotected T initialValue() {\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nremove方法\n\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        // 如果threadLocals已经被初始化，则移除\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 总结\n\n在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值。每个线程的本地变量存放在线程自己的内存变量threadLocals中\n\n只有当前线程第一次调用ThreadLocal的set或者get方法时才会创建threadLocals（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面\n\n\n# 15、InheritableThreadLocal\n\n\n# 简介\n\n从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的\n\nThread.currentThread()\n\n\n1\n\n\n所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，它能够让父线程中ThreadLocal的值传给子线程。\n\n也就是从main所在的线程，传给thread1或thread2\n\n\n# 使用\n\npublic class Demo1 {\n   public static void main(String[] args) {\n      ThreadLocal<String> stringThreadLocal = new ThreadLocal<>();\n      InheritableThreadLocal<String> stringInheritable = new InheritableThreadLocal<>();\n\n      // 主线程赋对上面两个变量进行赋值\n      stringThreadLocal.set("this is threadLocal");\n      stringInheritable.set("this is inheritableThreadLocal");\n\n      // 创建线程\n      Thread thread1 = new Thread(()->{\n         // 获得ThreadLocal中存放的值\n         System.out.println(stringThreadLocal.get());\n\n         // 获得InheritableThreadLocal存放的值\n         System.out.println(stringInheritable.get());\n      });\n\n      thread1.start();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n运行结果\n\nnull\nthis is inheritableThreadLocal\n\n\n1\n2\n\n\n可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有\n\n\n# 原理\n\n# InheritableThreadLocal\n\npublic class InheritableThreadLocal<T> extends ThreadLocal<T> {\n    // 传入父线程中的一个值，然后直接返回\n    protected T childValue(T parentValue) {\n        return parentValue;\n    }\n\n  \t// 返回传入线程的inheritableThreadLocals\n    // Thread中有一个inheritableThreadLocals变量\n    // ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n    ThreadLocalMap getMap(Thread t) {\n       return t.inheritableThreadLocals;\n    }\n\n \t// 创建一个inheritableThreadLocals\n    void createMap(Thread t, T firstValue) {\n        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了createMap方法，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用getMap方法获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals\n\n# childValue(T parentValue)方法的调用\n\n在主函数运行时，会调用Thread的默认构造函数（创建主线程，也就是父线程），所以我们先看看Thread的默认构造函数\n\npublic Thread() {\n    init(null, null, "Thread-" + nextThreadNum(), 0);\n}\nprivate void init(ThreadGroup g, Runnable target, String name,\n                  long stackSize, AccessControlContext acc,\n                  boolean inheritThreadLocals) {\n   \t...\n        \n\t// 获得当前线程的，在这里是主线程\n    Thread parent = currentThread();\n   \n    ...\n    \n    // 如果父线程的inheritableThreadLocals存在\n    // 我们在主线程中调用set和get时，会创建inheritableThreadLocals\n    if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n        // 设置子线程的inheritableThreadLocals\n        this.inheritableThreadLocals =\n            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n    \n    /* Stash the specified stack size in case the VM cares */\n    this.stackSize = stackSize;\n\n    /* Set thread ID */\n    tid = nextThreadID();\n}\nstatic ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {\n    return new ThreadLocalMap(parentMap);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量\n\nprivate ThreadLocalMap(ThreadLocalMap parentMap) {\n    Entry[] parentTable = parentMap.table;\n    int len = parentTable.length;\n    setThreshold(len);\n    table = new Entry[len];\n\n    for (int j = 0; j < len; j++) {\n        Entry e = parentTable[j];\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();\n            if (key != null) {\n                // 这里调用了 childValue 方法\n                // 该方法会返回parent的值\n                Object value = key.childValue(e.value);\n                \n                Entry c = new Entry(key, value);\n                int h = key.threadLocalHashCode & (len - 1);\n                while (table[h] != null)\n                    h = nextIndex(h, len);\n                table[h] = c;\n                size++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中\n\n# 总结\n\nInheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。\n\n当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。\n\n\n# 四、共享模型之内存\n\n\n# 1、JAVA内存模型（JMM）\n\nJMM 即 Java Memory Model，它定义了**主存（共享内存）、工作内存（线程私有）**抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。\n\nJMM体现在以下几个方面\n\n * 原子性 - 保证指令不会受到线程上下文切换的影响\n * 可见性 - 保证指令不会受 cpu 缓存的影响\n * 有序性 - 保证指令不会受 cpu 指令并行优化的影响\n\n\n# 2、可见性\n\n# 引例\n\n退出不出的循环\n\nstatic Boolean run = true;\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tnew Thread(()->{\n\t\t\twhile (run) {\n\t\t\t\t//如果run为真，则一直执行\n\t\t\t}\n\t\t}).start();\n\n\t\tThread.sleep(1000);\n\t\tSystem.out.println("改变run的值为false");\n\t\trun = false;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为什么无法退出该循环\n\n * 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。\n\n\n\n * 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率\n\n\n\n * 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值\n\n\n\n解决方法\n\n * 使用volatile易变关键字\n * 它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存\n\n//使用易变关键字\nvolatile static Boolean run = true;\npublic static void main(String[] args) throws InterruptedException {\n\tnew Thread(()->{\n\t\twhile (run) {\n\t\t\t//如果run为真，则一直执行\n\t\t}\n\t}).start();\n\n\tThread.sleep(1000);\n\tSystem.out.println("改变run的值为false");\n\trun = false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 可见性与原子性\n\n前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况\n\n * 注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。\n\n * 但缺点是 synchronized 是属于重量级操作，性能相对更低。\n\n * 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？\n   \n   * 因为使用了synchronized关键字\n     \n     public void println(String x) {\n     \t\t//使用了synchronized关键字\n             synchronized (this) {\n                 print(x);\n                 newLine();\n             }\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n# 两阶终止模式优化\n\npublic class Test7 {\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tMonitor monitor = new Monitor();\n\t\tmonitor.start();\n\t\tThread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass Monitor {\n\n\tThread monitor;\n\t//设置标记，用于判断是否被终止了\n\tprivate volatile boolean stop = false;\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(stop) {\n\t\t\t\t\t\tSystem.out.println("处理后续任务");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tSystem.out.println("被打断了");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n        //修改标记\n\t\tstop = true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n# 同步模式之犹豫模式\n\n定义\n\nBalking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回\n\n * 用一个标记来判断该任务是否已经被执行过了\n * 需要避免线程安全问题\n   * 加锁的代码块要尽量的小，以保证性能\n\npackage com.nyima.day1;\n\n/**\n * @author Chen Panwen\n * @data 2020/3/26 16:11\n */\npublic class Test7 {\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tMonitor monitor = new Monitor();\n\t\tmonitor.start();\n\t\tmonitor.start();\n\t\tThread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass Monitor {\n\n\tThread monitor;\n\t//设置标记，用于判断是否被终止了\n\tprivate volatile boolean stop = false;\n\t//设置标记，用于判断是否已经启动过了\n\tprivate boolean starting = false;\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//上锁，避免多线程运行时出现线程安全问题\n\t\tsynchronized (this) {\n\t\t\tif (starting) {\n\t\t\t\t//已被启动，直接返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//启动监视器，改变标记\n\t\t\tstarting = true;\n\t\t}\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(stop) {\n\t\t\t\t\t\tSystem.out.println("处理后续任务");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tSystem.out.println("被打断了");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n\t\tstop = true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3、有序性\n\n\n# 指令重排\n\n * JVM 会在不影响正确性的前提下，可以调整语句的执行顺序\n\n\n\n这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。\n\n\n# 指令重排序优化\n\n * 事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这5 个阶段\n\n\n\n * 在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行\n\n * 指令重排的前提是，重排指令不能影响结果，例如\n   \n   // 可以重排的例子 \n   int a = 10; \n   int b = 20; \n   System.out.println( a + b );\n   \n   // 不能重排的例子 \n   int a = 10;\n   int b = a - 5;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 支持流水线的处理器\n\n现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。\n\n\n\n在多线程环境下，指令重排序可能导致出现意料之外的结果\n\n\n# 解决办法\n\nvolatile 修饰的变量，可以禁用指令重排\n\n * 禁止的是加volatile关键字变量之前的代码被重排序\n\n\n# 4、内存屏障\n\n * 可见性\n   * 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\n   * 读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据\n * 有序性\n   * 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n   * 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n\n\n# 5、volatile 原理\n\nvolatile的底层实现原理是内存屏障，Memory Barrier（Memory Fence）\n\n * 对 volatile 变量的写指令后会加入写屏障\n * 对 volatile 变量的读指令前会加入读屏障\n\n\n# 如何保证可见性\n\n * 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\n   \n   \n\n * 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据\n   \n   \n\n\n# 如何保证有序性\n\n * 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n   \n   \n\n * 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n   \n   \n\n\n\n但是不能解决指令交错问题\n\n * 写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去\n * 而有序性的保证也只是保证了本线程内相关代码不被重排序\n\n\n# 实现原理之Lock前缀\n\n在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时\n\ninstance = new Singleton();\n\n\n1\n\n\n对应的汇编代码是\n\n... lock addl ...\n\n\n1\n\n\n有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事\n\n * Lock前缀指令会引起处理器\n   \n   缓存回写到内存\n   \n   * Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据\n\n * 一个处理器的缓存回写到内存会\n   \n   导致其他处理器的缓存无效\n   \n   * 在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致\n\n\n# 五、共享模型之无锁\n\n\n# 1、无锁解决线程安全问题\n\n * 使用原子整数\n   \n   AtomicInteger balance = new AtomicInteger();\n   \n   \n   1\n   \n\ninterface Account {\n\tInteger getBalance();\n\n\tvoid withdraw(Integer amount);\n\n\t/**\n\t * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0\n\t */\n\tstatic void demo(Account account) {\n\t\tList<Thread> ts = new ArrayList<>();\n\t\tlong start = System.nanoTime();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tts.add(new Thread(() -> {\n\t\t\t\taccount.withdraw(10);\n\t\t\t}));\n\t\t}\n\t\tts.forEach(Thread::start);\n\t\tts.forEach(t -> {\n\t\t\ttry {\n\t\t\t\tt.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t\tlong end = System.nanoTime();\n\t\tSystem.out.println(account.getBalance() + " cost: " + (end - start) / 1000_000 + " ms");\n\t}\n}\n\n//线程不安全的做法\nclass AccountUnsafe implements Account {\n\tprivate Integer balance;\n\n\tpublic AccountUnsafe(Integer balance) {\n\t\tthis.balance = balance;\n\t}\n\n\n\t@Override\n\tpublic Integer getBalance() {\n\t\treturn this.balance;\n\t}\n\n\t@Override\n\tpublic synchronized void withdraw(Integer amount) {\n\t\tbalance -= amount;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tAccount.demo(new AccountUnsafe(10000));\n\t\tAccount.demo(new AccountCas(10000));\n\t}\n}\n\n//线程安全的做法\nclass AccountCas implements Account {\n\t//使用原子整数\n\tprivate AtomicInteger balance;\n\n\tpublic AccountCas(int balance) {\n\t\tthis.balance = new AtomicInteger(balance);\n\t}\n\n\t@Override\n\tpublic Integer getBalance() {\n\t\t//得到原子整数的值\n\t\treturn balance.get();\n\t}\n\n\t@Override\n\tpublic void withdraw(Integer amount) {\n\t\twhile(true) {\n\t\t\t//获得修改前的值\n\t\t\tint prev = balance.get();\n\t\t\t//获得修改后的值\n\t\t\tint next = prev-amount;\n\t\t\t//比较并设值\n\t\t\tif(balance.compareAndSet(prev, next)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 2、CAS与volatile\n\n前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？\n\n其中的关键是 compareAndSwap（比较并设置值），它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。\n\n\n\n\n# 工作流程\n\n * 当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。\n   * 如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。\n   * 如果两者不相等，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。\n\n注意\n\n * 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。\n * 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。\n\n\n# volatile\n\n获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。\n\n注意\n\nvolatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）\n\n\n1\n\n\nCAS 必须借助 volatile 才能读取到共享变量的新值来实现【比较并交换】的效果\n\n\n# 效率问题\n\n一般情况下，使用无锁比使用加锁的效率更高。\n\n\n\n原因\n\n\n# CAS特点\n\n结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。\n\n * CAS 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。\n\n * synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。\n\n * CAS 体现的是\n   \n   无锁并发、无阻塞并发\n   \n   ，请仔细体会这两句话的意思\n   \n   * 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一\n   * 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响\n\n\n# 3、原子整数\n\nJ.U.C 并发包提供了\n\n * AtomicBoolean\n * AtomicInteger\n * AtomicLong\n\n以 AtomicInteger 为例\n\n AtomicInteger i = new AtomicInteger(0);\n \n// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());\n \n// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());\n \n// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());\n \n// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--\nSystem.out.println(i.getAndDecrement());\n \n// 获取并加值（i = 0, 结果 i = 5, 返回 0） \nSystem.out.println(i.getAndAdd(5));\n \n// 加值并获取（i = 5, 结果 i = 0, 返回 0） \nSystem.out.println(i.addAndGet(-5));\n \n// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用 \nSystem.out.println(i.getAndUpdate(p -> p - 2));\n \n// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用 \nSystem.out.println(i.updateAndGet(p -> p + 2));\n \n// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 \n// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 \nfinal System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));\n \n// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用\nSystem.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4、原子引用\n\npublic interface DecimalAccount {\n\tBigDecimal getBalance();\n\n\tvoid withdraw(BigDecimal amount);\n\n\t/**\n\t * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    \n     * 如果初始余额为 10000 那么正确的结果应当是 0\n\t */\n\tstatic void demo(DecimalAccountImpl account) {\n\t\tList<Thread> ts = new ArrayList<>();\n\t\tlong start = System.nanoTime();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tts.add(new Thread(() -> {\n\t\t\t\taccount.withdraw(BigDecimal.TEN);\n\t\t\t}));\n\t\t}\n\t\tts.forEach(Thread::start);\n\t\tts.forEach(t -> {\n\t\t\ttry {\n\t\t\t\tt.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t\tlong end = System.nanoTime();\n\t\tSystem.out.println(account.getBalance() + " cost: " + (end - start) / 1000_000 + " ms");\n\t}\n}\n\nclass DecimalAccountImpl implements DecimalAccount {\n\t//原子引用，泛型类型为小数类型\n\tAtomicReference<BigDecimal> balance;\n\n\tpublic DecimalAccountImpl(BigDecimal balance) {\n\t\tthis.balance = new AtomicReference<BigDecimal>(balance);\n\t}\n\n\t@Override\n\tpublic BigDecimal getBalance() {\n\t\treturn balance.get();\n\t}\n\n\t@Override\n\tpublic void withdraw(BigDecimal amount) {\n\t\twhile(true) {\n\t\t\tBigDecimal pre = balance.get();\n\t\t\tBigDecimal next = pre.subtract(amount);\n\t\t\tif(balance.compareAndSet(pre, next)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDecimalAccount.demo(new DecimalAccountImpl(new BigDecimal("10000")));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 5、ABA问题\n\npublic class Demo3 {\n\tstatic AtomicReference<String> str = new AtomicReference<>("A");\n\tpublic static void main(String[] args) {\n\t\tnew Thread(() -> {\n\t\t\tString pre = str.get();\n\t\t\tSystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//把str中的A改为C\n\t\t\tSystem.out.println("change A->C " + str.compareAndSet(pre, "C"));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws InterruptedException {\n\t\tnew Thread(()-> {\n\t\t\tSystem.out.println("change A->B " + str.compareAndSet("A", "B"));\n\t\t}).start();\n\t\tThread.sleep(500);\n\t\tnew Thread(()-> {\n\t\t\tSystem.out.println("change B->A " + str.compareAndSet("B", "A"));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n主线程仅能判断出共享变量的值与初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号\n\n\n# AtomicStampedReference\n\npublic class Demo3 {\n\t//指定版本号\n\tstatic AtomicStampedReference<String> str = new AtomicStampedReference<>("A", 0);\n\tpublic static void main(String[] args) {\n\t\tnew Thread(() -> {\n\t\t\tString pre = str.getReference();\n\t\t\t//获得版本号\n\t\t\tint stamp = str.getStamp();\n\t\t\tSystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1\n\t\t\tSystem.out.println("change A->C stamp " + stamp + str.compareAndSet(pre, "C", stamp, stamp+1));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws InterruptedException {\n\t\tnew Thread(()-> {\n\t\t\tint stamp = str.getStamp();\n\t\t\tSystem.out.println("change A->B stamp " + stamp + str.compareAndSet("A", "B", stamp, stamp+1));\n\t\t}).start();\n\t\tThread.sleep(500);\n\t\tnew Thread(()-> {\n\t\t\tint stamp = str.getStamp();\n\t\t\tSystem.out.println("change B->A stamp " + stamp +  str.compareAndSet("B", "A", stamp, stamp+1));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# AtomicMarkableReference\n\nAtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -> B -> A -> C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。 但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference\n\npublic class Demo4 {\n\t//指定版本号\n\tstatic AtomicMarkableReference<String> str = new AtomicMarkableReference<>("A", true);\n\tpublic static void main(String[] args) {\n\t\tnew Thread(() -> {\n\t\t\tString pre = str.getReference();\n\t\t\tSystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1\n\t\t\tSystem.out.println("change A->C mark " +  str.compareAndSet(pre, "C", true, false));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws InterruptedException {\n\t\tnew Thread(() -> {\n\t\t\tSystem.out.println("change A->A mark " + str.compareAndSet("A", "A", true, false));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n\n\n# 两者的区别\n\n * AtomicStampedReference 需要我们传入整型变量作为版本号，来判定是否被更改过\n * AtomicMarkableReference需要我们传入布尔变量作为标记，来判断是否被更改过\n\n\n# 6、原子数组\n\n * AtomicIntegerArray\n * AtomicLongArray\n * AtomicReferenceArray\n\n\n# lamba表达式的使用\n\n * 提供者\n   * 无参又返回\n   * ()->返回结果\n * 方法\n   * 有参有返回\n   * (参数一…)->返回结果\n * 消费者\n   * 有参无返回\n   * (参数一…)->void\n\n\n# 7、原子更新器\n\n * AtomicReferenceFieldUpdater // 域 字段\n * AtomicIntegerFieldUpdater\n * AtomicLongFieldUpdate\n\n原子更新器用于帮助我们改变某个对象中的某个属性\n\npublic class Demo1 {\n   public static void main(String[] args) {\n      Student student = new Student();\n       \n      // 获得原子更新器\n      // 泛型\n      // 参数1 持有属性的类 参数2 被更新的属性的类\n      // newUpdater中的参数：第三个为属性的名称\n      AtomicReferenceFieldUpdater<Student, String> updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");\n       \n      // 修改\n      updater.compareAndSet(student, null, "Nyima");\n      System.out.println(student);\n   }\n}\n\nclass Student {\n   volatile String name;\n\n   @Override\n   public String toString() {\n      return "Student{" +\n            "name=\'" + name + \'\\\'\' +\n            \'}\';\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 原子更新器初始化过程\n\n从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数\n\n * 拥有属性的类的Class\n * 属性的Class\n * 属性的名称\n\n大概可以猜出来，初始化过程用到了反射，让我们看看源码来验证一下这个猜测。\n\n# newUpdater方法\n\npublic static <U,W> AtomicReferenceFieldUpdater<U,W> newUpdater(Class<U> tclass,\n                                                                Class<W> vclass,\n                                                                String fieldName) {\n    // 返回了一个AtomicReferenceFieldUpdaterImpl实例\n    return new AtomicReferenceFieldUpdaterImpl<U,W>\n        (tclass, vclass, fieldName, Reflection.getCallerClass());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从newUpdater方法还并不能看出来具体的初始化过程\n\n# 内部实现类\n\n\n\nAtomicReferenceFieldUpdater为抽象类，该类内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl\n\nprivate static final class AtomicReferenceFieldUpdaterImpl<T,V>\n        extends AtomicReferenceFieldUpdater<T,V>\n\n\n1\n2\n\n\n\n\n构造方法\n\nAtomicReferenceFieldUpdaterImpl(final Class<T> tclass,\n                                final Class<V> vclass,\n                                final String fieldName,\n                                final Class<?> caller) {\n    // 用于保存要被修改的属性\n    final Field field;\n    \n    // 属性的Class\n    final Class<?> fieldClass;\n    \n    // field的修饰符\n    final int modifiers;\n    try {\n        // 反射获得属性\n        field = AccessController.doPrivileged(\n            new PrivilegedExceptionAction<Field>() {\n                public Field run() throws NoSuchFieldException {\n                    // tclass为传入的属性的Class，可以通过它来获得属性\n                    return tclass.getDeclaredField(fieldName);\n                }\n            });\n        \n        // 获得属性的修饰符，主要用于判断\n        // 1、vclass 与 属性确切的类型是否匹配\n        // 2、是否为引用类型\n        // 3、被修改的属性是否加了volatile关键字\n        modifiers = field.getModifiers();\n        sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n            caller, tclass, null, modifiers);\n        ClassLoader cl = tclass.getClassLoader();\n        ClassLoader ccl = caller.getClassLoader();\n        if ((ccl != null) && (ccl != cl) &&\n            ((cl == null) || !isAncestor(cl, ccl))) {\n            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n        }\n        \n        // 获得属性类的Class\n        fieldClass = field.getType();\n    } catch (PrivilegedActionException pae) {\n        throw new RuntimeException(pae.getException());\n    } catch (Exception ex) {\n        throw new RuntimeException(ex);\n    }\n\n    if (vclass != fieldClass)\n        throw new ClassCastException();\n    if (vclass.isPrimitive())\n        throw new IllegalArgumentException("Must be reference type");\n\n    if (!Modifier.isVolatile(modifiers))\n        throw new IllegalArgumentException("Must be volatile type");\n\n    // Access to protected field members is restricted to receivers only\n    // of the accessing class, or one of its subclasses, and the\n    // accessing class must in turn be a subclass (or package sibling)\n    // of the protected member\'s defining class.\n    // If the updater refers to a protected field of a declaring class\n    // outside the current package, the receiver argument will be\n    // narrowed to the type of the accessing class.\n \t// 对类中的属性进行初始化\n    this.cclass = (Modifier.isProtected(modifiers) &&\n                   tclass.isAssignableFrom(caller) &&\n                   !isSamePackage(tclass, caller))\n                  ? caller : tclass;\n    this.tclass = tclass;\n    this.vclass = vclass;\n    // 获得偏移量\n    this.offset = U.objectFieldOffset(field);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n可以看出，原子引用更新器确实使用了反射\n\n\n# 8、LongAdder原理\n\n\n# 原理之伪共享\n\n\n\n缓存行伪共享得从缓存说起 缓存与内存的速度比较\n\n\n\n\n\n因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） 缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效\n\n\n\n因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：\n\n * Core-0 要修改 Cell[0]\n * Core-1 要修改 Cell[1]\n\n无论谁修改成功，都会导致对方 Core 的缓存行失效，\n\n比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效\n\n@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding（空白），从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效\n\n\n\n累加主要调用以下方法\n\npublic void add(long x) {\n       Cell[] as; long b, v; int m; Cell a;\n       if ((as = cells) != null || !casBase(b = base, b + x)) {\n           boolean uncontended = true;\n           if (as == null || (m = as.length - 1) < 0 ||\n               (a = as[getProbe() & m]) == null ||\n               !(uncontended = a.cas(v = a.value, v + x)))\n               longAccumulate(x, null, uncontended);\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n累加流程图\n\n\n\n\n# 9、Unsafe\n\nUnsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得\n\npublic class GetUnsafe {\n\tpublic static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\n\t\t// 通过反射获得Unsafe对象\n\t\tClass unsafeClass = Unsafe.class;\n\t\t// 获得构造函数，Unsafe的构造函数为私有的\n\t\tConstructor constructor = unsafeClass.getDeclaredConstructor();\n\t\t// 设置为允许访问私有内容\n\t\tconstructor.setAccessible(true);\n\t\t// 创建Unsafe对象\n\t\tUnsafe unsafe = (Unsafe) constructor.newInstance();\n\t\t\n\t\t// 创建Person对象\n\t\tPerson person = new Person();\n\t\t// 获得其属性 name 的偏移量\n\t\tField field = Person.class.getDeclaredField("name");\n\t\tlong offset = unsafe.objectFieldOffset(field);\n\n\t\t// 通过unsafe的CAS操作改变值\n\t\tunsafe.compareAndSwapObject(person, offset, null, "Nyima");\n\t\tSystem.out.println(person);\n\t}\n}\n\nclass Person {\n    // 配合CAS操作，必须用volatile修饰\n \tvolatile String name;\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn "Person{" +\n\t\t\t\t"name=\'" + name + \'\\\'\' +\n\t\t\t\t\'}\';\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 六、共享模型之不可变\n\n\n# 1、不可变\n\n如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。\n\n\n# 2、不可变设计\n\n# String类中不可变的体现\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n   //....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nﬁnal 的使用 * 发现该类、类中所有属性都是 *ﬁnal 的\n\n * 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改\n * 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性\n\n**保护性拷贝 **\n\n但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例\n\npublic String substring(int beginIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        int subLen = value.length - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n    \t//返回的是一个新的对象\n        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n发现其内部是调用 String 的构造方法创建了一个新字符串\n\npublic String(char value[], int offset, int count) {\n        if (offset < 0) {\n            throw new StringIndexOutOfBoundsException(offset);\n        }\n        if (count <= 0) {\n            if (count < 0) {\n                throw new StringIndexOutOfBoundsException(count);\n            }\n            if (offset <= value.length) {\n                this.value = "".value;\n                return;\n            }\n        }\n        // Note: offset or count might be near -1>>>1.\n        if (offset > value.length - count) {\n            throw new StringIndexOutOfBoundsException(offset + count);\n        }\n        this.value = Arrays.OfRange(value, offset, offset+count);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive ）】\n\n\n# 七、线程池\n\n\n# 1、自定义线程池\n\n\n# 图解\n\n\n\n * 阻塞队列中维护了由主线程（或者其他线程）所产生的的任务\n * 主线程类似于生产者，产生任务并放入阻塞队列中\n * 线程池类似于消费者，得到阻塞队列中已有的任务并执行\n\n\n# 代码\n\npublic class Demo3 {\n   public static void main(String[] args) {\n      ThreadPool threadPool = new ThreadPool(2,  TimeUnit.SECONDS, 1, 4);\n      for (int i = 0; i < 10; i++) {\n         threadPool.execute(()->{\n            try {\n               TimeUnit.SECONDS.sleep(10000);\n            } catch (InterruptedException e) {\n               e.printStackTrace();\n            }\n            System.out.println("任务正在执行!");\n         });\n      }\n   }\n}\n\n\n/**\n * 自定义线程池\n */\nclass ThreadPool {\n   /**\n    * 自定义阻塞队列\n    */\n   private BlockingQueue<Runnable> blockingQueue;\n\n   /**\n    * 核心线程数\n    */\n   private int coreSize;\n\n   private HashSet<Worker> workers = new HashSet<>();\n\n   /**\n    * 用于指定线程最大存活时间\n    */\n   private TimeUnit timeUnit;\n   private long timeout;\n\n   /**\n    * 工作线程类\n    * 内部封装了Thread类，并且添加了一些属性\n    */\n   private class Worker extends Thread {\n      Runnable task;\n\n      public Worker(Runnable task) {\n         System.out.println("初始化任务");\n         this.task = task;\n      }\n\n      @Override\n      public void run() {\n         // 如果有任务就执行\n         // 如果阻塞队列中有任务，就继续执行\n         while (task != null || (task = blockingQueue.take()) != null) {\n            try {\n               System.out.println("执行任务");\n               task.run();\n            } catch (Exception e) {\n               e.printStackTrace();\n            } finally {\n               // 任务执行完毕，设为空\n               System.out.println("任务执行完毕");\n               task = null;\n            }\n         }\n         // 移除任务\n         synchronized (workers) {\n            System.out.println("移除任务");\n            workers.remove(this);\n         }\n      }\n   }\n\n   public ThreadPool(int coreSize, TimeUnit timeUnit, long timeout, int capacity) {\n      this.coreSize = coreSize;\n      this.timeUnit = timeUnit;\n      blockingQueue = new BlockingQueue<>(capacity);\n      this.timeout = timeout;\n   }\n\n   public void execute(Runnable task) {\n      synchronized (workers) {\n         // 创建任务\n         // 池中还有空余线程时，可以运行任务\n         // 否则阻塞\n         if (workers.size() < coreSize) {\n            Worker worker = new Worker(task);\n            workers.add(worker);\n            worker.start();\n         } else {\n            System.out.println("线程池中线程已用完，请稍等");\n            blockingQueue.put(task);\n         }\n      }\n   }\n}\n\n/**\n * 阻塞队列\n * 用于存放主线程或其他线程产生的任务\n */\nclass BlockingQueue<T> {\n   /**\n    * 阻塞队列\n    */\n   private  Deque<T> blockingQueue;\n\n   /**\n    * 阻塞队列容量\n    */\n   private int capacity;\n\n   /**\n    * 锁\n    */\n   private ReentrantLock lock;\n\n   /**\n    * 条件队列\n    */\n   private Condition fullQueue;\n   private Condition emptyQueue;\n\n\n   public BlockingQueue(int capacity) {\n      blockingQueue = new ArrayDeque<>(capacity);\n      lock = new ReentrantLock();\n      fullQueue = lock.newCondition();\n      emptyQueue = lock.newCondition();\n      this.capacity = capacity;\n   }\n\n   /**\n    * 获取任务的方法\n    */\n   public T take() {\n      // 加锁\n      lock.lock();\n      try {\n         // 如果阻塞队列为空（没有任务），就一直等待\n         while (blockingQueue.isEmpty()) {\n            try {\n               emptyQueue.await();\n            } catch (InterruptedException e) {\n               e.printStackTrace();\n            }\n         }\n         // 获取任务并唤醒生产者线程\n         T task = blockingQueue.removeFirst();\n         fullQueue.signalAll();\n         return task;\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   public T takeNanos(long timeout, TimeUnit unit) {\n      // 转换等待时间\n      lock.lock();\n      try {\n         long nanos = unit.toNanos(timeout);\n         while (blockingQueue.isEmpty()) {\n            try {\n               // awaitNanos会返回剩下的等待时间\n               nanos = emptyQueue.awaitNanos(nanos);\n               if (nanos < 0) {\n                  return null;\n               }\n            } catch (InterruptedException e) {\n               e.printStackTrace();\n            }\n         }\n         T task = blockingQueue.removeFirst();\n         fullQueue.signalAll();\n         return task;\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   /**\n    * 放入任务的方法\n    * @param task 放入阻塞队列的任务\n    */\n   public void put(T task) {\n      lock.lock();\n      try {\n         while (blockingQueue.size() == capacity) {\n            try {\n               System.out.println("阻塞队列已满");\n               fullQueue.await();\n            } catch (InterruptedException e) {\n               e.printStackTrace();\n            }\n         }\n         blockingQueue.add(task);\n         // 唤醒等待的消费者\n         emptyQueue.signalAll();\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   public int getSize() {\n      lock.lock();\n      try {\n         return blockingQueue.size();\n      } finally {\n         lock.unlock();\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n\n\n实现了一个简单的线程池\n\n * 阻塞队列BlockingQueue用于暂存来不及被线程执行的任务\n   * 也可以说是平衡生产者和消费者执行速度上的差异\n   * 里面的获取任务和放入任务用到了生产者消费者模式\n * 线程池中对线程Thread进行了再次的封装，封装为了Worker\n   * 在调用任务的run方法时，线程会去执行该任务，执行完毕后还会到阻塞队列中获取新任务来执行\n * 线程池中执行任务的主要方法为execute方法\n   * 执行时要判断正在执行的线程数是否大于了线程池容量\n\n\n# 2、ThreadPoolExecutor\n\n\n# 继承关系\n\n\n\n\n# 线程池状态\n\n// 线程池状态\n// runState is stored in the high-order bits\n// RUNNING 高3位为111\nprivate static final int RUNNING    = -1 << COUNT_BITS;\n\n// SHUTDOWN 高3位为000\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\n\n// 高3位 001\nprivate static final int STOP       =  1 << COUNT_BITS;\n\n// 高3位 010\nprivate static final int TIDYING    =  2 << COUNT_BITS;\n\n// 高3位 011\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n状态名称         高3位的值   描述\nRUNNING      111     接收新任务，同时处理任务队列中的任务\nSHUTDOWN     000     不接受新任务，但是处理任务队列中的任务\nSTOP         001     中断正在执行的任务，同时抛弃阻塞队列中的任务\nTIDYING      010     任务执行完毕，活动线程为0时，即将进入终结阶段\nTERMINATED   011     终结状态\n\n线程池状态和线程池中线程的数量由一个原子整型ctl来共同表示\n\n * 使用一个数来表示两个值的主要原因是：可以通过一次CAS同时更改两个属性的值\n\n// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n// 并不是所有平台的int都是32位。\n// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量\n// 高3位为0，剩余位数全为1\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n\n// 2^COUNT_BITS次方，表示可以保存的最大线程数\n// CAPACITY 的高3位为 0\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n获取线程池状态、线程数量以及合并两个值的操作\n\n// Packing and unpacking ctl\n// 获取运行状态\n// 该操作会让除高3位以外的数全部变为0\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\n\n// 获取运行线程数\n// 该操作会让高3位为0\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\n\n// 计算ctl新值\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 线程池属性\n\n// 工作线程，内部封装了Thread\nprivate final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable {\n    ...\n}\n\n// 阻塞队列，用于存放来不及被核心线程执行的任务\nprivate final BlockingQueue<Runnable> workQueue;\n\n// 锁\nprivate final ReentrantLock mainLock = new ReentrantLock();\n\n//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 构造方法极其参数\n\nThreadPoolExecutor最全面的构造方法\n\n也是构造自定义线程池的方法\n\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 参数解释\n\n * corePoolSize：核心线程数\n * maximumPoolSize：最大线程数\n   * maximumPoolSize - corePoolSize = 救急线程数\n * keepAliveTime：救急线程空闲时的最大生存时间\n * unit：时间单位\n * workQueue：阻塞队列（存放任务）\n   * 有界阻塞队列 ArrayBlockingQueue\n   * 无界阻塞队列 LinkedBlockingQueue\n   * 最多只有一个同步元素的 SynchronousQueue\n   * 优先队列 PriorityBlockingQueue\n * threadFactory：线程工厂（给线程取名字）\n * handler：拒绝策略\n\n# 工作方式\n\n * 当一个任务传给线程池以后，可能有以下几种可能\n   * 将任务分配给一个核心线程来执行\n   * 核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行\n   * 阻塞队列满了，使用救急线程来执行任务\n     * 救急线程用完以后，超过生存时间（keepAliveTime）后会被释放\n   * 任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略\n\n# 拒绝策略\n\n如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现\n\n\n\n * AbortPolicy：让调用者抛出 RejectedExecutionException 异常，这是默认策略\n * CallerRunsPolicy：让调用者运行任务\n * DiscardPolicy：放弃本次任务\n * DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之\n\n# 使用\n\npublic class Demo1 {\n   static AtomicInteger threadId = new AtomicInteger(0);\n\n   public static void main(String[] args) {\n      // 手动创建线程池\n      // 创建有界阻塞队列\n      ArrayBlockingQueue<Runnable> runnable = new ArrayBlockingQueue<Runnable>(10);\n      // 创建线程工厂\n      ThreadFactory threadFactory = new ThreadFactory() {\n         @Override\n         public Thread newThread(Runnable r) {\n            Thread thread = new Thread(r, "working_thread_"+threadId.getAndIncrement());\n            return thread;\n         }\n      };\n\n      // 手动创建线程池\n      // 拒绝策略采用默认策略\n      ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 7, 10, TimeUnit.SECONDS, runnable, threadFactory);\n\n      for (int i = 0; i < 20; i++) {\n         executor.execute(new Runnable() {\n            @Override\n            public void run() {\n               System.out.println(Thread.currentThread());\n               try {\n                  Thread.sleep(100000);\n               } catch (InterruptedException e) {\n                  e.printStackTrace();\n               }\n            }\n         });\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# FixedThreadPool\n\npublic class TestFixedThreadPool {\n   public static void main(String[] args) {\n      // 自定义线程工厂\n      ThreadFactory factory = new ThreadFactory() {\n         AtomicInteger atomicInteger = new AtomicInteger(1);\n\n         @Override\n         public Thread newThread(Runnable r) {\n            return new Thread(r, "myThread_" + atomicInteger.getAndIncrement());\n         }\n      };\n\n      // 创建核心线程数量为2的线程池\n      // 通过 ThreadFactory可以给线程添加名字\n\n      ExecutorService executorService = Executors.newFixedThreadPool(2, factory);\n\n      // 任务\n      Runnable runnable = new Runnable() {\n         @Override\n         public void run() {\n            System.out.println(Thread.currentThread().getName());\n            System.out.println("this is fixedThreadPool");\n         }\n      };\n      \n      executorService.execute(runnable);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n固定大小的线程池可以传入两个参数\n\n * 核心线程数：nThreads\n * 线程工厂：threadFactory\n\n内部调用的构造方法\n\nThreadPoolExecutor(nThreads, nThreads,\n                              0L, TimeUnit.MILLISECONDS,\n                              new LinkedBlockingQueue<Runnable>(),\n                              threadFactory);\n\n\n1\n2\n3\n4\n\n\n\n# CachedThreadPool\n\nExecutorService executorService = Executors.newCachedThreadPool();\n\n\n1\n\n\n内部构造方法\n\nThreadPoolExecutor(0, Integer.MAX_VALUE,\n                              60L, TimeUnit.SECONDS,\n                              new SynchronousQueue<Runnable>());\n\n\n1\n2\n3\n\n\n * 没有核心线程，最大线程数为Integer.MAX_VALUE，所有创建的线程都是救急线程，空闲时生存时间为60秒\n\n * 阻塞队列使用的是SynchronousQueue\n   \n   * SynchronousQueue\n     \n     是一种特殊的队列\n     \n     * 没有容量，没有线程来取是放不进去的\n     * 只有当线程取任务时，才会将任务放入该阻塞队列中\n\n\n# SingleThread\n\nExecutorService service = Executors.newSingleThreadExecutor();\n\n\n1\n\n\n内部构造方法\n\nnew FinalizableDelegatedExecutorService\n    (new ThreadPoolExecutor(1, 1,\n                            0L, TimeUnit.MILLISECONDS,\n                            new LinkedBlockingQueue<Runnable>()));\n\n\n1\n2\n3\n4\n\n\n内部调用了new ThreadPoolExecutor的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。\n\n# 几个注意\n\n * SingleThread和自己创建一个线程来运行多个任务的区别\n   \n   * 当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。\n\n * SingleThread和newFixedThreadPool(1)的区别\n   \n   * newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数\n   \n   // 强转为ThreadPoolExecutor\n   ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);\n   // 改变核心线程数\n   threadPool.setCorePoolSize(2);\n   \n   \n   1\n   2\n   3\n   4\n   \n   * 而SingleThread无法修改核心线程数\n\n\n# 执行任务\n\n# execute()方法\n\nexecute(Runnable command)\n\n\n1\n\n\n传入一个Runnable对象，执行其中的run方法\n\n源码解析\n\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n    // 获取ctl\n    int c = ctl.get();\n    \n    // 判断当前启用的线程数是否小于核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        // 为该任务分配线程\n        if (addWorker(command, true))\n            // 分配成功就返回\n            return;\n        \n        // 分配失败再次获取ctl\n        c = ctl.get();\n    }\n    \n    // 分配和信息线程失败以后\n    // 如果池状态为RUNNING并且插入到任务队列成功\n    if (isRunning(c) && workQueue.offer(command)) {\n        \n        // 双重检测，可能在添加后线程池状态变为了非RUNNING\n        int recheck = ctl.get();\n        \n        // 如果池状态为非RUNNING，则不会执行新来的任务\n        // 将该任务从阻塞队列中移除\n        if (! isRunning(recheck) && remove(command))\n            // 调用拒绝策略，拒绝该任务的执行\n            reject(command);\n        \n        // 如果没有正在运行的线程\n        else if (workerCountOf(recheck) == 0)\n            // 就创建新线程来执行该任务\n            addWorker(null, false);\n    }\n    \n    // 如果添加失败了（任务队列已满），就调用拒绝策略\n    else if (!addWorker(command, false))\n        reject(command);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n其中调用了**addWoker()**方法，再看看看这个方法\n\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            // 创建新线程失败\n            return false;\n\n        for (;;) {\n            // 获得当前工作线程数\n            int wc = workerCountOf(c);\n\n            // 参数中 core 为true\n            // CAPACITY 为 1 << COUNT_BITS-1，一般不会超过\n            // 如果工作线程数大于了核心线程数，则创建失败\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 通过CAS操作改变c的值\n            if (compareAndIncrementWorkerCount(c))\n                // 更改成功就跳出多重循环，且不再运行循环\n                break retry;\n            // 更改失败，重新获取ctl的值\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                // 跳出多重循环，且重新进入循环\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    // 用于标记work中的任务是否成功执行\n    boolean workerStarted = false;\n    // 用于标记worker是否成功加入了线程池中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 创建新线程来执行任务\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            // 加锁\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                // 加锁的同时再次检测\n                // 避免在释放锁之前调用了shut down\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    // 将线程添加到线程池中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    // 添加成功标志位变为true\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            // 如果worker成功加入了线程池，就执行其中的任务\n            if (workerAdded) {\n                t.start();\n                // 启动成功\n                workerStarted = true;\n            }\n        }\n    } finally {\n        // 如果执行失败\n        if (! workerStarted)\n            // 调用添加失败的函数\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n# submit()方法\n\nFuture<T> submit(Callable<T> task)\n\n\n1\n\n\n传入一个Callable对象，用Future来捕获返回值\n\n使用\n\n// 通过submit执行Callable中的call方法\n// 通过Future来捕获返回值\nFuture<String> future = threadPool.submit(new Callable<String>() {\n   @Override\n   public String call() throws Exception {\n      return "hello submit";\n   }\n});\n\n// 查看捕获的返回值\nSystem.out.println(future.get());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 停止\n\n# shutdown()\n\n/**\n* 将线程池的状态改为 SHUTDOWN\n* 不再接受新任务，但是会将阻塞队列中的任务执行完\n*/\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        \n        // 修改线程池状态为 SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        \n  \t\t// 中断空闲线程（没有执行任务的线程）\n        // Idle：空闲的\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终结，不一定成功\n    // \n    tryTerminate();\n}\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 终结失败的条件\n        // 线程池状态为RUNNING\n        // 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）\n        // 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        \n        // 如果活跃线程数不为0\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            // 中断空闲线程\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 处于可以终结的状态\n            // 通过CAS将线程池状态改为TIDYING\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    terminated();\n                } finally {\n                    // 通过CAS将线程池状态改为TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n# shutdownNow()\n\n/**\n* 将线程池的状态改为 STOP\n* 不再接受新任务，也不会在执行阻塞队列中的任务\n* 会将阻塞队列中未执行的任务返回给调用者\n*/\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        \n        // 修改状态为STOP，不执行任何任务\n        advanceRunState(STOP);\n        \n        // 中断所有线程\n        interruptWorkers();\n        \n        // 将未执行的任务从队列中移除，然后返回给调用者\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终结，一定会成功，因为阻塞队列为空了\n    tryTerminate();\n    return tasks;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'本篇笔记根据\n\n黑马java并发编程教程\n\n学习而做的笔记\n\n\n# 一、基本概念\n\n\n# 1、进程与线程\n\n\n# 进程\n\n * 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 cpu，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 io 的。\n * 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\n * 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）\n\n\n# 线程\n\n * 一个进程之内可以分为一到多个线程。\n * 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 cpu 执行 。\n * java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器\n\n\n# 二者对比\n\n * 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享\n   * 进程间通信较为复杂 同一台计算机的进程通信称为 ipc（inter-process communication）\n   * 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 http\n * 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低\n\n# 进程和线程的切换\n\n上下文切换\n\n内核为每一个进程维持一个上下文。**上下文就是内核重新启动一个被抢占的进程所需的状态。**包括以下内容：\n\n * 通用目的寄存器\n * 浮点寄存器\n * 程序计数器\n * 用户栈\n * 状态寄存器\n * 内核栈\n * 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表\n\n进程切换和线程切换的主要区别\n\n最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换\n\n页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表tlb（translation lookaside buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后tlb就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致tlb失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快\n\n而且还可能出现缺页中断，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间\n\n为什么tlb能加快访问速度\n\n快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查\n\n\n# 2、并发与并行\n\n并发是一个cpu在不同的时间去不同线程中执行指令。\n\n并行是多个cpu同时处理不同的线程。\n\n引用 rob pike 的一段描述：\n\n * 并发（concurrent）是同一时间应对（dealing with）多件事情的能力\n * 并行（parallel）是同一时间动手做（doing）多件事情的能力\n\n\n# 3、应用\n\n# 应用之异步调用（案例1）\n\n以调用方角度来讲，如果\n\n * 需要等待结果返回，才能继续运行就是同步\n * 不需要等待结果返回，就能继续运行就是异步\n\n\\1) 设计 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停… \\2) 结论\n\n * 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程\n * tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞\n * tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程\n\n结论\n\n 1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活\n 2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的\n    * 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）\n    * 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义\n 3. io 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 io】，这时相当于线程虽然不用 cpu，但需要一 直等待 io 结束，没能充分利用线程。所以才有后面的【非阻塞 io】和【异步 io】优化\n\n\n# 二、线程的创建\n\n\n# 1、创建一个线程（非主线程）\n\n\n# 方法一：通过继承thread创建线程\n\npublic class createthread {\n\tpublic static void main(string[] args) {\n\t\tthread mythread = new mythread();\n        // 启动线程\n\t\tmythread.start();\n\t}\n}\n\nclass mythread extends thread {\n\t@override\n\tpublic void run() {\n\t\tsystem.out.println("my thread running...");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用thread.currentthread（）方法；不好的地方是java不支持多继承，如果继承了thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码\n\n\n# 方法二：使用runnable配合thread(推荐)\n\npublic class test2 {\n\tpublic static void main(string[] args) {\n\t\t//创建线程任务\n\t\trunnable r = new runnable() {\n\t\t\t@override\n\t\t\tpublic void run() {\n\t\t\t\tsystem.out.println("runnable running");\n\t\t\t}\n\t\t};\n\t\t//将runnable对象传给thread\n\t\tthread t = new thread(r);\n\t\t//启动线程\n\t\tt.start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n或者\n\npublic class createthread2 {\n   private static class myrunnable implements runnable {\n\n      @override\n      public void run() {\n         system.out.println("my runnable running...");\n      }\n   }\n\n   public static void main(string[] args) {\n      myrunnable myrunnable = new myrunnable();\n      thread thread = new thread(myrunnable);\n      thread.start();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过实现runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可\n\n# 方法二的简化：使用lambda表达式简化操作\n\n当一个接口带有@functionalinterface注解时，是可以使用lambda来简化操作的\n\n所以方法二中的代码可以被简化为\n\npublic class test2 {\n\tpublic static void main(string[] args) {\n\t\t//创建线程任务\n\t\trunnable r = () -> {\n            //直接写方法体即可\n\t\t\tsystem.out.println("runnable running");\n\t\t\tsystem.out.println("hello thread");\n\t\t};\n\t\t//将runnable对象传给thread\n\t\tthread t = new thread(r);\n\t\t//启动线程\n\t\tt.start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以再runnable上使用alt+enter\n\n\n\n# 原理之 thread 与 runnable 的关系\n\n分析 thread 的源码，理清它与 runnable 的关系 小结\n\n * 方法1 是把线程和任务合并在了一起\n * 方法2 是把线程和任务分开了\n * 用 runnable 更容易与线程池等高级 api 配合 用 runnable 让任务类脱离了 thread 继承体系，更灵活\n\n\n# 方法三：使用futuretask与thread结合\n\n使用futuretask可以用泛型指定线程的返回值类型（runnable的run方法没有返回值）\n\npublic class test3 {\n\tpublic static void main(string[] args) throws executionexception, interruptedexception {\n        //需要传入一个callable对象\n\t\tfuturetask<integer> task = new futuretask<integer>(new callable<integer>() {\n\t\t\t@override\n\t\t\tpublic integer call() throws exception {\n\t\t\t\tsystem.out.println("线程执行!");\n\t\t\t\tthread.sleep(1000);\n\t\t\t\treturn 100;\n\t\t\t}\n\t\t});\n\n\t\tthread r1 = new thread(task, "t2");\n\t\tr1.start();\n\t\t//获取线程中方法执行后的返回结果\n\t\tsystem.out.println(task.get());\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n或\n\npublic class usefuturetask {\n   public static void main(string[] args) throws executionexception, interruptedexception {\n      futuretask<string> futuretask = new futuretask<>(new mycall());\n      thread thread = new thread(futuretask);\n      thread.start();\n      // 获得线程运行后的返回值\n      system.out.println(futuretask.get());\n   }\n}\n\nclass mycall implements callable<string> {\n   @override\n   public string call() throws exception {\n      return "hello world";\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 总结\n\n使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是java不支持多继承，如果继承了thread类，那么子类不能再继承其他类，而runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是futuretask方式可以\n\n\n# 2、原理之线程运行\n\n# 栈与栈帧\n\njava virtual machine stacks （java 虚拟机栈） 我们都知道 jvm 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？\n\n * 其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存\n * 每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存\n * 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n\n# 线程上下文切换（thread context switch）\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码\n\n * 线程的 cpu 时间片用完\n * 垃圾回收 有更高优先级的线程需要运行\n * 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\n\n当 context switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，java 中对应的概念 就是程序计数器（program counter register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的\n\n * 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等\n * context switch 频繁发生会影响性能\n\n\n# 3、常用方法\n\n\n# (1)start() vs run()\n\n被创建的thread对象直接调用重写的run方法时， run方法是在主线程中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，需要使用thread对象的start方法。\n\n\n# (2)sleep()与yield()\n\n# sleep (使线程阻塞)\n\n 1. 调用 sleep 会让当前线程从 running 进入 timed waiting 状态（阻塞），可通过state()方法查看\n\n 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 interruptedexception\n\n 3. 睡眠结束后的线程未必会立刻得到执行\n\n 4. 建议用 timeunit 的 sleep 代替 thread 的 sleep 来获得更好的可读性 。如：\n    \n    //休眠一秒\n    timeunit.seconds.sleep(1);\n    //休眠一分钟\n    timeunit.minutes.sleep(1);\n    \n    \n    1\n    2\n    3\n    4\n    \n\n# yield （让出当前线程）\n\n 1. 调用 yield 会让当前线程从 running 进入 runnable 就绪状态（仍然有可能被执行），然后调度执行其它线程\n 2. 具体的实现依赖于操作系统的任务调度器\n\n# 线程优先级\n\n * 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它\n\n * 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用\n\n * 设置方法：\n   \n   thread1.setpriority(thread.max_priority); //设置为优先级最高\n   \n   \n   1\n   \n\n\n# (3)join()方法\n\n用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。\n\n如在主线程中调用ti.join()，则是主线程等待t1线程结束\n\nthread thread = new thread();\n//等待thread线程执行结束\nthread.join();\n//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms\nthread.join(1000);\n\n\n1\n2\n3\n4\n5\n\n\n\n# (4)interrupt()方法\n\n用于打断阻塞(sleep wait join…)的线程。 处于阻塞状态的线程，cpu不会给其分配时间片。\n\n * 如果一个线程在在运行中被打断，打断标记会被置为true。\n * 如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false\n\n//用于查看打断标记，返回值被boolean类型\nt1.isinterrupted();\n\n\n1\n2\n\n\n正常运行的线程在被打断后，不会停止，会继续执行。如果要让线程在被打断后停下来，需要使用打断标记来判断。\n\nwhile(true) {\n    if(thread.currentthread().isinterrupted()) {\n        break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# interrupt方法的应用——两阶段终止模式\n\n当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来优雅的停止线程二。\n\n\n\n代码\n\npublic class test7 {\n\tpublic static void main(string[] args) throws interruptedexception {\n\t\tmonitor monitor = new monitor();\n\t\tmonitor.start();\n\t\tthread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass monitor {\n\n\tthread monitor;\n\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new thread() {\n\t\t\t@override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n                    //判断当前线程是否被打断了\n\t\t\t\t\tif(thread.currentthread().isinterrupted()) {\n\t\t\t\t\t\tsystem.out.println("处理后续任务");\n                        //终止线程执行\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tthread.sleep(1000);\n\t\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\t\te.printstacktrace();\n\t\t\t\t\t\t//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记\n\t\t\t\t\t\tthread.currentthread().interrupt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# (5)不推荐使用的打断方法\n\n * stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）\n * suspend（暂停线程）/resume（恢复线程）方法\n\n\n# (6)守护线程\n\n当java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。\n\n//将线程设置为守护线程, 默认为false\nmonitor.setdaemon(true);\n\n\n1\n2\n\n\n守护线程的应用\n\n * 垃圾回收器线程就是一种守护线程\n * tomcat 中的 acceptor 和 poller 线程都是守护线程，所以 tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求\n\n\n# 4、线程的状态\n\n\n# (1)五种状态\n\n这是从 操作系统 层面来描述的\n\n\n\n * 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）\n * 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 cpu 调度执行\n * 【运行状态】指获取了 cpu 时间片运行中的状态\n   * 当 cpu 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换\n * 【阻塞状态】\n   * 如果调用了阻塞 api，如 bio 读写文件，这时该线程实际不会用到 cpu，会导致线程上下文切换，进入 【阻塞状态】\n   * 等 bio 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】\n   * 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们\n * 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态\n\n\n# (2)六种状态\n\n这是从 java api 层面来描述的 根据 thread.state 枚举，分为六种状态\n\n\n\n * new 线程刚被创建，但是还没有调用 start() 方法\n * runnable 当调用了 start() 方法之后，注意，java api 层面的 runnable 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 bio 导致的线程阻塞，在 java 里无法区分，仍然认为 是可运行）\n * blocked ， waiting ， timed_waiting 都是 java api 层面对【阻塞状态】的细分，如sleep就位timed_waiting， join为waiting状态。后面会在状态转换一节详述。\n * terminated 当线程代码运行结束\n\n\n# 三、共享模型之管程\n\n\n# 1、共享带来的问题\n\n\n# (1)临界区 critical section\n\n * 一个程序运行多个线程本身是没有问题的\n * 问题出在多个线程访问共享资源\n   * 多个线程读共享资源其实也没有问题\n   * 在多个线程对共享资源读写操作时发生指令交错，就会出现问题\n * 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区\n\nstatic int counter = 0;\n \nstatic void increment() \n// 临界区 \n{   \n    counter++; \n}\n \nstatic void decrement() \n// 临界区 \n{ \n    counter--; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# (2)竞态条件 race condition\n\n多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件\n\n\n# 2、synchronized 解决方案\n\n\n# (1)解决手段\n\n为了避免临界区的竞态条件发生，有多种手段可以达到目的。\n\n * 阻塞式的解决方案：synchronized，lock\n * 非阻塞式的解决方案：原子变量\n\n本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的**【对象锁】**，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换\n\n\n# (2)synchronized语法\n\nsynchronized(对象) {\n\t//临界区\n}\n\n\n1\n2\n3\n\n\n例：\n\nstatic int counter = 0; \n//创建一个公共对象，作为对象锁的对象\nstatic final object room = new object();\n \npublic static void main(string[] args) throws interruptedexception {    \n\tthread t1 = new thread(() -> {        \n    for (int i = 0; i < 5000; i++) {            \n        synchronized (room) {     \n        counter++;            \n       \t }       \n \t   }    \n    }, "t1");\n \n    thread t2 = new thread(() -> {       \n        for (int i = 0; i < 5000; i++) {         \n            synchronized (room) {            \n            counter--;          \n            }    \n        } \n    }, "t2");\n \n    t1.start();    \n    t2.start(); \n    t1.join();   \n    t2.join();    \n    log.debug("{}",counter); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# (3)synchronized加在方法上\n\n * 加在成员方法上\n   \n   public class demo {\n   \t//在方法上加上synchronized关键字\n   \tpublic synchronized void test() {\n   \t\n   \t}\n   \t//等价于\n   \tpublic void test() {\n   \t\tsynchronized(this) {\n   \t\t\n   \t\t}\n   \t}\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * 加在静态方法上\n   \n   public class demo {\n   \t//在静态方法上加上synchronized关键字\n   \tpublic synchronized static void test() {\n   \t\n   \t}\n   \t//等价于\n   \tpublic void test() {\n   \t\tsynchronized(demo.class) {\n   \t\t\n   \t\t}\n   \t}\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 3、变量的线程安全分析\n\n# 成员变量和静态变量是否线程安全？\n\n * 如果它们没有共享，则线程安全\n * 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况\n   * 如果只有读操作，则线程安全\n   * 如果有读写操作，则这段代码是临界区，需要考虑线程安全\n\n# 局部变量是否线程安全？\n\n * 局部变量是线程安全的\n\n * 但局部变量引用的对象则未必 （要看该对象\n   \n   是否被共享\n   \n   且被执行了读写操作）\n   \n   * 如果该对象没有逃离方法的作用范围，它是线程安全的\n   * 如果该对象逃离方法的作用范围，需要考虑线程安全\n\n * 局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享\n\n\n\n * 如果调用的对象被共享，且执行了读写操作，则线程不安全\n\n\n\n * 如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。\n\n\n\n\n# 常见线程安全类\n\n * string\n * integer\n * stringbuﬀer\n * random\n * vector （list的线程安全实现类）\n * hashtable （hash的线程安全实现类）\n * java.util.concurrent 包下的类\n\n这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的\n\n * 它们的每个方法是原子的（都被加上了synchronized）\n * 但注意它们多个方法的组合不是原子的，所以可能会出现线程安全问题\n\n\n\n\n# 不可变类线程安全性\n\nstring、integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的\n\n有同学或许有疑问，string 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？\n\n这是因为这些方法的返回值都创建了一个新的对象，而不是直接改变string、integer对象本身。\n\n\n# 4、monitor概念\n\n\n# (1)原理之monitor\n\n\n\n * 当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)是否绑定了monitor。\n   \n   * 如果没有绑定，则会先去去与monitor绑定，并且将owner设为当前线程。\n   \n   * 如果\n     \n     已经绑定\n     \n     ，则会去查询该monitor是否已经有了owner\n     \n     * 如果没有，则owner与将当前线程绑定\n     * 如果有，则放入entrylist，进入阻塞状态(blocked)\n\n * 当monitor的owner将临界区中代码执行完毕后，owner便会被清空，此时entrylist中处于阻塞状态的线程会被叫醒并竞争，此时的竞争是非公平的\n\n * 注意：\n   \n   * 对象在使用了synchronized后与monitor绑定时，会将对象头中的mark word置为monitor指针。\n   * 每个对象都会绑定一个唯一的monitor，如果synchronized中所指定的对象(obj)不同，则会绑定不同的monitor\n\n\n# 5、synchronized原理进阶\n\n\n# 对象头格式\n\n\n\n\n# (1)轻量级锁（用于优化monitor这类的重量级锁）\n\n轻量级锁使用场景：当一个对象被多个线程所访问，但访问的时间是错开的（不存在竞争），此时就可以使用轻量级锁来优化。\n\n * 创建锁记录（lock record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用monitor）\n   \n   \n\n * 让锁记录中的object reference指向锁对象（object），并尝试用cas去替换object中的mark word，将此mark word放入lock record中保存\n\n\n\n * 如果cas替换成功，则将object的对象头替换为锁记录的地址和状态 00（轻量级锁状态），并由该线程给对象加锁\n\n\n\n\n# (2)锁膨胀\n\n * 如果一个线程在给一个对象加轻量级锁时，cas替换操作失败（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入锁膨胀过程\n\n\n\n * 此时便会给对象加上重量级锁（使用monitor）\n   \n   * 将对象头的mark word改为monitor的地址，并且状态改为01(重量级锁)\n   \n   * 并且该线程放入入entrylist中，并进入阻塞状态(blocked)\n     \n     \n\n\n# (3)自旋优化\n\n重量级锁竞争时，还可以使用自选来优化，如果当前线程在自旋成功（使用锁的线程退出了同步块，释放了锁），这时就可以避免线程进入阻塞状态。\n\n * 第一种情况\n\n\n\n * 第二种情况\n\n\n\n\n# (4)偏向锁(用于优化轻量级锁重入)\n\n轻量级锁在没有竞争时，每次重入（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。\n\n所以引入了偏向锁对性能进行优化：在第一次cas时会将线程的id写入对象的mark word中。此后发现这个线程id就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。\n\n\n\n# 偏向状态\n\n * normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）\n * biased：偏向状态，使用偏向锁，前面54位保存的当前线程的id，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）\n * lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后两位为状态（00）\n * heavyweight：使用重量级锁，前62位保存的是monitor的地址指针，后两位为状态(10)\n\n\n\n * 如果开启了偏向锁（默认开启），在创建对象时，对象的mark word后三位应该是101\n * 但是偏向锁默认是有延迟的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态\n * 如果没有开启偏向锁，对象的mark word后三位应该是001\n\n# 撤销偏向\n\n以下几种情况会使对象的偏向锁失效\n\n * 调用对象的hashcode方法\n * 多个线程使用该对象\n * 调用了wait/notify方法（调用wait方法会导致锁膨胀而使用重量级锁）\n\n\n# (5)批量重偏向\n\n * 如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向t1的对象仍有机会重新偏向t2\n   * 重偏向会重置thread id\n * 当撤销超过20次后（超过阈值），jvm会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。\n\n\n# (6)批量撤销\n\n当撤销偏向锁的阈值超过40以后，就会将整个类的对象都改为不可偏向的\n\n\n# 6、wait/notify\n\n\n# (1)原理\n\n\n\n * 锁对象调用wait方法（obj.wait），就会使当前线程进入waitset中，变为waiting状态。\n\n * 处于blocked和waiting状态的线程都为\n   \n   阻塞\n   \n   状态，cpu都不会分给他们时间片。但是有所区别：\n   \n   * blocked状态的线程是在竞争对象时，发现monitor的owner已经是别的线程了，此时就会进入entrylist中，并处于blocked状态\n   * waiting状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了waitset中，处于waiting状态\n\n * blocked状态的线程会在锁被释放的时候被唤醒，但是处于waiting状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyall)，才会被唤醒。\n\n注：只有当对象被锁以后，才能调用wait和notify方法\n\npublic class test1 {\n\tfinal static object lock = new object();\n\tpublic static void main(string[] args) throws interruptedexception {\n        //只有在对象被锁住后才能调用wait方法\n\t\tsynchronized (lock) {\n\t\t\tlock.wait();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# (2)wait与sleep的区别\n\n不同点\n\n * sleep是thread类的静态方法，wait是object的方法，object又是所有类的父类，所以所有类都有wait方法。\n * sleep在阻塞的时候不会释放锁，而wait在阻塞的时候会释放锁\n * sleep不需要与synchronized一起使用，而wait需要与synchronized一起使用（对象被锁以后才能使用）\n\n相同点\n\n * 阻塞状态都为timed_waiting\n\n\n# (3)优雅地使用wait/notify\n\n什么时候适合使用wait\n\n * 当线程不满足某些条件，需要暂停运行时，可以使用wait。这样会将对象的锁释放，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。\n\n使用wait/notify需要注意什么\n\n * 当有多个线程在运行时，对象调用了wait方法，此时这些线程都会进入waitset中等待。如果这时使用了notify方法，可能会造成虚假唤醒（唤醒的不是满足条件的等待线程），这时就需要使用notifyall方法\n\nsynchronized (lock) {\n\twhile(//不满足条件，一直等待，避免虚假唤醒) {\n\t\tlock.wait();\n\t}\n\t//满足条件后再运行\n}\n\nsynchronized (lock) {\n\t//唤醒所有等待线程\n\tlock.notifyall();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7、模式之保护性暂停\n\n\n# (1)定义\n\n\n\n\n# (2)举例\n\npublic class test2 {\n\tpublic static void main(string[] args) {\n\t\tstring hello = "hello thread!";\n\t\tguarded guarded = new guarded();\n\t\tnew thread(()->{\n\t\t\tsystem.out.println("想要得到结果");\n\t\t\tsynchronized (guarded) {\n\t\t\t\tsystem.out.println("结果是："+guarded.getresponse());\n\t\t\t}\n\t\t\tsystem.out.println("得到结果");\n\t\t}).start();\n\n\t\tnew thread(()->{\n\t\t\tsystem.out.println("设置结果");\n\t\t\tsynchronized (guarded) {\n\t\t\t\tguarded.setresponse(hello);\n\t\t\t}\n\t\t}).start();\n\t}\n}\n\nclass guarded {\n\t/**\n\t * 要返回的结果\n\t */\n\tprivate object response;\n\t\n    //优雅地使用wait/notify\n\tpublic object getresponse() {\n\t\t//如果返回结果为空就一直等待，避免虚假唤醒\n\t\twhile(response == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.wait();\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn response;\n\t}\n\n\tpublic void setresponse(object response) {\n\t\tthis.response = response;\n\t\tsynchronized (this) {\n\t\t\t//唤醒休眠的线程\n\t\t\tthis.notifyall();\n\t\t}\n\t}\n\n\t@override\n\tpublic string tostring() {\n\t\treturn "guarded{" +\n\t\t\t\t"response=" + response +\n\t\t\t\t\'}\';\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n带超时判断的暂停\n\npublic object getresponse(long time) {\n\t\tsynchronized (this) {\n\t\t\t//获取开始时间\n\t\t\tlong currenttime = system.currenttimemillis();\n\t\t\t//用于保存已经等待了的时间\n\t\t\tlong passedtime = 0;\n\t\t\twhile(response == null) {\n\t\t\t\t//看经过的时间-开始时间是否超过了指定时间\n\t\t\t\tlong waittime = time -passedtime;\n\t\t\t\tif(waittime <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n                   \t//等待剩余时间\n\t\t\t\t\tthis.wait(waittime);\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t\t//获取当前时间\n\t\t\t\tpassedtime = system.currenttimemillis()-currenttime\t\t\n            }\n\t\t}\n\t\treturn response;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# (3)join源码——使用保护性暂停模式\n\npublic final synchronized void join(long millis)\n    throws interruptedexception {\n        long base = system.currenttimemillis();\n        long now = 0;\n\n        if (millis < 0) {\n            throw new illegalargumentexception("timeout value is negative");\n        }\n\n        if (millis == 0) {\n            while (isalive()) {\n                wait(0);\n            }\n        } else {\n            while (isalive()) {\n                long delay = millis - now;\n                if (delay <= 0) {\n                    break;\n                }\n                wait(delay);\n                now = system.currenttimemillis() - base;\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 8、park/unpark\n\n\n# (1)基本使用\n\npark/unpark都是locksupport类中的的方法\n\n//暂停线程运行\nlocksupport.park;\n\n//恢复线程运行\nlocksupport.unpark(thread);\npublic static void main(string[] args) throws interruptedexception {\n\t\tthread thread = new thread(()-> {\n\t\t\tsystem.out.println("park");\n            //暂停线程运行\n\t\t\tlocksupport.park();\n\t\t\tsystem.out.println("resume");\n\t\t}, "t1");\n\t\tthread.start();\n\n\t\tthread.sleep(1000);\n\t\tsystem.out.println("unpark");\n    \t//恢复线程运行\n\t\tlocksupport.unpark(thread);\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# (2)特点\n\n与wait/notify的区别\n\n * wait，notify 和 notifyall 必须配合object monitor一起使用，而park，unpark不必\n * park ，unpark 是以线程为单位来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyall 是唤醒所有等待线程，就不那么精确\n * park & unpark 可以先 unpark，而 wait & notify 不能先 notify\n * park不会释放锁，而wait会释放锁\n\n\n# (3)原理\n\n每个线程都有一个自己的park对象，并且该对象**_counter, _cond,__mutex**组成\n\n * 先调用park再调用unpark时\n   \n   * 先调用park\n     \n     * 线程运行时，会将park对象中的**_counter的值设为0**；\n     * 调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中\n     * 放入阻塞队列中后，会再次将counter设置为0\n   \n   * 然后调用unpark\n     \n     * 调用unpark方法后，会将counter的值设置为1\n     \n     * 去唤醒阻塞队列cond中的线程\n     \n     * 线程继续运行并将counter的值设为0\n       \n       \n\n\n\n * 先调用unpark，再调用park\n   * 调用unpark\n     * 会将counter设置为1（运行时0）\n   * 调用park方法\n     * 查看counter是否为0\n     * 因为unpark已经把counter设置为1，所以此时将counter设置为0，但不放入阻塞队列cond中\n\n\n\n\n# 9、线程中的状态转换\n\n\n\n\n# 情况一：new –> runnable\n\n * 当调用了t.start()方法时，由 new –> runnable\n\n\n# 情况二： runnable <–> waiting\n\n * 当调用了t 线程用 synchronized(obj) 获取了对象锁后\n   * 调用 obj.wait() 方法时，t 线程从 runnable –> waiting\n   * 调用 obj.notify() ， obj.notifyall() ， t.interrupt() 时\n     * 竞争锁成功，t 线程从 waiting –> runnable\n     * 竞争锁失败，t 线程从 waiting –> blocked\n\n\n# 情况三：runnable <–> waiting\n\n * 当前线程\n   \n   调用 t.join() 方法时，当前线程从 runnable –> waiting\n   \n   * 注意是当前线程在t 线程对象的监视器上等待\n\n * t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 waiting –> runnable\n\n\n# 情况四： runnable <–> waiting\n\n * 当前线程调用 locksupport.park() 方法会让当前线程从 runnable –> waiting\n * 调用 locksupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 waiting –> runnable\n\n\n# 情况五： runnable <–> timed_waiting\n\nt 线程用 synchronized(obj) 获取了对象锁后\n\n * 调用 obj.wait(long n) 方法时，t 线程从 runnable –> timed_waiting\n * t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyall() ， t.interrupt() 时\n   * 竞争锁成功，t 线程从 timed_waiting –> runnable\n   * 竞争锁失败，t 线程从 timed_waiting –> blocked\n\n\n# 情况六：runnable <–> timed_waiting\n\n * 当前线程调用 t.join\n   \n   (long n\n   \n   ) 方法时，当前线程从 runnable –> timed_waiting\n   \n   * 注意是当前线程在t 线程对象的监视器上等待\n\n * 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 timed_waiting –> runnable\n\n\n# 情况七：runnable <–> timed_waiting\n\n * 当前线程调用 thread.sleep(long n) ，当前线程从 runnable –> timed_waiting\n * 当前线程等待时间超过了 n 毫秒，当前线程从 timed_waiting –> runnable\n\n\n# 情况八：runnable <–> timed_waiting\n\n * 当前线程调用 locksupport.parknanos(long nanos) 或 locksupport.parkuntil(long millis) 时，当前线 程从 runnable –> timed_waiting\n * 调用 locksupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 timed_waiting–> runnable\n\n\n# 情况九：runnable <–> blocked\n\n * t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 runnable –> blocked\n * 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 blocked 的线程重新竞争，如果其中 t 线程竞争 成功，从 blocked –> runnable ，其它失败的线程仍然 blocked\n\n\n# 情况十： runnable <–> terminated\n\n当前线程所有代码运行完毕，进入 terminated\n\n\n# 10、多把锁\n\n将锁的粒度细分\n\nclass bigroom {\n    //额外创建对象来作为锁\n\tprivate final object studyroom = new object();\n\tprivate final object bedroom = new object();\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 11、活跃性\n\n\n# (1)定义\n\n因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性\n\n\n# (2)死锁\n\n有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁\n\n如：t1线程获得a对象 锁，接下来想获取b对象的锁t2线程获得b对象锁，接下来想获取a对象的锁\n\npublic static void main(string[] args) {\n\t\tfinal object a = new object();\n\t\tfinal object b = new object();\n\t\tnew thread(()->{\n\t\t\tsynchronized (a) {\n\t\t\t\ttry {\n\t\t\t\t\tthread.sleep(2000);\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (b) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\tnew thread(()->{\n\t\t\tsynchronized (b) {\n\t\t\t\ttry {\n\t\t\t\t\tthread.sleep(1000);\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (a) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 发生死锁的必要条件\n\n * 互斥条件\n   * 在一段时间内，一种资源只能被一个进程所使用\n * 请求和保持条件\n   * 进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源\n * 不可抢占条件\n   * 进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放\n * 循环等待条件\n   * 发生死锁时，必然存在一个进程——资源的循环链。\n\n# 定位死锁的方法\n\n * jps+jstack threadid\n   \n   * 在java控制台中的terminal中输入jps指令可以查看运行中的线程id，使用jstack threadid可以查看线程状态。\n     \n     \n   \n   f:\\thread_study>jps\n   20672 remotemavenserver36\n   22880 jps\n   4432 launcher\n   5316 test5\n   20184 kotlincompiledaemon\n   11132\n   \n   f:\\thread_study>jstack 5316\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 打印的结果\n   \n   //找到一个java级别的死锁\n   found one java-level deadlock:\n   =============================\n   "thread-1":\n     waiting to lock monitor 0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.object),\n     which is held by "thread-0"\n   "thread-0":\n     waiting to lock monitor 0x0000000017f43678 (object 0x00000000d6188890, a java.lang.object),\n     which is held by "thread-1"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * jconsole检测死锁\n   \n   \n   \n   \n\n# 哲学家就餐问题\n\n\n\n# 避免死锁的方法\n\n在线程使用锁对象时**，顺序加锁**即可避免死锁\n\n\n\n\n# (3)活锁\n\n活锁出现在两个线程互相改变对方的结束条件，后谁也无法结束。\n\n# 避免活锁的方法\n\n在线程执行时，中途给予不同的间隔时间即可。\n\n# 死锁与活锁的区别\n\n * 死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。\n * 活锁是因为线程间修改了对方的结束条件，而导致代码一直在运行，却一直运行不完的现象。\n\n\n# (4)饥饿\n\n某些线程因为优先级太低，导致一直无法获得资源的现象。\n\n在使用顺序加锁时，可能会出现饥饿现象\n\n\n# 12、reentrantlock\n\n和synchronized相比具有的的特点\n\n * 可中断\n * 可以设置超时时间\n * 可以设置为公平锁 (先到先得)\n * 支持多个条件变量( 具有多个waitset)\n\n基本语法\n\n//获取reentrantlock对象\nprivate reentrantlock lock = new reentrantlock();\n//加锁\nlock.lock();\ntry {\n\t//需要执行的代码\n}finally {\n\t//释放锁\n\tlock.unlock();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 可重入\n\n * 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁\n * 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住\n\n# 可打断\n\n如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败\n\n简而言之就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行\n\npublic static void main(string[] args) {\n\t\treentrantlock lock = new reentrantlock();\n\t\tthread t1 = new thread(()-> {\n\t\t\ttry {\n\t\t\t\t//加锁，可打断锁\n\t\t\t\tlock.lockinterruptibly();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n                //被打断，返回，不再向下执行\n\t\t\t\treturn;\n\t\t\t}finally {\n\t\t\t\t//释放锁\n\t\t\t\tlock.unlock();\n\t\t\t}\n\n\t\t});\n\n\t\tlock.lock();\n\t\ttry {\n\t\t\tt1.start();\n\t\t\tthread.sleep(1000);\n\t\t\t//打断\n\t\t\tt1.interrupt();\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 锁超时\n\n使用lock.trylock方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。\n\n并且trylock方法可以指定等待时间，参数为：trylock(long timeout, timeunit unit), 其中timeout为最长等待时间，timeunit为时间单位\n\n简而言之就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行\n\n不设置等待时间\n\npublic static void main(string[] args) {\n\t\treentrantlock lock = new reentrantlock();\n\t\tthread t1 = new thread(()-> {\n            //未设置等待时间，一旦获取失败，直接返回false\n\t\t\tif(!lock.trylock()) {\n\t\t\t\tsystem.out.println("获取失败");\n                //获取失败，不再向下执行，返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsystem.out.println("得到了锁");\n\t\t\tlock.unlock();\n\t\t});\n\n\n\t\tlock.lock();\n\t\ttry{\n\t\t\tt1.start();\n\t\t\tthread.sleep(3000);\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n设置等待时间\n\npublic static void main(string[] args) {\n\t\treentrantlock lock = new reentrantlock();\n\t\tthread t1 = new thread(()-> {\n\t\t\ttry {\n\t\t\t\t//判断获取锁是否成功，最多等待1秒\n\t\t\t\tif(!lock.trylock(1, timeunit.seconds)) {\n\t\t\t\t\tsystem.out.println("获取失败");\n\t\t\t\t\t//获取失败，不再向下执行，直接返回\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t\t//被打断，不再向下执行，直接返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsystem.out.println("得到了锁");\n\t\t\t//释放锁\n\t\t\tlock.unlock();\n\t\t});\n\n\n\t\tlock.lock();\n\t\ttry{\n\t\t\tt1.start();\n\t\t\t//打断等待\n\t\t\tt1.interrupt();\n\t\t\tthread.sleep(3000);\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n# 公平锁\n\n在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。\n\n//默认是不公平锁，需要在创建时指定为公平锁\nreentrantlock lock = new reentrantlock(true);\n\n\n1\n2\n\n\n# 条件变量\n\nsynchronized 中也有条件变量，就是我们讲原理时那个 waitset 休息室，当条件不满足时进入waitset 等待\n\nreentrantlock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比\n\n * synchronized 是那些不满足条件的线程都在一间休息室等消息\n * 而 reentrantlock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒\n\n使用要点：\n\n * await 前需要获得锁\n * await 执行后，会释放锁，进入 conditionobject 等待\n * await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁\n * 竞争 lock 锁成功后，从 await 后继续执\n\nstatic boolean judge = false;\npublic static void main(string[] args) throws interruptedexception {\n\treentrantlock lock = new reentrantlock();\n\t//获得条件变量\n\tcondition condition = lock.newcondition();\n\tnew thread(()->{\n\t\tlock.lock();\n\t\ttry{\n\t\t\twhile(!judge) {\n\t\t\t\tsystem.out.println("不满足条件，等待...");\n\t\t\t\t//等待\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t} finally {\n\t\t\tsystem.out.println("执行完毕！");\n\t\t\tlock.unlock();\n\t\t}\n\t}).start();\n\n\tnew thread(()->{\n\t\tlock.lock();\n\t\ttry {\n\t\t\tthread.sleep(1);\n\t\t\tjudge = true;\n\t\t\t//释放\n\t\t\tcondition.signal();\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\n\t}).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 通过lock与aqs实现可重入锁\n\npublic class mylock implements lock {\n   private static class sync extends abstractqueuedsynchronizer {\n      @override\n      protected boolean tryacquire(int arg) {\n         if (getexclusiveownerthread() == null) {\n            if (compareandsetstate(0, 1)) {\n               setexclusiveownerthread(thread.currentthread());\n               return true;\n            }\n            return false;\n         }\n\n         if (getexclusiveownerthread() == thread.currentthread()) {\n            int state = getstate();\n            compareandsetstate(state, state + 1);\n            return true;\n         }\n\n         return false;\n      }\n\n      @override\n      protected boolean tryrelease(int arg) {\n         if (getstate() <= 0) {\n            throw new illegalmonitorstateexception();\n         }\n\n         if (getexclusiveownerthread() != thread.currentthread()) {\n            throw new illegalmonitorstateexception();\n         }\n\n         int state = getstate();\n         if (state == 1) {\n            setexclusiveownerthread(null);\n            compareandsetstate(state, 0);\n         } else {\n            compareandsetstate(state, state - 1);\n         }\n         return true;\n      }\n\n      @override\n      protected boolean isheldexclusively() {\n         return getstate() >= 1;\n      }\n\n      public condition newcondition() {\n         return new conditionobject();\n      }\n\n   }\n\n   sync sync = new sync();\n\n   @override\n   public void lock() {\n      sync.acquire(1);\n   }\n\n   @override\n   public void lockinterruptibly() throws interruptedexception {\n      sync.acquireinterruptibly(1);\n   }\n\n   @override\n   public boolean trylock() {\n      return sync.tryacquire(1);\n   }\n\n   @override\n   public boolean trylock(long time, timeunit unit) throws interruptedexception {\n      return sync.tryacquirenanos(1, time);\n   }\n\n   @override\n   public void unlock() {\n      sync.release(1);\n   }\n\n   @override\n   public condition newcondition() {\n      return sync.newcondition();\n   }\n}\n\nclass main {\n   static int num = 0;\n   public static void main(string[] args) throws interruptedexception, ioexception {\n      mylock lock = new mylock();\n\n      object synclock = new object();\n\n      thread t1 = new thread(() -> {\n         for (int i = 0; i < 10000; i++) {\n            lock.lock();\n            try {\n               lock.lock();\n               try {\n                  lock.lock();\n                  try {\n                     num++;\n                  } finally {\n                     lock.unlock();\n                  }\n               } finally {\n                  lock.unlock();\n               }\n            } finally {\n               lock.unlock();\n            }\n         }\n      });\n\n      thread t2 = new thread(() -> {\n         for (int i = 0; i < 10000; i++) {\n            lock.lock();\n            try {\n               lock.lock();\n               try {\n                  lock.lock();\n                  try {\n                     num--;\n                  } finally {\n                     lock.unlock();\n                  }\n               } finally {\n                  lock.unlock();\n               }\n            } finally {\n               lock.unlock();\n            }\n         }\n      });\n\n      t1.start();\n      t2.start();\n      t1.join();\n      t2.join();\n\n      int x = 0;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n\n\n\n# 13、同步模式之顺序控制\n\n\n# wait/notify版本\n\nstatic final object lock = new object();\n//判断先执行的内容是否执行完毕\nstatic boolean judge = false;\npublic static void main(string[] args) {\n\tnew thread(()->{\n\t\tsynchronized (lock) {\n\t\t\twhile (!judge) {\n\t\t\t\ttry {\n\t\t\t\t\tlock.wait();\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsystem.out.println("2");\n\t\t}\n\t}).start();\n\n\tnew thread(()->{\n\t\tsynchronized (lock) {\n\t\t\tsystem.out.println("1");\n\t\t\tjudge = true;\n               //执行完毕，唤醒所有等待线程\n\t\t\tlock.notifyall();\n\t\t}\n\t}).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 交替输出\n\nwait/notify版本\n\npublic class test4 {\n\tstatic symbol symbol = new symbol();\n\tpublic static void main(string[] args) {\n\t\tnew thread(()->{\n\t\t\tsymbol.run("a", 1, 2);\n\t\t}).start();\n\n\t\tnew thread(()->{\n\t\t\tsymbol.run("b", 2, 3);\n\n\t\t}).start();\n\t\tsymbol.run("c", 3, 1);\n\t\tnew thread(()->{\n\n\t\t}).start();\n\t}\n}\n\nclass symbol {\n\tpublic synchronized void run(string str, int flag, int nextflag) {\n\t\tfor(int i=0; i<loopnumber; i++) {\n\t\t\twhile(flag != this.flag) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.wait();\n\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\te.printstacktrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsystem.out.println(str);\n\t\t\t//设置下一个运行的线程标记\n\t\t\tthis.flag = nextflag;\n\t\t\t//唤醒所有线程\n\t\t\tthis.notifyall();\n\t\t}\n\t}\n\n\t/**\n\t * 线程的执行标记， 1->a 2->b 3->c\n\t */\n\tprivate int flag = 1;\n\tprivate int loopnumber = 5;\n\n\tpublic int getflag() {\n\t\treturn flag;\n\t}\n\n\tpublic void setflag(int flag) {\n\t\tthis.flag = flag;\n\t}\n\n\tpublic int getloopnumber() {\n\t\treturn loopnumber;\n\t}\n\n\tpublic void setloopnumber(int loopnumber) {\n\t\tthis.loopnumber = loopnumber;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nawait/signal版本\n\npublic class test5 {\n\tstatic awaitsignal awaitsignal = new awaitsignal();\n\tstatic condition conditiona = awaitsignal.newcondition();\n\tstatic condition conditionb = awaitsignal.newcondition();\n\tstatic condition conditionc = awaitsignal.newcondition();\n\tpublic static void main(string[] args) {\n\t\tnew thread(()->{\n\t\t\tawaitsignal.run("a", conditiona, conditionb);\n\t\t}).start();\n\n\t\tnew thread(()->{\n\t\t\tawaitsignal.run("b", conditionb, conditionc);\n\t\t}).start();\n\n\t\tnew thread(()->{\n\t\t\tawaitsignal.run("c", conditionc, conditiona);\n\t\t}).start();\n\n\n\t\ttry {\n\t\t\tthread.sleep(1000);\n\t\t} catch (interruptedexception e) {\n\t\t\te.printstacktrace();\n\t\t}\n\t\tawaitsignal.lock();\n\t\ttry {\n            //唤醒一个等待的线程\n\t\t\tconditiona.signal();\n\t\t}finally {\n\t\t\tawaitsignal.unlock();\n\t\t}\n\t}\n}\n\nclass awaitsignal extends reentrantlock{\n\tpublic void run(string str, condition thiscondition, condition nextcondition) {\n\t\tfor(int i=0; i<loopnumber; i++) {\n\t\t\tlock();\n\t\t\ttry {\n                //全部进入等待状态\n\t\t\t\tthiscondition.await();\n\t\t\t\tsystem.out.print(str);\n\t\t\t\tnextcondition.signal();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t} finally {\n\t\t\t\tunlock();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int loopnumber=5;\n\n\tpublic int getloopnumber() {\n\t\treturn loopnumber;\n\t}\n\n\tpublic void setloopnumber(int loopnumber) {\n\t\tthis.loopnumber = loopnumber;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 14、threadlocal\n\n\n# 简介\n\nthreadlocal是jdk包提供的，它提供了线程本地变量，也就是如果你创建了一个threadlocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题\n\n\n# 使用\n\npublic class threadlocalstudy {\n   public static void main(string[] args) {\n      // 创建threadlocal变量\n      threadlocal<string> stringthreadlocal = new threadlocal<>();\n      threadlocal<user> userthreadlocal = new threadlocal<>();\n\n      // 创建两个线程，分别使用上面的两个threadlocal变量\n      thread thread1 = new thread(()->{\n         // stringthreadlocal第一次赋值\n         stringthreadlocal.set("thread1 stringthreadlocal first");\n         // stringthreadlocal第二次赋值\n         stringthreadlocal.set("thread1 stringthreadlocal second");\n         // userthreadlocal赋值\n         userthreadlocal.set(new user("nyima", 20));\n\n         // 取值\n         system.out.println(stringthreadlocal.get());\n         system.out.println(userthreadlocal.get());\n          \n          // 移除\n\t\t userthreadlocal.remove();\n\t\t system.out.println(userthreadlocal.get());\n      });\n\n      thread thread2 = new thread(()->{\n         // stringthreadlocal第一次赋值\n         stringthreadlocal.set("thread2 stringthreadlocal first");\n         // stringthreadlocal第二次赋值\n         stringthreadlocal.set("thread2 stringthreadlocal second");\n         // userthreadlocal赋值\n         userthreadlocal.set(new user("hulu", 20));\n\n         // 取值\n         system.out.println(stringthreadlocal.get());\n         system.out.println(userthreadlocal.get());\n      });\n\n      // 启动线程\n      thread1.start();\n      thread2.start();\n   }\n}\n\nclass user {\n   string name;\n   int age;\n\n   public user(string name, int age) {\n      this.name = name;\n      this.age = age;\n   }\n\n   @override\n   public string tostring() {\n      return "user{" +\n            "name=\'" + name + \'\\\'\' +\n            ", age=" + age +\n            \'}\';\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n运行结果\n\nthread1 stringthreadlocal second\nthread2 stringthreadlocal second\nuser{name=\'nyima\', age=20}\nuser{name=\'hulu\', age=20}\nnull\n\n\n1\n2\n3\n4\n5\n\n\n从运行结果可以看出\n\n * 每个线程中的threadlocal变量是每个线程私有的，而不是共享的\n   * 从线程1和线程2的打印结果可以看出\n * threadlocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的\n   * stringthreadlocal被赋值了两次，保存的是最后一次赋值的结果\n * threadlocal可以进行以下几个操作\n   * set 设置值\n   * get 取出值\n   * remove 移除值\n\n\n# 原理\n\n# thread中的threadlocals\n\npublic class thread implements runnable {\n ...\n\n threadlocal.threadlocalmap threadlocals = null;\n\n // 放在后面说\n threadlocal.threadlocalmap inheritablethreadlocals = null;\n\n ...\n}\nstatic class threadlocalmap {\n    static class entry extends weakreference<threadlocal<?>> {\n        /** the value associated with this threadlocal. */\n        object value;\n\n        entry(threadlocal<?> k, object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看出thread类中有一个threadlocals和一个inheritablethreadlocals，它们都是threadlocalmap类型的变量，而threadlocalmap是一个定制化的hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadlocals，inheritablethreadlocals放在后面讨论\n\n# threadlocal中的方法\n\nset方法\n\npublic void set(t value) {\n    // 获取当前线程\n    thread t = thread.currentthread();\n    \n    // 获得threadlocalmap对象 \n    // 这里的get会返回thread类中的threadlocals\n    threadlocalmap map = getmap(t);\n    \n    // 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入\n    if (map != null)\n        // threadlocal自生的引用作为key，传入的值作为value\n        map.set(this, value);\n    else\n        createmap(t, value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果未创建\n\nvoid createmap(thread t, t firstvalue) {\n    // 创建的同时设置想放入的值\n    // hreadlocal自生的引用作为key，传入的值作为value\n    t.threadlocals = new threadlocalmap(this, firstvalue);\n}\n\n\n1\n2\n3\n4\n5\n\n\nget方法\n\npublic t get() {\n    // 获取当前线程\n    thread t = thread.currentthread();\n\t// 获取当前线程的threadlocals变量\n    threadlocalmap map = getmap(t);\n    \n    // 判断threadlocals是否被初始化了\n    if (map != null) {\n        // 已经初始化则直接返回\n        threadlocalmap.entry e = map.getentry(this);\n        if (e != null) {\n            @suppresswarnings("unchecked")\n            t result = (t)e.value;\n            return result;\n        }\n    }\n    // 否则就创建threadlocals\n    return setinitialvalue();\n}\nprivate t setinitialvalue() {\n    // 这个方法返回是null\n    t value = initialvalue();\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    \n    // 无论map创建与否，最终value的值都为null\n    if (map != null)\n        map.set(this, value);\n    else\n        createmap(t, value);\n    return value;\n}\nprotected t initialvalue() {\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nremove方法\n\npublic void remove() {\n    threadlocalmap m = getmap(thread.currentthread());\n    if (m != null)\n        // 如果threadlocals已经被初始化，则移除\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 总结\n\n在每个线程内部都有一个名为threadlocals的成员变量，该变量的类型为hashmap，其中key为我们定义的threadlocal变量的this引用，value则为我们使用set方法设置的值。每个线程的本地变量存放在线程自己的内存变量threadlocals中\n\n只有当前线程第一次调用threadlocal的set或者get方法时才会创建threadlocals（inheritablethreadlocals也是一样）。其实每个线程的本地变量不是存放在threadlocal实例里面，而是存放在调用线程的threadlocals变量里面\n\n\n# 15、inheritablethreadlocal\n\n\n# 简介\n\n从threadlocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的\n\nthread.currentthread()\n\n\n1\n\n\n所以threadlocal无法从父线程传向子线程，所以inheritablethreadlocal出现了，它能够让父线程中threadlocal的值传给子线程。\n\n也就是从main所在的线程，传给thread1或thread2\n\n\n# 使用\n\npublic class demo1 {\n   public static void main(string[] args) {\n      threadlocal<string> stringthreadlocal = new threadlocal<>();\n      inheritablethreadlocal<string> stringinheritable = new inheritablethreadlocal<>();\n\n      // 主线程赋对上面两个变量进行赋值\n      stringthreadlocal.set("this is threadlocal");\n      stringinheritable.set("this is inheritablethreadlocal");\n\n      // 创建线程\n      thread thread1 = new thread(()->{\n         // 获得threadlocal中存放的值\n         system.out.println(stringthreadlocal.get());\n\n         // 获得inheritablethreadlocal存放的值\n         system.out.println(stringinheritable.get());\n      });\n\n      thread1.start();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n运行结果\n\nnull\nthis is inheritablethreadlocal\n\n\n1\n2\n\n\n可以看出inheritablethreadlocal的值成功从主线程传入了子线程，而threadlocal则没有\n\n\n# 原理\n\n# inheritablethreadlocal\n\npublic class inheritablethreadlocal<t> extends threadlocal<t> {\n    // 传入父线程中的一个值，然后直接返回\n    protected t childvalue(t parentvalue) {\n        return parentvalue;\n    }\n\n  \t// 返回传入线程的inheritablethreadlocals\n    // thread中有一个inheritablethreadlocals变量\n    // threadlocal.threadlocalmap inheritablethreadlocals = null;\n    threadlocalmap getmap(thread t) {\n       return t.inheritablethreadlocals;\n    }\n\n \t// 创建一个inheritablethreadlocals\n    void createmap(thread t, t firstvalue) {\n        t.inheritablethreadlocals = new threadlocalmap(this, firstvalue);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由如上代码可知，inheritablethreadlocal继承了threadlocal，并重写了三个方法。inheritablethreadlocal重写了createmap方法，那么现在当第一次调用set方法时，创建的是当前线程的inheritablethreadlocals变量的实例而不再是threadlocals。当调用getmap方法获取当前线程内部的map变量时，获取的是inheritablethreadlocals而不再是threadlocals\n\n# childvalue(t parentvalue)方法的调用\n\n在主函数运行时，会调用thread的默认构造函数（创建主线程，也就是父线程），所以我们先看看thread的默认构造函数\n\npublic thread() {\n    init(null, null, "thread-" + nextthreadnum(), 0);\n}\nprivate void init(threadgroup g, runnable target, string name,\n                  long stacksize, accesscontrolcontext acc,\n                  boolean inheritthreadlocals) {\n   \t...\n        \n\t// 获得当前线程的，在这里是主线程\n    thread parent = currentthread();\n   \n    ...\n    \n    // 如果父线程的inheritablethreadlocals存在\n    // 我们在主线程中调用set和get时，会创建inheritablethreadlocals\n    if (inheritthreadlocals && parent.inheritablethreadlocals != null)\n        // 设置子线程的inheritablethreadlocals\n        this.inheritablethreadlocals =\n            threadlocal.createinheritedmap(parent.inheritablethreadlocals);\n    \n    /* stash the specified stack size in case the vm cares */\n    this.stacksize = stacksize;\n\n    /* set thread id */\n    tid = nextthreadid();\n}\nstatic threadlocalmap createinheritedmap(threadlocalmap parentmap) {\n    return new threadlocalmap(parentmap);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在createinheritedmap内部使用父线程的inheritablethreadlocals变量作为构造函数创建了一个新的threadlocalmap变量，然后赋值给了子线程的inheritablethreadlocals变量\n\nprivate threadlocalmap(threadlocalmap parentmap) {\n    entry[] parenttable = parentmap.table;\n    int len = parenttable.length;\n    setthreshold(len);\n    table = new entry[len];\n\n    for (int j = 0; j < len; j++) {\n        entry e = parenttable[j];\n        if (e != null) {\n            @suppresswarnings("unchecked")\n            threadlocal<object> key = (threadlocal<object>) e.get();\n            if (key != null) {\n                // 这里调用了 childvalue 方法\n                // 该方法会返回parent的值\n                object value = key.childvalue(e.value);\n                \n                entry c = new entry(key, value);\n                int h = key.threadlocalhashcode & (len - 1);\n                while (table[h] != null)\n                    h = nextindex(h, len);\n                table[h] = c;\n                size++;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在该构造函数内部把父线程的inheritablethreadlocals成员变量的值复制到新的threadlocalmap对象中\n\n# 总结\n\ninheritablethreadlocal类通过重写getmap和createmap，让本地变量保存到了具体线程的inheritablethreadlocals变量里面，那么线程在通过inheritablethreadlocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritablethreadlocals变量。\n\n当父线程创建子线程时，构造函数会把父线程中inheritablethreadlocals变量里面的本地变量复制一份保存到子线程的inheritablethreadlocals变量里面。\n\n\n# 四、共享模型之内存\n\n\n# 1、java内存模型（jmm）\n\njmm 即 java memory model，它定义了**主存（共享内存）、工作内存（线程私有）**抽象概念，底层对应着 cpu 寄存器、缓存、硬件内存、 cpu 指令优化等。\n\njmm体现在以下几个方面\n\n * 原子性 - 保证指令不会受到线程上下文切换的影响\n * 可见性 - 保证指令不会受 cpu 缓存的影响\n * 有序性 - 保证指令不会受 cpu 指令并行优化的影响\n\n\n# 2、可见性\n\n# 引例\n\n退出不出的循环\n\nstatic boolean run = true;\n\tpublic static void main(string[] args) throws interruptedexception {\n\t\tnew thread(()->{\n\t\t\twhile (run) {\n\t\t\t\t//如果run为真，则一直执行\n\t\t\t}\n\t\t}).start();\n\n\t\tthread.sleep(1000);\n\t\tsystem.out.println("改变run的值为false");\n\t\trun = false;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n为什么无法退出该循环\n\n * 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。\n\n\n\n * 因为 t 线程要频繁从主内存中读取 run 的值，jit 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率\n\n\n\n * 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值\n\n\n\n解决方法\n\n * 使用volatile易变关键字\n * 它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存\n\n//使用易变关键字\nvolatile static boolean run = true;\npublic static void main(string[] args) throws interruptedexception {\n\tnew thread(()->{\n\t\twhile (run) {\n\t\t\t//如果run为真，则一直执行\n\t\t}\n\t}).start();\n\n\tthread.sleep(1000);\n\tsystem.out.println("改变run的值为false");\n\trun = false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 可见性与原子性\n\n前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况\n\n * 注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。\n\n * 但缺点是 synchronized 是属于重量级操作，性能相对更低。\n\n * 如果在前面示例的死循环中加入 system.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？\n   \n   * 因为使用了synchronized关键字\n     \n     public void println(string x) {\n     \t\t//使用了synchronized关键字\n             synchronized (this) {\n                 print(x);\n                 newline();\n             }\n         }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n# 两阶终止模式优化\n\npublic class test7 {\n\tpublic static void main(string[] args) throws interruptedexception {\n\t\tmonitor monitor = new monitor();\n\t\tmonitor.start();\n\t\tthread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass monitor {\n\n\tthread monitor;\n\t//设置标记，用于判断是否被终止了\n\tprivate volatile boolean stop = false;\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new thread() {\n\t\t\t@override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(stop) {\n\t\t\t\t\t\tsystem.out.println("处理后续任务");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tthread.sleep(1000);\n\t\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\t\tsystem.out.println("被打断了");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n        //修改标记\n\t\tstop = true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n# 同步模式之犹豫模式\n\n定义\n\nbalking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回\n\n * 用一个标记来判断该任务是否已经被执行过了\n * 需要避免线程安全问题\n   * 加锁的代码块要尽量的小，以保证性能\n\npackage com.nyima.day1;\n\n/**\n * @author chen panwen\n * @data 2020/3/26 16:11\n */\npublic class test7 {\n\tpublic static void main(string[] args) throws interruptedexception {\n\t\tmonitor monitor = new monitor();\n\t\tmonitor.start();\n\t\tmonitor.start();\n\t\tthread.sleep(3500);\n\t\tmonitor.stop();\n\t}\n}\n\nclass monitor {\n\n\tthread monitor;\n\t//设置标记，用于判断是否被终止了\n\tprivate volatile boolean stop = false;\n\t//设置标记，用于判断是否已经启动过了\n\tprivate boolean starting = false;\n\t/**\n\t * 启动监控器线程\n\t */\n\tpublic void start() {\n\t\t//上锁，避免多线程运行时出现线程安全问题\n\t\tsynchronized (this) {\n\t\t\tif (starting) {\n\t\t\t\t//已被启动，直接返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//启动监视器，改变标记\n\t\t\tstarting = true;\n\t\t}\n\t\t//设置线控器线程，用于监控线程状态\n\t\tmonitor = new thread() {\n\t\t\t@override\n\t\t\tpublic void run() {\n\t\t\t\t//开始不停的监控\n\t\t\t\twhile (true) {\n\t\t\t\t\tif(stop) {\n\t\t\t\t\t\tsystem.out.println("处理后续任务");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsystem.out.println("监控器运行中...");\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//线程休眠\n\t\t\t\t\t\tthread.sleep(1000);\n\t\t\t\t\t} catch (interruptedexception e) {\n\t\t\t\t\t\tsystem.out.println("被打断了");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmonitor.start();\n\t}\n\n\t/**\n\t * \t用于停止监控器线程\n\t */\n\tpublic void stop() {\n\t\t//打断线程\n\t\tmonitor.interrupt();\n\t\tstop = true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3、有序性\n\n\n# 指令重排\n\n * jvm 会在不影响正确性的前提下，可以调整语句的执行顺序\n\n\n\n这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。\n\n\n# 指令重排序优化\n\n * 事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 cpu 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这5 个阶段\n\n\n\n * 在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行\n\n * 指令重排的前提是，重排指令不能影响结果，例如\n   \n   // 可以重排的例子 \n   int a = 10; \n   int b = 20; \n   system.out.println( a + b );\n   \n   // 不能重排的例子 \n   int a = 10;\n   int b = a - 5;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 支持流水线的处理器\n\n现代 cpu 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 cpu 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），ipc = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。\n\n\n\n在多线程环境下，指令重排序可能导致出现意料之外的结果\n\n\n# 解决办法\n\nvolatile 修饰的变量，可以禁用指令重排\n\n * 禁止的是加volatile关键字变量之前的代码被重排序\n\n\n# 4、内存屏障\n\n * 可见性\n   * 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\n   * 读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据\n * 有序性\n   * 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n   * 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n\n\n# 5、volatile 原理\n\nvolatile的底层实现原理是内存屏障，memory barrier（memory fence）\n\n * 对 volatile 变量的写指令后会加入写屏障\n * 对 volatile 变量的读指令前会加入读屏障\n\n\n# 如何保证可见性\n\n * 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\n   \n   \n\n * 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据\n   \n   \n\n\n# 如何保证有序性\n\n * 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n   \n   \n\n * 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n   \n   \n\n\n\n但是不能解决指令交错问题\n\n * 写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去\n * 而有序性的保证也只是保证了本线程内相关代码不被重排序\n\n\n# 实现原理之lock前缀\n\n在x86处理器下通过工具获取jit编译器生成的汇编指令来查看对volatile进行写操作时\n\ninstance = new singleton();\n\n\n1\n\n\n对应的汇编代码是\n\n... lock addl ...\n\n\n1\n\n\n有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查ia-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事\n\n * lock前缀指令会引起处理器\n   \n   缓存回写到内存\n   \n   * lock前缀指令导致在执行指令期间，声言处理器的lock#信号。在多处理器环境中，lock#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，lock #信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据\n\n * 一个处理器的缓存回写到内存会\n   \n   导致其他处理器的缓存无效\n   \n   * 在多核处理器系统中进行操作的时候，ia-32和intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致\n\n\n# 五、共享模型之无锁\n\n\n# 1、无锁解决线程安全问题\n\n * 使用原子整数\n   \n   atomicinteger balance = new atomicinteger();\n   \n   \n   1\n   \n\ninterface account {\n\tinteger getbalance();\n\n\tvoid withdraw(integer amount);\n\n\t/**\n\t * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0\n\t */\n\tstatic void demo(account account) {\n\t\tlist<thread> ts = new arraylist<>();\n\t\tlong start = system.nanotime();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tts.add(new thread(() -> {\n\t\t\t\taccount.withdraw(10);\n\t\t\t}));\n\t\t}\n\t\tts.foreach(thread::start);\n\t\tts.foreach(t -> {\n\t\t\ttry {\n\t\t\t\tt.join();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t});\n\t\tlong end = system.nanotime();\n\t\tsystem.out.println(account.getbalance() + " cost: " + (end - start) / 1000_000 + " ms");\n\t}\n}\n\n//线程不安全的做法\nclass accountunsafe implements account {\n\tprivate integer balance;\n\n\tpublic accountunsafe(integer balance) {\n\t\tthis.balance = balance;\n\t}\n\n\n\t@override\n\tpublic integer getbalance() {\n\t\treturn this.balance;\n\t}\n\n\t@override\n\tpublic synchronized void withdraw(integer amount) {\n\t\tbalance -= amount;\n\t}\n\n\tpublic static void main(string[] args) {\n\t\taccount.demo(new accountunsafe(10000));\n\t\taccount.demo(new accountcas(10000));\n\t}\n}\n\n//线程安全的做法\nclass accountcas implements account {\n\t//使用原子整数\n\tprivate atomicinteger balance;\n\n\tpublic accountcas(int balance) {\n\t\tthis.balance = new atomicinteger(balance);\n\t}\n\n\t@override\n\tpublic integer getbalance() {\n\t\t//得到原子整数的值\n\t\treturn balance.get();\n\t}\n\n\t@override\n\tpublic void withdraw(integer amount) {\n\t\twhile(true) {\n\t\t\t//获得修改前的值\n\t\t\tint prev = balance.get();\n\t\t\t//获得修改后的值\n\t\t\tint next = prev-amount;\n\t\t\t//比较并设值\n\t\t\tif(balance.compareandset(prev, next)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 2、cas与volatile\n\n前面看到的 atomicinteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？\n\n其中的关键是 compareandswap（比较并设置值），它的简称就是 cas （也有 compare and swap 的说法），它必须是原子操作。\n\n\n\n\n# 工作流程\n\n * 当一个线程要去修改account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与account中的余额进行比较。\n   * 如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作。\n   * 如果两者不相等，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。\n\n注意\n\n * 其实 cas 的底层是 lock cmpxchg 指令（x86 架构），在单核 cpu 和多核 cpu 下都能够保证【比较-交换】的原子性。\n * 在多核状态下，某个核执行到带 lock 的指令时，cpu 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。\n\n\n# volatile\n\n获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。\n\n注意\n\nvolatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）\n\n\n1\n\n\ncas 必须借助 volatile 才能读取到共享变量的新值来实现【比较并交换】的效果\n\n\n# 效率问题\n\n一般情况下，使用无锁比使用加锁的效率更高。\n\n\n\n原因\n\n\n# cas特点\n\n结合 cas 和 volatile 可以实现无锁并发，适用于线程数少、多核 cpu 的场景下。\n\n * cas 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。\n\n * synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。\n\n * cas 体现的是\n   \n   无锁并发、无阻塞并发\n   \n   ，请仔细体会这两句话的意思\n   \n   * 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一\n   * 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响\n\n\n# 3、原子整数\n\nj.u.c 并发包提供了\n\n * atomicboolean\n * atomicinteger\n * atomiclong\n\n以 atomicinteger 为例\n\n atomicinteger i = new atomicinteger(0);\n \n// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ system.out.println(i.getandincrement());\n \n// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i system.out.println(i.incrementandget());\n \n// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i system.out.println(i.decrementandget());\n \n// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--\nsystem.out.println(i.getanddecrement());\n \n// 获取并加值（i = 0, 结果 i = 5, 返回 0） \nsystem.out.println(i.getandadd(5));\n \n// 加值并获取（i = 5, 结果 i = 0, 返回 0） \nsystem.out.println(i.addandget(-5));\n \n// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用 \nsystem.out.println(i.getandupdate(p -> p - 2));\n \n// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用 \nsystem.out.println(i.updateandget(p -> p + 2));\n \n// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用 // getandupdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 \n// getandaccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 \nfinal system.out.println(i.getandaccumulate(10, (p, x) -> p + x));\n \n// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） \n// 其中函数中的操作能保证原子，但函数需要无副作用\nsystem.out.println(i.accumulateandget(-10, (p, x) -> p + x));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 4、原子引用\n\npublic interface decimalaccount {\n\tbigdecimal getbalance();\n\n\tvoid withdraw(bigdecimal amount);\n\n\t/**\n\t * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    \n     * 如果初始余额为 10000 那么正确的结果应当是 0\n\t */\n\tstatic void demo(decimalaccountimpl account) {\n\t\tlist<thread> ts = new arraylist<>();\n\t\tlong start = system.nanotime();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tts.add(new thread(() -> {\n\t\t\t\taccount.withdraw(bigdecimal.ten);\n\t\t\t}));\n\t\t}\n\t\tts.foreach(thread::start);\n\t\tts.foreach(t -> {\n\t\t\ttry {\n\t\t\t\tt.join();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t});\n\t\tlong end = system.nanotime();\n\t\tsystem.out.println(account.getbalance() + " cost: " + (end - start) / 1000_000 + " ms");\n\t}\n}\n\nclass decimalaccountimpl implements decimalaccount {\n\t//原子引用，泛型类型为小数类型\n\tatomicreference<bigdecimal> balance;\n\n\tpublic decimalaccountimpl(bigdecimal balance) {\n\t\tthis.balance = new atomicreference<bigdecimal>(balance);\n\t}\n\n\t@override\n\tpublic bigdecimal getbalance() {\n\t\treturn balance.get();\n\t}\n\n\t@override\n\tpublic void withdraw(bigdecimal amount) {\n\t\twhile(true) {\n\t\t\tbigdecimal pre = balance.get();\n\t\t\tbigdecimal next = pre.subtract(amount);\n\t\t\tif(balance.compareandset(pre, next)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(string[] args) {\n\t\tdecimalaccount.demo(new decimalaccountimpl(new bigdecimal("10000")));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 5、aba问题\n\npublic class demo3 {\n\tstatic atomicreference<string> str = new atomicreference<>("a");\n\tpublic static void main(string[] args) {\n\t\tnew thread(() -> {\n\t\t\tstring pre = str.get();\n\t\t\tsystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthread.sleep(1000);\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\t//把str中的a改为c\n\t\t\tsystem.out.println("change a->c " + str.compareandset(pre, "c"));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws interruptedexception {\n\t\tnew thread(()-> {\n\t\t\tsystem.out.println("change a->b " + str.compareandset("a", "b"));\n\t\t}).start();\n\t\tthread.sleep(500);\n\t\tnew thread(()-> {\n\t\t\tsystem.out.println("change b->a " + str.compareandset("b", "a"));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n主线程仅能判断出共享变量的值与初值 a 是否相同，不能感知到这种从 a 改为 b 又 改回 a 的情况，如果主线程希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号\n\n\n# atomicstampedreference\n\npublic class demo3 {\n\t//指定版本号\n\tstatic atomicstampedreference<string> str = new atomicstampedreference<>("a", 0);\n\tpublic static void main(string[] args) {\n\t\tnew thread(() -> {\n\t\t\tstring pre = str.getreference();\n\t\t\t//获得版本号\n\t\t\tint stamp = str.getstamp();\n\t\t\tsystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthread.sleep(1000);\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\t//把str中的a改为c,并比对版本号，如果版本号相同，就执行替换，并让版本号+1\n\t\t\tsystem.out.println("change a->c stamp " + stamp + str.compareandset(pre, "c", stamp, stamp+1));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws interruptedexception {\n\t\tnew thread(()-> {\n\t\t\tint stamp = str.getstamp();\n\t\t\tsystem.out.println("change a->b stamp " + stamp + str.compareandset("a", "b", stamp, stamp+1));\n\t\t}).start();\n\t\tthread.sleep(500);\n\t\tnew thread(()-> {\n\t\t\tint stamp = str.getstamp();\n\t\t\tsystem.out.println("change b->a stamp " + stamp +  str.compareandset("b", "a", stamp, stamp+1));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# atomicmarkablereference\n\natomicstampedreference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： a -> b -> a -> c ，通过atomicstampedreference，我们可以知道，引用变量中途被更改了几次。 但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 atomicmarkablereference\n\npublic class demo4 {\n\t//指定版本号\n\tstatic atomicmarkablereference<string> str = new atomicmarkablereference<>("a", true);\n\tpublic static void main(string[] args) {\n\t\tnew thread(() -> {\n\t\t\tstring pre = str.getreference();\n\t\t\tsystem.out.println("change");\n\t\t\ttry {\n\t\t\t\tother();\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthread.sleep(1000);\n\t\t\t} catch (interruptedexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t\t//把str中的a改为c,并比对版本号，如果版本号相同，就执行替换，并让版本号+1\n\t\t\tsystem.out.println("change a->c mark " +  str.compareandset(pre, "c", true, false));\n\t\t}).start();\n\t}\n\n\tstatic void other() throws interruptedexception {\n\t\tnew thread(() -> {\n\t\t\tsystem.out.println("change a->a mark " + str.compareandset("a", "a", true, false));\n\t\t}).start();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n\n\n# 两者的区别\n\n * atomicstampedreference 需要我们传入整型变量作为版本号，来判定是否被更改过\n * atomicmarkablereference需要我们传入布尔变量作为标记，来判断是否被更改过\n\n\n# 6、原子数组\n\n * atomicintegerarray\n * atomiclongarray\n * atomicreferencearray\n\n\n# lamba表达式的使用\n\n * 提供者\n   * 无参又返回\n   * ()->返回结果\n * 方法\n   * 有参有返回\n   * (参数一…)->返回结果\n * 消费者\n   * 有参无返回\n   * (参数一…)->void\n\n\n# 7、原子更新器\n\n * atomicreferencefieldupdater // 域 字段\n * atomicintegerfieldupdater\n * atomiclongfieldupdate\n\n原子更新器用于帮助我们改变某个对象中的某个属性\n\npublic class demo1 {\n   public static void main(string[] args) {\n      student student = new student();\n       \n      // 获得原子更新器\n      // 泛型\n      // 参数1 持有属性的类 参数2 被更新的属性的类\n      // newupdater中的参数：第三个为属性的名称\n      atomicreferencefieldupdater<student, string> updater = atomicreferencefieldupdater.newupdater(student.class, string.class, "name");\n       \n      // 修改\n      updater.compareandset(student, null, "nyima");\n      system.out.println(student);\n   }\n}\n\nclass student {\n   volatile string name;\n\n   @override\n   public string tostring() {\n      return "student{" +\n            "name=\'" + name + \'\\\'\' +\n            \'}\';\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 原子更新器初始化过程\n\n从上面的例子可以看出，原子更新器是通过newupdater来获取实例的。其中传入了三个参数\n\n * 拥有属性的类的class\n * 属性的class\n * 属性的名称\n\n大概可以猜出来，初始化过程用到了反射，让我们看看源码来验证一下这个猜测。\n\n# newupdater方法\n\npublic static <u,w> atomicreferencefieldupdater<u,w> newupdater(class<u> tclass,\n                                                                class<w> vclass,\n                                                                string fieldname) {\n    // 返回了一个atomicreferencefieldupdaterimpl实例\n    return new atomicreferencefieldupdaterimpl<u,w>\n        (tclass, vclass, fieldname, reflection.getcallerclass());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从newupdater方法还并不能看出来具体的初始化过程\n\n# 内部实现类\n\n\n\natomicreferencefieldupdater为抽象类，该类内部有一个自己的实现类atomicreferencefieldupdaterimpl\n\nprivate static final class atomicreferencefieldupdaterimpl<t,v>\n        extends atomicreferencefieldupdater<t,v>\n\n\n1\n2\n\n\n\n\n构造方法\n\natomicreferencefieldupdaterimpl(final class<t> tclass,\n                                final class<v> vclass,\n                                final string fieldname,\n                                final class<?> caller) {\n    // 用于保存要被修改的属性\n    final field field;\n    \n    // 属性的class\n    final class<?> fieldclass;\n    \n    // field的修饰符\n    final int modifiers;\n    try {\n        // 反射获得属性\n        field = accesscontroller.doprivileged(\n            new privilegedexceptionaction<field>() {\n                public field run() throws nosuchfieldexception {\n                    // tclass为传入的属性的class，可以通过它来获得属性\n                    return tclass.getdeclaredfield(fieldname);\n                }\n            });\n        \n        // 获得属性的修饰符，主要用于判断\n        // 1、vclass 与 属性确切的类型是否匹配\n        // 2、是否为引用类型\n        // 3、被修改的属性是否加了volatile关键字\n        modifiers = field.getmodifiers();\n        sun.reflect.misc.reflectutil.ensurememberaccess(\n            caller, tclass, null, modifiers);\n        classloader cl = tclass.getclassloader();\n        classloader ccl = caller.getclassloader();\n        if ((ccl != null) && (ccl != cl) &&\n            ((cl == null) || !isancestor(cl, ccl))) {\n            sun.reflect.misc.reflectutil.checkpackageaccess(tclass);\n        }\n        \n        // 获得属性类的class\n        fieldclass = field.gettype();\n    } catch (privilegedactionexception pae) {\n        throw new runtimeexception(pae.getexception());\n    } catch (exception ex) {\n        throw new runtimeexception(ex);\n    }\n\n    if (vclass != fieldclass)\n        throw new classcastexception();\n    if (vclass.isprimitive())\n        throw new illegalargumentexception("must be reference type");\n\n    if (!modifier.isvolatile(modifiers))\n        throw new illegalargumentexception("must be volatile type");\n\n    // access to protected field members is restricted to receivers only\n    // of the accessing class, or one of its subclasses, and the\n    // accessing class must in turn be a subclass (or package sibling)\n    // of the protected member\'s defining class.\n    // if the updater refers to a protected field of a declaring class\n    // outside the current package, the receiver argument will be\n    // narrowed to the type of the accessing class.\n \t// 对类中的属性进行初始化\n    this.cclass = (modifier.isprotected(modifiers) &&\n                   tclass.isassignablefrom(caller) &&\n                   !issamepackage(tclass, caller))\n                  ? caller : tclass;\n    this.tclass = tclass;\n    this.vclass = vclass;\n    // 获得偏移量\n    this.offset = u.objectfieldoffset(field);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n可以看出，原子引用更新器确实使用了反射\n\n\n# 8、longadder原理\n\n\n# 原理之伪共享\n\n\n\n缓存行伪共享得从缓存说起 缓存与内存的速度比较\n\n\n\n\n\n因为 cpu 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） 缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 cpu 要保证数据的一致性，如果某个 cpu 核心更改了数据，其它 cpu 核心对应的整个缓存行必须失效\n\n\n\n因为 cell 是数组形式，在内存中是连续存储的，一个 cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 cell 对象。这样问题来了：\n\n * core-0 要修改 cell[0]\n * core-1 要修改 cell[1]\n\n无论谁修改成功，都会导致对方 core 的缓存行失效，\n\n比如 core-0 中 cell[0]=6000, cell[1]=8000 要累加 cell[0]=6001, cell[1]=8000 ，这时会让 core-1 的缓存行失效\n\n@sun.misc.contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding（空白），从而让 cpu 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效\n\n\n\n累加主要调用以下方法\n\npublic void add(long x) {\n       cell[] as; long b, v; int m; cell a;\n       if ((as = cells) != null || !casbase(b = base, b + x)) {\n           boolean uncontended = true;\n           if (as == null || (m = as.length - 1) < 0 ||\n               (a = as[getprobe() & m]) == null ||\n               !(uncontended = a.cas(v = a.value, v + x)))\n               longaccumulate(x, null, uncontended);\n       }\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n累加流程图\n\n\n\n\n# 9、unsafe\n\nunsafe 对象提供了非常底层的，操作内存、线程的方法，unsafe 对象不能直接调用，只能通过反射获得\n\npublic class getunsafe {\n\tpublic static void main(string[] args) throws nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception, nosuchfieldexception {\n\t\t// 通过反射获得unsafe对象\n\t\tclass unsafeclass = unsafe.class;\n\t\t// 获得构造函数，unsafe的构造函数为私有的\n\t\tconstructor constructor = unsafeclass.getdeclaredconstructor();\n\t\t// 设置为允许访问私有内容\n\t\tconstructor.setaccessible(true);\n\t\t// 创建unsafe对象\n\t\tunsafe unsafe = (unsafe) constructor.newinstance();\n\t\t\n\t\t// 创建person对象\n\t\tperson person = new person();\n\t\t// 获得其属性 name 的偏移量\n\t\tfield field = person.class.getdeclaredfield("name");\n\t\tlong offset = unsafe.objectfieldoffset(field);\n\n\t\t// 通过unsafe的cas操作改变值\n\t\tunsafe.compareandswapobject(person, offset, null, "nyima");\n\t\tsystem.out.println(person);\n\t}\n}\n\nclass person {\n    // 配合cas操作，必须用volatile修饰\n \tvolatile string name;\n\n\n\t@override\n\tpublic string tostring() {\n\t\treturn "person{" +\n\t\t\t\t"name=\'" + name + \'\\\'\' +\n\t\t\t\t\'}\';\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 六、共享模型之不可变\n\n\n# 1、不可变\n\n如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。\n\n\n# 2、不可变设计\n\n# string类中不可变的体现\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final char value[];\n\n    /** cache the hash code for the string */\n    private int hash; // default to 0\n    \n   //....\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nﬁnal 的使用 * 发现该类、类中所有属性都是 *ﬁnal 的\n\n * 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改\n * 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性\n\n**保护性拷贝 **\n\n但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例\n\npublic string substring(int beginindex) {\n        if (beginindex < 0) {\n            throw new stringindexoutofboundsexception(beginindex);\n        }\n        int sublen = value.length - beginindex;\n        if (sublen < 0) {\n            throw new stringindexoutofboundsexception(sublen);\n        }\n    \t//返回的是一个新的对象\n        return (beginindex == 0) ? this : new string(value, beginindex, sublen);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n发现其内部是调用 string 的构造方法创建了一个新字符串\n\npublic string(char value[], int offset, int count) {\n        if (offset < 0) {\n            throw new stringindexoutofboundsexception(offset);\n        }\n        if (count <= 0) {\n            if (count < 0) {\n                throw new stringindexoutofboundsexception(count);\n            }\n            if (offset <= value.length) {\n                this.value = "".value;\n                return;\n            }\n        }\n        // note: offset or count might be near -1>>>1.\n        if (offset > value.length - count) {\n            throw new stringindexoutofboundsexception(offset + count);\n        }\n        this.value = arrays.ofrange(value, offset, offset+count);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive ）】\n\n\n# 七、线程池\n\n\n# 1、自定义线程池\n\n\n# 图解\n\n\n\n * 阻塞队列中维护了由主线程（或者其他线程）所产生的的任务\n * 主线程类似于生产者，产生任务并放入阻塞队列中\n * 线程池类似于消费者，得到阻塞队列中已有的任务并执行\n\n\n# 代码\n\npublic class demo3 {\n   public static void main(string[] args) {\n      threadpool threadpool = new threadpool(2,  timeunit.seconds, 1, 4);\n      for (int i = 0; i < 10; i++) {\n         threadpool.execute(()->{\n            try {\n               timeunit.seconds.sleep(10000);\n            } catch (interruptedexception e) {\n               e.printstacktrace();\n            }\n            system.out.println("任务正在执行!");\n         });\n      }\n   }\n}\n\n\n/**\n * 自定义线程池\n */\nclass threadpool {\n   /**\n    * 自定义阻塞队列\n    */\n   private blockingqueue<runnable> blockingqueue;\n\n   /**\n    * 核心线程数\n    */\n   private int coresize;\n\n   private hashset<worker> workers = new hashset<>();\n\n   /**\n    * 用于指定线程最大存活时间\n    */\n   private timeunit timeunit;\n   private long timeout;\n\n   /**\n    * 工作线程类\n    * 内部封装了thread类，并且添加了一些属性\n    */\n   private class worker extends thread {\n      runnable task;\n\n      public worker(runnable task) {\n         system.out.println("初始化任务");\n         this.task = task;\n      }\n\n      @override\n      public void run() {\n         // 如果有任务就执行\n         // 如果阻塞队列中有任务，就继续执行\n         while (task != null || (task = blockingqueue.take()) != null) {\n            try {\n               system.out.println("执行任务");\n               task.run();\n            } catch (exception e) {\n               e.printstacktrace();\n            } finally {\n               // 任务执行完毕，设为空\n               system.out.println("任务执行完毕");\n               task = null;\n            }\n         }\n         // 移除任务\n         synchronized (workers) {\n            system.out.println("移除任务");\n            workers.remove(this);\n         }\n      }\n   }\n\n   public threadpool(int coresize, timeunit timeunit, long timeout, int capacity) {\n      this.coresize = coresize;\n      this.timeunit = timeunit;\n      blockingqueue = new blockingqueue<>(capacity);\n      this.timeout = timeout;\n   }\n\n   public void execute(runnable task) {\n      synchronized (workers) {\n         // 创建任务\n         // 池中还有空余线程时，可以运行任务\n         // 否则阻塞\n         if (workers.size() < coresize) {\n            worker worker = new worker(task);\n            workers.add(worker);\n            worker.start();\n         } else {\n            system.out.println("线程池中线程已用完，请稍等");\n            blockingqueue.put(task);\n         }\n      }\n   }\n}\n\n/**\n * 阻塞队列\n * 用于存放主线程或其他线程产生的任务\n */\nclass blockingqueue<t> {\n   /**\n    * 阻塞队列\n    */\n   private  deque<t> blockingqueue;\n\n   /**\n    * 阻塞队列容量\n    */\n   private int capacity;\n\n   /**\n    * 锁\n    */\n   private reentrantlock lock;\n\n   /**\n    * 条件队列\n    */\n   private condition fullqueue;\n   private condition emptyqueue;\n\n\n   public blockingqueue(int capacity) {\n      blockingqueue = new arraydeque<>(capacity);\n      lock = new reentrantlock();\n      fullqueue = lock.newcondition();\n      emptyqueue = lock.newcondition();\n      this.capacity = capacity;\n   }\n\n   /**\n    * 获取任务的方法\n    */\n   public t take() {\n      // 加锁\n      lock.lock();\n      try {\n         // 如果阻塞队列为空（没有任务），就一直等待\n         while (blockingqueue.isempty()) {\n            try {\n               emptyqueue.await();\n            } catch (interruptedexception e) {\n               e.printstacktrace();\n            }\n         }\n         // 获取任务并唤醒生产者线程\n         t task = blockingqueue.removefirst();\n         fullqueue.signalall();\n         return task;\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   public t takenanos(long timeout, timeunit unit) {\n      // 转换等待时间\n      lock.lock();\n      try {\n         long nanos = unit.tonanos(timeout);\n         while (blockingqueue.isempty()) {\n            try {\n               // awaitnanos会返回剩下的等待时间\n               nanos = emptyqueue.awaitnanos(nanos);\n               if (nanos < 0) {\n                  return null;\n               }\n            } catch (interruptedexception e) {\n               e.printstacktrace();\n            }\n         }\n         t task = blockingqueue.removefirst();\n         fullqueue.signalall();\n         return task;\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   /**\n    * 放入任务的方法\n    * @param task 放入阻塞队列的任务\n    */\n   public void put(t task) {\n      lock.lock();\n      try {\n         while (blockingqueue.size() == capacity) {\n            try {\n               system.out.println("阻塞队列已满");\n               fullqueue.await();\n            } catch (interruptedexception e) {\n               e.printstacktrace();\n            }\n         }\n         blockingqueue.add(task);\n         // 唤醒等待的消费者\n         emptyqueue.signalall();\n      } finally {\n         lock.unlock();\n      }\n   }\n\n   public int getsize() {\n      lock.lock();\n      try {\n         return blockingqueue.size();\n      } finally {\n         lock.unlock();\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n\n\n实现了一个简单的线程池\n\n * 阻塞队列blockingqueue用于暂存来不及被线程执行的任务\n   * 也可以说是平衡生产者和消费者执行速度上的差异\n   * 里面的获取任务和放入任务用到了生产者消费者模式\n * 线程池中对线程thread进行了再次的封装，封装为了worker\n   * 在调用任务的run方法时，线程会去执行该任务，执行完毕后还会到阻塞队列中获取新任务来执行\n * 线程池中执行任务的主要方法为execute方法\n   * 执行时要判断正在执行的线程数是否大于了线程池容量\n\n\n# 2、threadpoolexecutor\n\n\n# 继承关系\n\n\n\n\n# 线程池状态\n\n// 线程池状态\n// runstate is stored in the high-order bits\n// running 高3位为111\nprivate static final int running    = -1 << count_bits;\n\n// shutdown 高3位为000\nprivate static final int shutdown   =  0 << count_bits;\n\n// 高3位 001\nprivate static final int stop       =  1 << count_bits;\n\n// 高3位 010\nprivate static final int tidying    =  2 << count_bits;\n\n// 高3位 011\nprivate static final int terminated =  3 << count_bits;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n状态名称         高3位的值   描述\nrunning      111     接收新任务，同时处理任务队列中的任务\nshutdown     000     不接受新任务，但是处理任务队列中的任务\nstop         001     中断正在执行的任务，同时抛弃阻塞队列中的任务\ntidying      010     任务执行完毕，活动线程为0时，即将进入终结阶段\nterminated   011     终结状态\n\n线程池状态和线程池中线程的数量由一个原子整型ctl来共同表示\n\n * 使用一个数来表示两个值的主要原因是：可以通过一次cas同时更改两个属性的值\n\n// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量\nprivate final atomicinteger ctl = new atomicinteger(ctlof(running, 0));\n\n// 并不是所有平台的int都是32位。\n// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量\n// 高3位为0，剩余位数全为1\nprivate static final int count_bits = integer.size - 3;\n\n// 2^count_bits次方，表示可以保存的最大线程数\n// capacity 的高3位为 0\nprivate static final int capacity   = (1 << count_bits) - 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n获取线程池状态、线程数量以及合并两个值的操作\n\n// packing and unpacking ctl\n// 获取运行状态\n// 该操作会让除高3位以外的数全部变为0\nprivate static int runstateof(int c)     { return c & ~capacity; }\n\n// 获取运行线程数\n// 该操作会让高3位为0\nprivate static int workercountof(int c)  { return c & capacity; }\n\n// 计算ctl新值\nprivate static int ctlof(int rs, int wc) { return rs | wc; }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 线程池属性\n\n// 工作线程，内部封装了thread\nprivate final class worker\n        extends abstractqueuedsynchronizer\n        implements runnable {\n    ...\n}\n\n// 阻塞队列，用于存放来不及被核心线程执行的任务\nprivate final blockingqueue<runnable> workqueue;\n\n// 锁\nprivate final reentrantlock mainlock = new reentrantlock();\n\n//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）\nprivate final hashset<worker> workers = new hashset<worker>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 构造方法极其参数\n\nthreadpoolexecutor最全面的构造方法\n\n也是构造自定义线程池的方法\n\npublic threadpoolexecutor(int corepoolsize,\n                          int maximumpoolsize,\n                          long keepalivetime,\n                          timeunit unit,\n                          blockingqueue<runnable> workqueue,\n                          threadfactory threadfactory,\n                          rejectedexecutionhandler handler)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 参数解释\n\n * corepoolsize：核心线程数\n * maximumpoolsize：最大线程数\n   * maximumpoolsize - corepoolsize = 救急线程数\n * keepalivetime：救急线程空闲时的最大生存时间\n * unit：时间单位\n * workqueue：阻塞队列（存放任务）\n   * 有界阻塞队列 arrayblockingqueue\n   * 无界阻塞队列 linkedblockingqueue\n   * 最多只有一个同步元素的 synchronousqueue\n   * 优先队列 priorityblockingqueue\n * threadfactory：线程工厂（给线程取名字）\n * handler：拒绝策略\n\n# 工作方式\n\n * 当一个任务传给线程池以后，可能有以下几种可能\n   * 将任务分配给一个核心线程来执行\n   * 核心线程都在执行任务，将任务放到阻塞队列workqueue中等待被执行\n   * 阻塞队列满了，使用救急线程来执行任务\n     * 救急线程用完以后，超过生存时间（keepalivetime）后会被释放\n   * 任务总数大于了 最大线程数（maximumpoolsize）与阻塞队列容量的最大值（workqueue.capacity），使用拒接策略\n\n# 拒绝策略\n\n如果线程到达 maximumpoolsize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现\n\n\n\n * abortpolicy：让调用者抛出 rejectedexecutionexception 异常，这是默认策略\n * callerrunspolicy：让调用者运行任务\n * discardpolicy：放弃本次任务\n * discardoldestpolicy：放弃队列中最早的任务，本任务取而代之\n\n# 使用\n\npublic class demo1 {\n   static atomicinteger threadid = new atomicinteger(0);\n\n   public static void main(string[] args) {\n      // 手动创建线程池\n      // 创建有界阻塞队列\n      arrayblockingqueue<runnable> runnable = new arrayblockingqueue<runnable>(10);\n      // 创建线程工厂\n      threadfactory threadfactory = new threadfactory() {\n         @override\n         public thread newthread(runnable r) {\n            thread thread = new thread(r, "working_thread_"+threadid.getandincrement());\n            return thread;\n         }\n      };\n\n      // 手动创建线程池\n      // 拒绝策略采用默认策略\n      threadpoolexecutor executor = new threadpoolexecutor(5, 7, 10, timeunit.seconds, runnable, threadfactory);\n\n      for (int i = 0; i < 20; i++) {\n         executor.execute(new runnable() {\n            @override\n            public void run() {\n               system.out.println(thread.currentthread());\n               try {\n                  thread.sleep(100000);\n               } catch (interruptedexception e) {\n                  e.printstacktrace();\n               }\n            }\n         });\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# fixedthreadpool\n\npublic class testfixedthreadpool {\n   public static void main(string[] args) {\n      // 自定义线程工厂\n      threadfactory factory = new threadfactory() {\n         atomicinteger atomicinteger = new atomicinteger(1);\n\n         @override\n         public thread newthread(runnable r) {\n            return new thread(r, "mythread_" + atomicinteger.getandincrement());\n         }\n      };\n\n      // 创建核心线程数量为2的线程池\n      // 通过 threadfactory可以给线程添加名字\n\n      executorservice executorservice = executors.newfixedthreadpool(2, factory);\n\n      // 任务\n      runnable runnable = new runnable() {\n         @override\n         public void run() {\n            system.out.println(thread.currentthread().getname());\n            system.out.println("this is fixedthreadpool");\n         }\n      };\n      \n      executorservice.execute(runnable);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n固定大小的线程池可以传入两个参数\n\n * 核心线程数：nthreads\n * 线程工厂：threadfactory\n\n内部调用的构造方法\n\nthreadpoolexecutor(nthreads, nthreads,\n                              0l, timeunit.milliseconds,\n                              new linkedblockingqueue<runnable>(),\n                              threadfactory);\n\n\n1\n2\n3\n4\n\n\n\n# cachedthreadpool\n\nexecutorservice executorservice = executors.newcachedthreadpool();\n\n\n1\n\n\n内部构造方法\n\nthreadpoolexecutor(0, integer.max_value,\n                              60l, timeunit.seconds,\n                              new synchronousqueue<runnable>());\n\n\n1\n2\n3\n\n\n * 没有核心线程，最大线程数为integer.max_value，所有创建的线程都是救急线程，空闲时生存时间为60秒\n\n * 阻塞队列使用的是synchronousqueue\n   \n   * synchronousqueue\n     \n     是一种特殊的队列\n     \n     * 没有容量，没有线程来取是放不进去的\n     * 只有当线程取任务时，才会将任务放入该阻塞队列中\n\n\n# singlethread\n\nexecutorservice service = executors.newsinglethreadexecutor();\n\n\n1\n\n\n内部构造方法\n\nnew finalizabledelegatedexecutorservice\n    (new threadpoolexecutor(1, 1,\n                            0l, timeunit.milliseconds,\n                            new linkedblockingqueue<runnable>()));\n\n\n1\n2\n3\n4\n\n\n内部调用了new threadpoolexecutor的构造方法，传入的corepoolsize和maximumpoolsize都为1。然后将该对象传给了finalizabledelegatedexecutorservice。该类修饰了threadpoolexecutor，让外部无法调用threadpoolexecutor内部的某些方法来修改所创建的线程池的大小。\n\n# 几个注意\n\n * singlethread和自己创建一个线程来运行多个任务的区别\n   \n   * 当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而singlethread会创建一个新线程，继续执行任务队列中剩余的任务。\n\n * singlethread和newfixedthreadpool(1)的区别\n   \n   * newfixedthreadpool(1)传值为1，可以将fixedthreadpool强转为threadpoolexecutor，然后通过setcorepoolsize改变核心线程数\n   \n   // 强转为threadpoolexecutor\n   threadpoolexecutor threadpool = (threadpoolexecutor) executors.newfixedthreadpool(1);\n   // 改变核心线程数\n   threadpool.setcorepoolsize(2);\n   \n   \n   1\n   2\n   3\n   4\n   \n   * 而singlethread无法修改核心线程数\n\n\n# 执行任务\n\n# execute()方法\n\nexecute(runnable command)\n\n\n1\n\n\n传入一个runnable对象，执行其中的run方法\n\n源码解析\n\npublic void execute(runnable command) {\n    if (command == null)\n        throw new nullpointerexception();\n\n    // 获取ctl\n    int c = ctl.get();\n    \n    // 判断当前启用的线程数是否小于核心线程数\n    if (workercountof(c) < corepoolsize) {\n        // 为该任务分配线程\n        if (addworker(command, true))\n            // 分配成功就返回\n            return;\n        \n        // 分配失败再次获取ctl\n        c = ctl.get();\n    }\n    \n    // 分配和信息线程失败以后\n    // 如果池状态为running并且插入到任务队列成功\n    if (isrunning(c) && workqueue.offer(command)) {\n        \n        // 双重检测，可能在添加后线程池状态变为了非running\n        int recheck = ctl.get();\n        \n        // 如果池状态为非running，则不会执行新来的任务\n        // 将该任务从阻塞队列中移除\n        if (! isrunning(recheck) && remove(command))\n            // 调用拒绝策略，拒绝该任务的执行\n            reject(command);\n        \n        // 如果没有正在运行的线程\n        else if (workercountof(recheck) == 0)\n            // 就创建新线程来执行该任务\n            addworker(null, false);\n    }\n    \n    // 如果添加失败了（任务队列已满），就调用拒绝策略\n    else if (!addworker(command, false))\n        reject(command);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n其中调用了**addwoker()**方法，再看看看这个方法\n\nprivate boolean addworker(runnable firsttask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runstateof(c);\n\n        // check if queue empty only if necessary.\n        // 如果池状态为非running状态、线程池为shutdown且该任务为空 或者阻塞队列中已经有任务\n        if (rs >= shutdown &&\n            ! (rs == shutdown &&\n               firsttask == null &&\n               ! workqueue.isempty()))\n            // 创建新线程失败\n            return false;\n\n        for (;;) {\n            // 获得当前工作线程数\n            int wc = workercountof(c);\n\n            // 参数中 core 为true\n            // capacity 为 1 << count_bits-1，一般不会超过\n            // 如果工作线程数大于了核心线程数，则创建失败\n            if (wc >= capacity ||\n                wc >= (core ? corepoolsize : maximumpoolsize))\n                return false;\n            // 通过cas操作改变c的值\n            if (compareandincrementworkercount(c))\n                // 更改成功就跳出多重循环，且不再运行循环\n                break retry;\n            // 更改失败，重新获取ctl的值\n            c = ctl.get();  // re-read ctl\n            if (runstateof(c) != rs)\n                // 跳出多重循环，且重新进入循环\n                continue retry;\n            // else cas failed due to workercount change; retry inner loop\n        }\n    }\n\n    // 用于标记work中的任务是否成功执行\n    boolean workerstarted = false;\n    // 用于标记worker是否成功加入了线程池中\n    boolean workeradded = false;\n    worker w = null;\n    try {\n        // 创建新线程来执行任务\n        w = new worker(firsttask);\n        final thread t = w.thread;\n        if (t != null) {\n            final reentrantlock mainlock = this.mainlock;\n            // 加锁\n            mainlock.lock();\n            try {\n                // recheck while holding lock.\n                // back out on threadfactory failure or if\n                // shut down before lock acquired.\n                // 加锁的同时再次检测\n                // 避免在释放锁之前调用了shut down\n                int rs = runstateof(ctl.get());\n\n                if (rs < shutdown ||\n                    (rs == shutdown && firsttask == null)) {\n                    if (t.isalive()) // precheck that t is startable\n                        throw new illegalthreadstateexception();\n                    // 将线程添加到线程池中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestpoolsize)\n                        largestpoolsize = s;\n                    // 添加成功标志位变为true\n                    workeradded = true;\n                }\n            } finally {\n                mainlock.unlock();\n            }\n            // 如果worker成功加入了线程池，就执行其中的任务\n            if (workeradded) {\n                t.start();\n                // 启动成功\n                workerstarted = true;\n            }\n        }\n    } finally {\n        // 如果执行失败\n        if (! workerstarted)\n            // 调用添加失败的函数\n            addworkerfailed(w);\n    }\n    return workerstarted;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n# submit()方法\n\nfuture<t> submit(callable<t> task)\n\n\n1\n\n\n传入一个callable对象，用future来捕获返回值\n\n使用\n\n// 通过submit执行callable中的call方法\n// 通过future来捕获返回值\nfuture<string> future = threadpool.submit(new callable<string>() {\n   @override\n   public string call() throws exception {\n      return "hello submit";\n   }\n});\n\n// 查看捕获的返回值\nsystem.out.println(future.get());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 停止\n\n# shutdown()\n\n/**\n* 将线程池的状态改为 shutdown\n* 不再接受新任务，但是会将阻塞队列中的任务执行完\n*/\npublic void shutdown() {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        checkshutdownaccess();\n        \n        // 修改线程池状态为 shutdown\n        advancerunstate(shutdown);\n        \n  \t\t// 中断空闲线程（没有执行任务的线程）\n        // idle：空闲的\n        interruptidleworkers();\n        onshutdown(); // hook for scheduledthreadpoolexecutor\n    } finally {\n        mainlock.unlock();\n    }\n    // 尝试终结，不一定成功\n    // \n    tryterminate();\n}\nfinal void tryterminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 终结失败的条件\n        // 线程池状态为running\n        // 线程池状态为 running shutdown stop （状态值大于tidying）\n        // 线程池状态为shutdown，但阻塞队列中还有任务等待执行\n        if (isrunning(c) ||\n            runstateatleast(c, tidying) ||\n            (runstateof(c) == shutdown && ! workqueue.isempty()))\n            return;\n        \n        // 如果活跃线程数不为0\n        if (workercountof(c) != 0) { // eligible to terminate\n            // 中断空闲线程\n            interruptidleworkers(only_one);\n            return;\n        }\n\n        final reentrantlock mainlock = this.mainlock;\n        mainlock.lock();\n        try {\n            // 处于可以终结的状态\n            // 通过cas将线程池状态改为tidying\n            if (ctl.compareandset(c, ctlof(tidying, 0))) {\n                try {\n                    terminated();\n                } finally {\n                    // 通过cas将线程池状态改为terminated\n                    ctl.set(ctlof(terminated, 0));\n                    termination.signalall();\n                }\n                return;\n            }\n        } finally {\n            mainlock.unlock();\n        }\n        // else retry on failed cas\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n# shutdownnow()\n\n/**\n* 将线程池的状态改为 stop\n* 不再接受新任务，也不会在执行阻塞队列中的任务\n* 会将阻塞队列中未执行的任务返回给调用者\n*/\npublic list<runnable> shutdownnow() {\n    list<runnable> tasks;\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        checkshutdownaccess();\n        \n        // 修改状态为stop，不执行任何任务\n        advancerunstate(stop);\n        \n        // 中断所有线程\n        interruptworkers();\n        \n        // 将未执行的任务从队列中移除，然后返回给调用者\n        tasks = drainqueue();\n    } finally {\n        mainlock.unlock();\n    }\n    // 尝试终结，一定会成功，因为阻塞队列为空了\n    tryterminate();\n    return tasks;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"Java集合",frontmatter:{title:"Java集合",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/3dacb0/"},regularPath:"/01.Java/Java%E9%9B%86%E5%90%88.html",relativePath:"01.Java/Java集合.md",key:"v-c2331f12",path:"/pages/3dacb0/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"NIO",frontmatter:{title:"NIO",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/b825b8/"},regularPath:"/01.Java/NIO.html",relativePath:"01.Java/NIO.md",key:"v-255c09a1",path:"/pages/b825b8/",headers:[{level:2,title:"一、简介",slug:"一、简介",normalizedTitle:"一、简介",charIndex:15},{level:2,title:"二、IO与NIO的区别",slug:"二、io与nio的区别",normalizedTitle:"二、io与nio的区别",charIndex:164},{level:3,title:"1、面向流和缓冲区",slug:"_1、面向流和缓冲区",normalizedTitle:"1、面向流和缓冲区",charIndex:337},{level:2,title:"三、通道与缓冲区",slug:"三、通道与缓冲区",normalizedTitle:"三、通道与缓冲区",charIndex:538},{level:2,title:"四、缓冲区(Buffer)",slug:"四、缓冲区-buffer",normalizedTitle:"四、缓冲区(buffer)",charIndex:700},{level:3,title:"1、缓冲区类型",slug:"_1、缓冲区类型",normalizedTitle:"1、缓冲区类型",charIndex:718},{level:3,title:"2、获取缓冲区",slug:"_2、获取缓冲区",normalizedTitle:"2、获取缓冲区",charIndex:1114},{level:3,title:"3、核心属性",slug:"_3、核心属性",normalizedTitle:"3、核心属性",charIndex:1259},{level:3,title:"4、核心方法",slug:"_4、核心方法",normalizedTitle:"4、核心方法",charIndex:1719},{level:3,title:"5、非直接缓冲区和直接缓冲区",slug:"_5、非直接缓冲区和直接缓冲区",normalizedTitle:"5、非直接缓冲区和直接缓冲区",charIndex:4784},{level:2,title:"五、通道(Channel)",slug:"五、通道-channel",normalizedTitle:"五、通道(channel)",charIndex:5848},{level:3,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:5866},{level:3,title:"2、图解",slug:"_2、图解",normalizedTitle:"2、图解",charIndex:5993},{level:3,title:"3、Java Channel",slug:"_3、java-channel",normalizedTitle:"3、java channel",charIndex:6373},{level:3,title:"4、分散和聚集",slug:"_4、分散和聚集",normalizedTitle:"4、分散和聚集",charIndex:11922},{level:2,title:"六、非阻塞式网络通信",slug:"六、非阻塞式网络通信",normalizedTitle:"六、非阻塞式网络通信",charIndex:12978},{level:3,title:"1、概念",slug:"_1、概念",normalizedTitle:"1、概念",charIndex:12993},{level:3,title:"2、使用",slug:"_2、使用",normalizedTitle:"2、使用",charIndex:13646}],headersStr:"一、简介 二、IO与NIO的区别 1、面向流和缓冲区 三、通道与缓冲区 四、缓冲区(Buffer) 1、缓冲区类型 2、获取缓冲区 3、核心属性 4、核心方法 5、非直接缓冲区和直接缓冲区 五、通道(Channel) 1、简介 2、图解 3、Java Channel 4、分散和聚集 六、非阻塞式网络通信 1、概念 2、使用",content:'# Java NIO\n\n\n# 一、简介\n\nJava NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。\n\n\n# 二、IO与NIO的区别\n\nIO                     NIO\n面向流(Stream Oriented)   面向缓冲区(Buffer Oriented)\n阻塞IO(Blocking IO)      非阻塞IO(NonBlocking IO)\n                       选择器(Selectors)\n\n\n# 1、面向流和缓冲区\n\nIO\n\n传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的\n\n就像自来水要通过水管将自来水厂和家连接起来一样\n\n\n\nNIO\n\nNIO在传输数据时，会在输入输出端之间建立通道，然后将数据放入到缓冲区中。缓冲区通过通道来传输数据\n\n这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输\n\n\n\n\n# 三、通道与缓冲区\n\nJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理\n\n简而言之，通道负责传输，缓冲区负责存储\n\n\n# 四、缓冲区(Buffer)\n\n\n# 1、缓冲区类型\n\nBuffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下Buffer 常用子类\n\n * ByteBuffer\n * CharBuffer\n * ShortBuffer\n * IntBuffer\n * LongBuffer\n * FloatBuffer\n * DoubleBuffer\n\n各种类型的缓冲区中，都有一个对应类型的数组，如\n\nByteBuffer\n\nfinal byte[] hb;                  // Non-null only for heap buffersCopy\n\n\n1\n\n\nIntBuffer\n\nfinal int[] hb;                  // Non-null only for heap buffersCopy\n\n\n1\n\n\n他们的继承关系如下\n\n\n\n\n# 2、获取缓冲区\n\n通过allocate方法可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法\n\n例\n\n// 获取一个容量大小为1024字节的字节缓冲区\nByteBuffer byteBuffer = ByteBuffer.allocate(1024);Copy\n\n\n1\n2\n\n\n\n# 3、核心属性\n\n缓冲区的父类Buffer中有几个核心属性，如下\n\n// Invariants: mark <= position <= limit <= capacity\nprivate int mark = -1;\nprivate int position = 0;\nprivate int limit;\nprivate int capacity;Copy\n\n\n1\n2\n3\n4\n5\n\n * capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改\n * limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量\n * position：下一个读写位置的索引（类似PC）。缓冲区的位置不能为负，并且不能大于limit\n * mark：记录当前position的值。position被改变后，可以通过调用reset() 方法恢复到mark的位置。\n\n以上四个属性必须满足以下要求\n\nmark <= position <= limit <= capacity\n\n\n# 4、核心方法\n\n# put()方法\n\n * put()方法可以将一个数据放入到缓冲区中。\n * 进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。\n\n\n\n# flip()方法\n\n * flip()方法会切换对缓冲区的操作模式，由写->读 / 读->写\n * 进行该操作后\n   * 如果是写模式->读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变\n   * 如果是读->写，则恢复为put()方法中的值\n\n\n\n# get()方法\n\n * get()方法会读取缓冲区中的一个值\n * 进行该操作后，position会+1，如果超过了limit则会抛出异常\n\n\n\n# rewind()方法\n\n * 该方法只能在读模式下使用\n * rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值\n\n\n\n# clean()方法\n\n * clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit\n * 此时缓冲区的数据依然存在，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据\n\n\n\n# mark()和reset()方法\n\n * mark()方法会将postion的值保存到mark属性中\n * reset()方法会将position的值改为mark中保存的值\n\n# 使用展示\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n\t\tSystem.out.println("放入前参数");\n\t\tSystem.out.println("position " + byteBuffer.position());\n\t\tSystem.out.println("limit " + byteBuffer.limit());\n\t\tSystem.out.println("capacity " + byteBuffer.capacity());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println("------put()------");\n\t\tSystem.out.println("放入3个数据");\n\t\tbyte bt = 1;\n\t\tbyteBuffer.put(bt);\n\t\tbyteBuffer.put(bt);\n\t\tbyteBuffer.put(bt);\n\n\t\tSystem.out.println("放入后参数");\n\t\tSystem.out.println("position " + byteBuffer.position());\n\t\tSystem.out.println("limit " + byteBuffer.limit());\n\t\tSystem.out.println("capacity " + byteBuffer.capacity());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println("------flip()-get()------");\n\t\tSystem.out.println("读取一个数据");\n\t\t// 切换模式\n\t\tbyteBuffer.flip();\n\t\tbyteBuffer.get();\n\n\t\tSystem.out.println("读取后参数");\n\t\tSystem.out.println("position " + byteBuffer.position());\n\t\tSystem.out.println("limit " + byteBuffer.limit());\n\t\tSystem.out.println("capacity " + byteBuffer.capacity());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println("------rewind()------");\n\t\tbyteBuffer.rewind();\n\t\tSystem.out.println("恢复后参数");\n\t\tSystem.out.println("position " + byteBuffer.position());\n\t\tSystem.out.println("limit " + byteBuffer.limit());\n\t\tSystem.out.println("capacity " + byteBuffer.capacity());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println("------clear()------");\n\t\t// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在\n\t\t// 但是下次写入的时候会覆盖缓冲区中之前的数据\n\t\tbyteBuffer.clear();\n\t\tSystem.out.println("清空后参数");\n\t\tSystem.out.println("position " + byteBuffer.position());\n\t\tSystem.out.println("limit " + byteBuffer.limit());\n\t\tSystem.out.println("capacity " + byteBuffer.capacity());\n\t\tSystem.out.println();\n\t\tSystem.out.println("清空后获得数据");\n\t\tSystem.out.println(byteBuffer.get());\n\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n打印结果\n\n放入前参数\nposition 0\nlimit 1024\ncapacity 1024\n\n------put()------\n放入3个数据\n放入后参数\nposition 3\nlimit 1024\ncapacity 1024\n\n------flip()-get()------\n读取一个数据\n读取后参数\nposition 1\nlimit 3\ncapacity 1024\n\n------rewind()------\n恢复后参数\nposition 0\nlimit 3\ncapacity 1024\n\n------clear()------\n清空后参数\nposition 0\nlimit 1024\ncapacity 1024\n\n清空后获得数据\n1Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 5、非直接缓冲区和直接缓冲区\n\n# 非直接缓冲区\n\n通过allocate()方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM堆内存之中的。\n\npublic static ByteBuffer allocate(int capacity) {\n    if (capacity < 0)\n    throw new IllegalArgumentException();\n\n    // 在堆内存中开辟空间\n    return new HeapByteBuffer(capacity, capacity);\n}\n\nHeapByteBuffer(int cap, int lim) {        // package-private\n    // new byte[cap] 创建数组，在堆内存中开辟空间\n    super(-1, 0, lim, cap, new byte[cap], 0);\n    /*\n    hb = new byte[cap];\n    offset = 0;\n    */\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。都需要经过JVM和操作系统，数据在两个地址空间中传输时，会****一份保存在对方的空间中。所以费直接缓冲区的读取效率较低\n\n# 直接缓冲区\n\n只有ByteBuffer可以获得直接缓冲区，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在物理内存之中的。\n\npublic static ByteBuffer allocateDirect(int capacity) {\n    return new DirectByteBuffer(capacity);\n}\n\nDirectByteBuffer(int cap) {                   // package-private\n\t...\n    // 申请物理内存\n\tboolean pa = VM.isDirectMemoryPageAligned();\n\t...\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n直接缓冲区通过在操作系统和JVM之间创建物理内存映射文件加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中\n\n\n# 五、通道(Channel)\n\n\n# 1、简介\n\nChannel由java.nio.channels 包定义的。Channel 表示IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互\n\n\n# 2、图解\n\n应用程序进行读写操作调用函数时，底层调用的操作系统提供给用户的读写API，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，所有读写请求的指令都有CPU去执行，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低\n\n\n\n后来，DMA(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，DMA会向CPU请求，让DMA去处理这些IO操作，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率\n\n\n\n于是便有了Channel(通道)，Channel相当于一个专门用于IO操作的独立处理器，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求\n\n\n\n\n# 3、Java Channel\n\n# 常用实现类\n\n\n\n * 本地文件IO\n   * FileChannel\n * 网络IO\n   * SocketChanel、ServerSocketChannel：用于TCP传输\n   * DatagramChannel：用于UDP传输\n\n# 获得通道的方法\n\n获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：\n\n * FileInputStream\n * FileOutputStream\n * RandomAccessFile\n * DatagramSocket\n * Socket\n * ServerSocket\n\npublic class Demo2 {\n   public static void main(String[] args) throws IOException {\n      // 本地通道\n      FileInputStream fileInputStream = new FileInputStream("");\n      FileChannel channel1 = fileInputStream.getChannel();\n\n      FileOutputStream fileOutputStream = new FileOutputStream("");\n      FileChannel channel2 = fileOutputStream.getChannel();\n   \n      // 网络通道\n      Socket socket = new Socket();\n      SocketChannel channel3 = socket.getChannel();\n      \n      ServerSocket serverSocket = new ServerSocket();\n      ServerSocketChannel channel4 = serverSocket.getChannel();\n\n      DatagramSocket datagramSocket = new DatagramSocket();\n      DatagramChannel channel5 = datagramSocket.getChannel();\n       \n      // 最后要关闭通道\n       \n   }\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n也可以通过通道的静态方法open()来获取\n\npublic static void main(String[] args) throws IOException {\n   FileChannel open = FileChannel.open(Paths.get(""));\n   \n   SocketChannel open1 = SocketChannel.open();\n   \n   ...\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# getChannel()+非直接缓冲区\n\n * getChannel()获得通道\n * allocate()获得非直接缓冲区\n\n通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据\n\npublic class Demo4 {\n   public static void main(String[] args) {\n      FileInputStream is = null;\n      FileOutputStream os = null;\n      // 获得通道\n      FileChannel inChannel = null;\n      FileChannel outChannel = null;\n       \n      // 利用 try-catch-finally 保证关闭\n      try {\n         is = new FileInputStream("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\1.jpg");\n         os = new FileOutputStream("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\2.jpg");\n\n         // 获得通道\n         inChannel = is.getChannel();\n         outChannel = os.getChannel();\n\n         // 获得缓冲区，用于在通道中传输数据\n         ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n         // 循环将字节数据放入到buffer中，然后写入磁盘中\n         while (inChannel.read(byteBuffer) != -1) {\n            // 切换模式\n            byteBuffer.flip();\n            outChannel.write(byteBuffer);\n            byteBuffer.clear();\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n         if (inChannel != null) {\n            try {\n               inChannel.close();\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n         if (outChannel != null) {\n            try {\n               outChannel.close();\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n         if (is != null) {\n            try {\n               is.close();\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n         if (os != null) {\n            try {\n               os.close();\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n      }\n   }\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n图片读取后，被写入到了指定位置\n\n# open()+直接缓冲区\n\n * 通过open获得通道\n * 通过FileChannel.map()获取直接缓冲区\n\n使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可\n\npublic class Demo5 {\n   public static void main(String[] args) throws IOException {\n      // 通过open()方法来获得通道\n      FileChannel inChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\1.jpg"), StandardOpenOption.READ);\n\n      // outChannel需要为 READ WRITE CREATE模式\n      // READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式\n      // CREATE是因为要创建新的文件\n      FileChannel outChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\3.jpg"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n      // 获得直接缓冲区\n      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());\n      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());\n\n      // 字节数组\n      byte[] bytes = new byte[inMapBuf.limit()];\n\n      // 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输\n      inMapBuf.get(bytes);\n      outMapBuf.put(bytes);\n\n      // 关闭缓冲区，这里没有用try-catch-finally\n      inChannel.close();\n      outChannel.close();\n   }\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n运行结果，图片被创建\n\n# 通道间直接传输\n\npublic static void channelToChannel() throws IOException {\n   long start = System.currentTimeMillis();\n   // 通过open()方法来获得通道\n   FileChannel inChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\1.mp4"), StandardOpenOption.READ);\n\n   // outChannel需要为 READ WRITE CREATE模式\n   // READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式\n   // CREATE是因为要创建新的文件\n   FileChannel outChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\NIO\\\\day1\\\\4.mp4"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n   // 通道间直接传输\n   inChannel.transferTo(0, inChannel.size(), outChannel);\n   // 对应的还有transferFrom\n   // outChannel.transferFrom(inChannel, 0, inChannel.size());\n\n   inChannel.close();\n   outChannel.close();\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 直接缓冲区VS非直接缓冲区\n\n效率\n\n读取一个MP4文件，通过二者花费时间的多少来判定执行的速度\n\n// getChannel() + 非直接缓冲区耗时\n708\n// open() + 直接缓冲区耗时\n115\n// channel transferTo channel耗时\n47Copy\n\n\n1\n2\n3\n4\n5\n6\n\n\n内存占用\n\n直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢\n\n\n# 4、分散和聚集\n\n# 分散读取\n\n分散读取（Scattering Reads）是指从Channel 中读取的数据“分散”到多个Buffer 中\n\n注意：按照缓冲区的顺序，从Channel 中读取的数据依次将 Buffer 填满\n\n\n\n# 聚集写入\n\n聚集写入（Gathering Writes）是指将多个Buffer 中的数据“聚集”到Channel\n\n按照缓冲区的顺序，写入position 和limit 之间的数据到Channel\n\n\n\n代码\n\npublic class Demo2 {\n   public static void main(String[] args) throws IOException {\n      FileInputStream is = new FileInputStream("F:\\\\JDKLearning\\\\src\\\\main\\\\nio\\\\day2\\\\计划.txt");\n      FileOutputStream os = new FileOutputStream("F:\\\\JDKLearning\\\\src\\\\main\\\\nio\\\\day2\\\\计划2.txt");\n\n      FileChannel inChannel = is.getChannel();\n      FileChannel outChannel = os.getChannel();\n\n      // 获得多个缓冲区，并且放入到缓冲区数组中\n      ByteBuffer byteBuffer1 = ByteBuffer.allocate(50);\n      ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n      ByteBuffer[] byteBuffers = {byteBuffer1, byteBuffer2};\n\n      // 分散读取\n      inChannel.read(byteBuffers);\n      \n      byteBuffer1.flip();\n      byteBuffer2.flip();\n      \n      // 聚集写入\n      outChannel.write(byteBuffers);\n   }\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n\n\n\n# 六、非阻塞式网络通信\n\n\n# 1、概念\n\n# 举例\n\n双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递\n\n * 若为阻塞式的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了\n * 若为非阻塞式的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿\n\n# 阻塞式网络通信\n\n传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务\n\n因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降\n\n也就是说，服务器在等待IO准备就绪的期间，线程处于阻塞状态，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。\n\n\n\n# 非阻塞式网络通信\n\nJava NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以单独的线程可以管理多个输入和输出通道\n\n因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端\n\n\n\n\n# 2、使用\n\n# 阻塞式网络通信演示\n\npublic class Demo1 {\n   public static void main(String[] args) throws IOException {\n      Thread thread1 = new Thread(()->{\n         try {\n            server();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      });\n\n      Thread thread2 = new Thread(()->{\n         try {\n            client();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      });\n\n      thread1.start();\n      thread2.start();\n   }\n\n   public static void client() throws IOException {\n      // 创建客户端通道\n      SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 2022));\n\n      // 读取信息\n      FileChannel fileChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\nio\\\\day3\\\\1.jpg"), StandardOpenOption.READ);\n\n      // 创建缓冲区\n      ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n      // 写入数据\n      while (fileChannel.read(byteBuffer) != -1) {\n         byteBuffer.flip();\n         socketChannel.write(byteBuffer);\n         byteBuffer.clear();\n      }\n\n      fileChannel.close();\n      socketChannel.close();\n   }\n\n   public static void server() throws IOException {\n      // 创建服务端通道\n      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n      FileChannel fileChannel = FileChannel.open(Paths.get("F:\\\\JDKLearning\\\\src\\\\main\\\\nio\\\\day3\\\\2.jpg"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n      // 绑定链接\n      serverSocketChannel.bind(new InetSocketAddress(2022));\n\n      // 获取客户端的通道\n      SocketChannel socketChannel = serverSocketChannel.accept();\n\n      // 创建缓冲区\n      ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n      while (socketChannel.read(byteBuffer) != -1) {\n         byteBuffer.flip();\n         fileChannel.write(byteBuffer);\n         byteBuffer.clear();\n      }\n\n      socketChannel.close();\n      fileChannel.close();\n      serverSocketChannel.close();\n   }\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n# 非阻塞式网络通信演示\n\npublic class DemoNIO {\n\tpublic static void main(String[] args) {\n\t\tThread thread1 = new Thread(()->{\n\t\t\ttry {\n\t\t\t\tserver();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\n\t\tThread thread2 = new Thread(()->{\n\t\t\ttry {\n\t\t\t\tclient();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t\tthread1.start();\n\t\tthread2.start();\n\t}\n\n\tpublic static void client() throws IOException {\n\t\tSocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 2020));\n\n\t\t// 设置为非阻塞模式\n\t\tsocketChannel.configureBlocking(false);\n\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNext()) {\n\t\t\tString str = scanner.next();\n\t\t\tbyteBuffer.put(str.getBytes());\n\t\t\tbyteBuffer.flip();\n\t\t\tsocketChannel.write(byteBuffer);\n\t\t\tbyteBuffer.clear();\n\t\t}\n\n\t\tbyteBuffer.clear();\n\n\t\tsocketChannel.close();\n\t}\n\n\tpublic static void server() throws IOException {\n\t\tServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\t\tserverSocketChannel.configureBlocking(false);\n\t\tserverSocketChannel.bind(new InetSocketAddress(2020));\n\n\t\t// 获得选择器\n\t\tSelector selector = Selector.open();\n\n\t\t// 将通道注册到选择器中，设定为接收操作\n\t\tserverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\t\t// 轮训接受\n\t\twhile (selector.select() > 0) {\n\t\t\tIterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n\t\t\t// 获得事件的key\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tSelectionKey key = iterator.next();\n\t\t\t\tif (key.isAcceptable()) {\n\t\t\t\t\tSocketChannel socketChannel = serverSocketChannel.accept();\n\t\t\t\t\tsocketChannel.configureBlocking(false);\n\t\t\t\t\tsocketChannel.register(selector, SelectionKey.OP_READ);\n\t\t\t\t} else if (key.isReadable()) {\n\t\t\t\t\t// 从选择器中获取通道\n\t\t\t\t\tSocketChannel socketChannel = (SocketChannel) key.channel();\n\n\t\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(10);\n\n\t\t\t\t\twhile (socketChannel.read(byteBuffer) != -1) {\n\t\t\t\t\t\tint len = byteBuffer.limit();\n\t\t\t\t\t\tbyteBuffer.flip();\n\t\t\t\t\t\tSystem.out.println(new String(byteBuffer.array(), 0, len));\n\t\t\t\t\t\tbyteBuffer.clear();\n\t\t\t\t\t}\n\t\t\t\t\tsocketChannel.close();\n\t\t\t\t}\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tserverSocketChannel.close();\n\t}\n}Copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n# 选择器\n\n选择器（Selector）是SelectableChannle 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。Selector 是非阻塞IO 的核心\n\n\n\n选择器的创建\n\n// 创建一个选择器\nSelector selector = Selector.open();Copy\n\n\n1\n2\n\n\n绑定选择器\n\n通过调用通道的register方法可以绑定选择器，register方法有两个参数\n\n * Selector：即绑定哪个选择器\n\n * ops：监听事件类型。ops有4个值可以选择，为SelectionKey的静态属性\n   \n   \n\n// 让选择器监听一种状态\nmyChannel.register(selector, SelectionKey.OP_READ);\n// 让选择器监听多种状态\nmyChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);Copy\n\n\n1\n2\n3\n4\n\n\nSelectionKey\n\n表示SelectableChannel 和Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作',normalizedContent:'# java nio\n\n\n# 一、简介\n\njava nio（new io）是从java 1.4版本开始引入的一个新的io api，可以替代标准的java io api。nio与原来的io有同样的作用和目的，但是使用的方式完全不同，nio支持面向缓冲区的、基于通道的io操作。nio将以更加高效的方式进行文件的读写操作。\n\n\n# 二、io与nio的区别\n\nio                     nio\n面向流(stream oriented)   面向缓冲区(buffer oriented)\n阻塞io(blocking io)      非阻塞io(nonblocking io)\n                       选择器(selectors)\n\n\n# 1、面向流和缓冲区\n\nio\n\n传统io在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的\n\n就像自来水要通过水管将自来水厂和家连接起来一样\n\n\n\nnio\n\nnio在传输数据时，会在输入输出端之间建立通道，然后将数据放入到缓冲区中。缓冲区通过通道来传输数据\n\n这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输\n\n\n\n\n# 三、通道与缓冲区\n\njava nio系统的核心在于：通道(channel)和缓冲区(buffer)。通道表示打开到 io 设备(例如：文件、套接字)的连接。若需要使用 nio 系统，需要获取用于连接 io 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理\n\n简而言之，通道负责传输，缓冲区负责存储\n\n\n# 四、缓冲区(buffer)\n\n\n# 1、缓冲区类型\n\nbuffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下buffer 常用子类\n\n * bytebuffer\n * charbuffer\n * shortbuffer\n * intbuffer\n * longbuffer\n * floatbuffer\n * doublebuffer\n\n各种类型的缓冲区中，都有一个对应类型的数组，如\n\nbytebuffer\n\nfinal byte[] hb;                  // non-null only for heap bufferscopy\n\n\n1\n\n\nintbuffer\n\nfinal int[] hb;                  // non-null only for heap bufferscopy\n\n\n1\n\n\n他们的继承关系如下\n\n\n\n\n# 2、获取缓冲区\n\n通过allocate方法可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法\n\n例\n\n// 获取一个容量大小为1024字节的字节缓冲区\nbytebuffer bytebuffer = bytebuffer.allocate(1024);copy\n\n\n1\n2\n\n\n\n# 3、核心属性\n\n缓冲区的父类buffer中有几个核心属性，如下\n\n// invariants: mark <= position <= limit <= capacity\nprivate int mark = -1;\nprivate int position = 0;\nprivate int limit;\nprivate int capacity;copy\n\n\n1\n2\n3\n4\n5\n\n * capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改\n * limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量\n * position：下一个读写位置的索引（类似pc）。缓冲区的位置不能为负，并且不能大于limit\n * mark：记录当前position的值。position被改变后，可以通过调用reset() 方法恢复到mark的位置。\n\n以上四个属性必须满足以下要求\n\nmark <= position <= limit <= capacity\n\n\n# 4、核心方法\n\n# put()方法\n\n * put()方法可以将一个数据放入到缓冲区中。\n * 进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。\n\n\n\n# flip()方法\n\n * flip()方法会切换对缓冲区的操作模式，由写->读 / 读->写\n * 进行该操作后\n   * 如果是写模式->读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变\n   * 如果是读->写，则恢复为put()方法中的值\n\n\n\n# get()方法\n\n * get()方法会读取缓冲区中的一个值\n * 进行该操作后，position会+1，如果超过了limit则会抛出异常\n\n\n\n# rewind()方法\n\n * 该方法只能在读模式下使用\n * rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值\n\n\n\n# clean()方法\n\n * clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit\n * 此时缓冲区的数据依然存在，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据\n\n\n\n# mark()和reset()方法\n\n * mark()方法会将postion的值保存到mark属性中\n * reset()方法会将position的值改为mark中保存的值\n\n# 使用展示\n\npublic class demo1 {\n\tpublic static void main(string[] args) {\n\t\tbytebuffer bytebuffer = bytebuffer.allocate(1024);\n\n\t\tsystem.out.println("放入前参数");\n\t\tsystem.out.println("position " + bytebuffer.position());\n\t\tsystem.out.println("limit " + bytebuffer.limit());\n\t\tsystem.out.println("capacity " + bytebuffer.capacity());\n\t\tsystem.out.println();\n\n\t\tsystem.out.println("------put()------");\n\t\tsystem.out.println("放入3个数据");\n\t\tbyte bt = 1;\n\t\tbytebuffer.put(bt);\n\t\tbytebuffer.put(bt);\n\t\tbytebuffer.put(bt);\n\n\t\tsystem.out.println("放入后参数");\n\t\tsystem.out.println("position " + bytebuffer.position());\n\t\tsystem.out.println("limit " + bytebuffer.limit());\n\t\tsystem.out.println("capacity " + bytebuffer.capacity());\n\t\tsystem.out.println();\n\n\t\tsystem.out.println("------flip()-get()------");\n\t\tsystem.out.println("读取一个数据");\n\t\t// 切换模式\n\t\tbytebuffer.flip();\n\t\tbytebuffer.get();\n\n\t\tsystem.out.println("读取后参数");\n\t\tsystem.out.println("position " + bytebuffer.position());\n\t\tsystem.out.println("limit " + bytebuffer.limit());\n\t\tsystem.out.println("capacity " + bytebuffer.capacity());\n\t\tsystem.out.println();\n\n\t\tsystem.out.println("------rewind()------");\n\t\tbytebuffer.rewind();\n\t\tsystem.out.println("恢复后参数");\n\t\tsystem.out.println("position " + bytebuffer.position());\n\t\tsystem.out.println("limit " + bytebuffer.limit());\n\t\tsystem.out.println("capacity " + bytebuffer.capacity());\n\t\tsystem.out.println();\n\n\t\tsystem.out.println("------clear()------");\n\t\t// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在\n\t\t// 但是下次写入的时候会覆盖缓冲区中之前的数据\n\t\tbytebuffer.clear();\n\t\tsystem.out.println("清空后参数");\n\t\tsystem.out.println("position " + bytebuffer.position());\n\t\tsystem.out.println("limit " + bytebuffer.limit());\n\t\tsystem.out.println("capacity " + bytebuffer.capacity());\n\t\tsystem.out.println();\n\t\tsystem.out.println("清空后获得数据");\n\t\tsystem.out.println(bytebuffer.get());\n\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n打印结果\n\n放入前参数\nposition 0\nlimit 1024\ncapacity 1024\n\n------put()------\n放入3个数据\n放入后参数\nposition 3\nlimit 1024\ncapacity 1024\n\n------flip()-get()------\n读取一个数据\n读取后参数\nposition 1\nlimit 3\ncapacity 1024\n\n------rewind()------\n恢复后参数\nposition 0\nlimit 3\ncapacity 1024\n\n------clear()------\n清空后参数\nposition 0\nlimit 1024\ncapacity 1024\n\n清空后获得数据\n1copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 5、非直接缓冲区和直接缓冲区\n\n# 非直接缓冲区\n\n通过allocate()方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在jvm堆内存之中的。\n\npublic static bytebuffer allocate(int capacity) {\n    if (capacity < 0)\n    throw new illegalargumentexception();\n\n    // 在堆内存中开辟空间\n    return new heapbytebuffer(capacity, capacity);\n}\n\nheapbytebuffer(int cap, int lim) {        // package-private\n    // new byte[cap] 创建数组，在堆内存中开辟空间\n    super(-1, 0, lim, cap, new byte[cap], 0);\n    /*\n    hb = new byte[cap];\n    offset = 0;\n    */\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。都需要经过jvm和操作系统，数据在两个地址空间中传输时，会****一份保存在对方的空间中。所以费直接缓冲区的读取效率较低\n\n# 直接缓冲区\n\n只有bytebuffer可以获得直接缓冲区，通过allocatedirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在物理内存之中的。\n\npublic static bytebuffer allocatedirect(int capacity) {\n    return new directbytebuffer(capacity);\n}\n\ndirectbytebuffer(int cap) {                   // package-private\n\t...\n    // 申请物理内存\n\tboolean pa = vm.isdirectmemorypagealigned();\n\t...\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n直接缓冲区通过在操作系统和jvm之间创建物理内存映射文件加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中\n\n\n# 五、通道(channel)\n\n\n# 1、简介\n\nchannel由java.nio.channels 包定义的。channel 表示io 源与目标打开的连接。channel 类似于传统的“流”。只不过channel 本身不能直接访问数据，channel 只能与buffer 进行交互\n\n\n# 2、图解\n\n应用程序进行读写操作调用函数时，底层调用的操作系统提供给用户的读写api，调用这些api时会生成对应的指令，cpu则会执行这些指令。在计算机刚出现的那段时间，所有读写请求的指令都有cpu去执行，过多的读写请求会导致cpu无法去执行其他命令，从而cpu的利用率降低\n\n\n\n后来，dma(direct memory access，直接存储器访问)出现了。当io请求传到计算机底层时，dma会向cpu请求，让dma去处理这些io操作，从而可以让cpu去执行其他指令。dma处理io操作时，会请求获取总线的使用权。当io请求过多时，会导致大量总线用于处理io请求，从而降低效率\n\n\n\n于是便有了channel(通道)，channel相当于一个专门用于io操作的独立处理器，它具有独立处理io请求的能力，当有io请求时，它会自行处理这些io请求\n\n\n\n\n# 3、java channel\n\n# 常用实现类\n\n\n\n * 本地文件io\n   * filechannel\n * 网络io\n   * socketchanel、serversocketchannel：用于tcp传输\n   * datagramchannel：用于udp传输\n\n# 获得通道的方法\n\n获取通道的一种方式是对支持通道的对象调用getchannel() 方法。支持通道的类如下：\n\n * fileinputstream\n * fileoutputstream\n * randomaccessfile\n * datagramsocket\n * socket\n * serversocket\n\npublic class demo2 {\n   public static void main(string[] args) throws ioexception {\n      // 本地通道\n      fileinputstream fileinputstream = new fileinputstream("");\n      filechannel channel1 = fileinputstream.getchannel();\n\n      fileoutputstream fileoutputstream = new fileoutputstream("");\n      filechannel channel2 = fileoutputstream.getchannel();\n   \n      // 网络通道\n      socket socket = new socket();\n      socketchannel channel3 = socket.getchannel();\n      \n      serversocket serversocket = new serversocket();\n      serversocketchannel channel4 = serversocket.getchannel();\n\n      datagramsocket datagramsocket = new datagramsocket();\n      datagramchannel channel5 = datagramsocket.getchannel();\n       \n      // 最后要关闭通道\n       \n   }\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n也可以通过通道的静态方法open()来获取\n\npublic static void main(string[] args) throws ioexception {\n   filechannel open = filechannel.open(paths.get(""));\n   \n   socketchannel open1 = socketchannel.open();\n   \n   ...\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# getchannel()+非直接缓冲区\n\n * getchannel()获得通道\n * allocate()获得非直接缓冲区\n\n通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据\n\npublic class demo4 {\n   public static void main(string[] args) {\n      fileinputstream is = null;\n      fileoutputstream os = null;\n      // 获得通道\n      filechannel inchannel = null;\n      filechannel outchannel = null;\n       \n      // 利用 try-catch-finally 保证关闭\n      try {\n         is = new fileinputstream("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\1.jpg");\n         os = new fileoutputstream("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\2.jpg");\n\n         // 获得通道\n         inchannel = is.getchannel();\n         outchannel = os.getchannel();\n\n         // 获得缓冲区，用于在通道中传输数据\n         bytebuffer bytebuffer = bytebuffer.allocate(1024);\n\n         // 循环将字节数据放入到buffer中，然后写入磁盘中\n         while (inchannel.read(bytebuffer) != -1) {\n            // 切换模式\n            bytebuffer.flip();\n            outchannel.write(bytebuffer);\n            bytebuffer.clear();\n         }\n      } catch (ioexception e) {\n         e.printstacktrace();\n      } finally {\n         if (inchannel != null) {\n            try {\n               inchannel.close();\n            } catch (ioexception e) {\n               e.printstacktrace();\n            }\n         }\n         if (outchannel != null) {\n            try {\n               outchannel.close();\n            } catch (ioexception e) {\n               e.printstacktrace();\n            }\n         }\n         if (is != null) {\n            try {\n               is.close();\n            } catch (ioexception e) {\n               e.printstacktrace();\n            }\n         }\n         if (os != null) {\n            try {\n               os.close();\n            } catch (ioexception e) {\n               e.printstacktrace();\n            }\n         }\n      }\n   }\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n图片读取后，被写入到了指定位置\n\n# open()+直接缓冲区\n\n * 通过open获得通道\n * 通过filechannel.map()获取直接缓冲区\n\n使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可\n\npublic class demo5 {\n   public static void main(string[] args) throws ioexception {\n      // 通过open()方法来获得通道\n      filechannel inchannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\1.jpg"), standardopenoption.read);\n\n      // outchannel需要为 read write create模式\n      // read write是因为后面获取直接缓冲区时模式为read_write模式\n      // create是因为要创建新的文件\n      filechannel outchannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\3.jpg"), standardopenoption.read, standardopenoption.write, standardopenoption.create);\n\n      // 获得直接缓冲区\n      mappedbytebuffer inmapbuf = inchannel.map(filechannel.mapmode.read_only, 0, inchannel.size());\n      mappedbytebuffer outmapbuf = outchannel.map(filechannel.mapmode.read_write, 0, inchannel.size());\n\n      // 字节数组\n      byte[] bytes = new byte[inmapbuf.limit()];\n\n      // 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输\n      inmapbuf.get(bytes);\n      outmapbuf.put(bytes);\n\n      // 关闭缓冲区，这里没有用try-catch-finally\n      inchannel.close();\n      outchannel.close();\n   }\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n运行结果，图片被创建\n\n# 通道间直接传输\n\npublic static void channeltochannel() throws ioexception {\n   long start = system.currenttimemillis();\n   // 通过open()方法来获得通道\n   filechannel inchannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\1.mp4"), standardopenoption.read);\n\n   // outchannel需要为 read write create模式\n   // read write是因为后面获取直接缓冲区时模式为read_write模式\n   // create是因为要创建新的文件\n   filechannel outchannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day1\\\\4.mp4"), standardopenoption.read, standardopenoption.write, standardopenoption.create);\n\n   // 通道间直接传输\n   inchannel.transferto(0, inchannel.size(), outchannel);\n   // 对应的还有transferfrom\n   // outchannel.transferfrom(inchannel, 0, inchannel.size());\n\n   inchannel.close();\n   outchannel.close();\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 直接缓冲区vs非直接缓冲区\n\n效率\n\n读取一个mp4文件，通过二者花费时间的多少来判定执行的速度\n\n// getchannel() + 非直接缓冲区耗时\n708\n// open() + 直接缓冲区耗时\n115\n// channel transferto channel耗时\n47copy\n\n\n1\n2\n3\n4\n5\n6\n\n\n内存占用\n\n直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢\n\n\n# 4、分散和聚集\n\n# 分散读取\n\n分散读取（scattering reads）是指从channel 中读取的数据“分散”到多个buffer 中\n\n注意：按照缓冲区的顺序，从channel 中读取的数据依次将 buffer 填满\n\n\n\n# 聚集写入\n\n聚集写入（gathering writes）是指将多个buffer 中的数据“聚集”到channel\n\n按照缓冲区的顺序，写入position 和limit 之间的数据到channel\n\n\n\n代码\n\npublic class demo2 {\n   public static void main(string[] args) throws ioexception {\n      fileinputstream is = new fileinputstream("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day2\\\\计划.txt");\n      fileoutputstream os = new fileoutputstream("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day2\\\\计划2.txt");\n\n      filechannel inchannel = is.getchannel();\n      filechannel outchannel = os.getchannel();\n\n      // 获得多个缓冲区，并且放入到缓冲区数组中\n      bytebuffer bytebuffer1 = bytebuffer.allocate(50);\n      bytebuffer bytebuffer2 = bytebuffer.allocate(1024);\n      bytebuffer[] bytebuffers = {bytebuffer1, bytebuffer2};\n\n      // 分散读取\n      inchannel.read(bytebuffers);\n      \n      bytebuffer1.flip();\n      bytebuffer2.flip();\n      \n      // 聚集写入\n      outchannel.write(bytebuffers);\n   }\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n\n\n\n# 六、非阻塞式网络通信\n\n\n# 1、概念\n\n# 举例\n\n双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递\n\n * 若为阻塞式的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了\n * 若为非阻塞式的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿\n\n# 阻塞式网络通信\n\n传统的io 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务\n\n因此，在完成网络通信进行io 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降\n\n也就是说，服务器在等待io准备就绪的期间，线程处于阻塞状态，若为单线程，等待期间cpu未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待io准备就绪时，cpu可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。\n\n\n\n# 非阻塞式网络通信\n\njava nio 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞io 的空闲时间用于在其他通道上执行io 操作，所以单独的线程可以管理多个输入和输出通道\n\n因此，nio 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端\n\n\n\n\n# 2、使用\n\n# 阻塞式网络通信演示\n\npublic class demo1 {\n   public static void main(string[] args) throws ioexception {\n      thread thread1 = new thread(()->{\n         try {\n            server();\n         } catch (ioexception e) {\n            e.printstacktrace();\n         }\n      });\n\n      thread thread2 = new thread(()->{\n         try {\n            client();\n         } catch (ioexception e) {\n            e.printstacktrace();\n         }\n      });\n\n      thread1.start();\n      thread2.start();\n   }\n\n   public static void client() throws ioexception {\n      // 创建客户端通道\n      socketchannel socketchannel = socketchannel.open(new inetsocketaddress("127.0.0.1", 2022));\n\n      // 读取信息\n      filechannel filechannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day3\\\\1.jpg"), standardopenoption.read);\n\n      // 创建缓冲区\n      bytebuffer bytebuffer = bytebuffer.allocate(1024);\n\n      // 写入数据\n      while (filechannel.read(bytebuffer) != -1) {\n         bytebuffer.flip();\n         socketchannel.write(bytebuffer);\n         bytebuffer.clear();\n      }\n\n      filechannel.close();\n      socketchannel.close();\n   }\n\n   public static void server() throws ioexception {\n      // 创建服务端通道\n      serversocketchannel serversocketchannel = serversocketchannel.open();\n\n      filechannel filechannel = filechannel.open(paths.get("f:\\\\jdklearning\\\\src\\\\main\\\\nio\\\\day3\\\\2.jpg"), standardopenoption.write, standardopenoption.create);\n\n      // 绑定链接\n      serversocketchannel.bind(new inetsocketaddress(2022));\n\n      // 获取客户端的通道\n      socketchannel socketchannel = serversocketchannel.accept();\n\n      // 创建缓冲区\n      bytebuffer bytebuffer = bytebuffer.allocate(1024);\n\n      while (socketchannel.read(bytebuffer) != -1) {\n         bytebuffer.flip();\n         filechannel.write(bytebuffer);\n         bytebuffer.clear();\n      }\n\n      socketchannel.close();\n      filechannel.close();\n      serversocketchannel.close();\n   }\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n# 非阻塞式网络通信演示\n\npublic class demonio {\n\tpublic static void main(string[] args) {\n\t\tthread thread1 = new thread(()->{\n\t\t\ttry {\n\t\t\t\tserver();\n\t\t\t} catch (ioexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t});\n\n\t\tthread thread2 = new thread(()->{\n\t\t\ttry {\n\t\t\t\tclient();\n\t\t\t} catch (ioexception e) {\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t\t});\n\t\tthread1.start();\n\t\tthread2.start();\n\t}\n\n\tpublic static void client() throws ioexception {\n\t\tsocketchannel socketchannel = socketchannel.open(new inetsocketaddress("127.0.0.1", 2020));\n\n\t\t// 设置为非阻塞模式\n\t\tsocketchannel.configureblocking(false);\n\n\t\tbytebuffer bytebuffer = bytebuffer.allocate(1024);\n\n\t\tscanner scanner = new scanner(system.in);\n\t\twhile (scanner.hasnext()) {\n\t\t\tstring str = scanner.next();\n\t\t\tbytebuffer.put(str.getbytes());\n\t\t\tbytebuffer.flip();\n\t\t\tsocketchannel.write(bytebuffer);\n\t\t\tbytebuffer.clear();\n\t\t}\n\n\t\tbytebuffer.clear();\n\n\t\tsocketchannel.close();\n\t}\n\n\tpublic static void server() throws ioexception {\n\t\tserversocketchannel serversocketchannel = serversocketchannel.open();\n\t\tserversocketchannel.configureblocking(false);\n\t\tserversocketchannel.bind(new inetsocketaddress(2020));\n\n\t\t// 获得选择器\n\t\tselector selector = selector.open();\n\n\t\t// 将通道注册到选择器中，设定为接收操作\n\t\tserversocketchannel.register(selector, selectionkey.op_accept);\n\n\t\t// 轮训接受\n\t\twhile (selector.select() > 0) {\n\t\t\titerator<selectionkey> iterator = selector.selectedkeys().iterator();\n\t\t\t// 获得事件的key\n\t\t\twhile (iterator.hasnext()) {\n\t\t\t\tselectionkey key = iterator.next();\n\t\t\t\tif (key.isacceptable()) {\n\t\t\t\t\tsocketchannel socketchannel = serversocketchannel.accept();\n\t\t\t\t\tsocketchannel.configureblocking(false);\n\t\t\t\t\tsocketchannel.register(selector, selectionkey.op_read);\n\t\t\t\t} else if (key.isreadable()) {\n\t\t\t\t\t// 从选择器中获取通道\n\t\t\t\t\tsocketchannel socketchannel = (socketchannel) key.channel();\n\n\t\t\t\t\tbytebuffer bytebuffer = bytebuffer.allocate(10);\n\n\t\t\t\t\twhile (socketchannel.read(bytebuffer) != -1) {\n\t\t\t\t\t\tint len = bytebuffer.limit();\n\t\t\t\t\t\tbytebuffer.flip();\n\t\t\t\t\t\tsystem.out.println(new string(bytebuffer.array(), 0, len));\n\t\t\t\t\t\tbytebuffer.clear();\n\t\t\t\t\t}\n\t\t\t\t\tsocketchannel.close();\n\t\t\t\t}\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tserversocketchannel.close();\n\t}\n}copy\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n# 选择器\n\n选择器（selector）是selectablechannle 对象的多路复用器，selector 可以同时监控多个selectablechannel 的io 状况，也就是说，利用selector 可使一个单独的线程管理多个channel。selector 是非阻塞io 的核心\n\n\n\n选择器的创建\n\n// 创建一个选择器\nselector selector = selector.open();copy\n\n\n1\n2\n\n\n绑定选择器\n\n通过调用通道的register方法可以绑定选择器，register方法有两个参数\n\n * selector：即绑定哪个选择器\n\n * ops：监听事件类型。ops有4个值可以选择，为selectionkey的静态属性\n   \n   \n\n// 让选择器监听一种状态\nmychannel.register(selector, selectionkey.op_read);\n// 让选择器监听多种状态\nmychannel.register(selector, selectionkey.op_read | selectionkey.op_accept);copy\n\n\n1\n2\n3\n4\n\n\nselectionkey\n\n表示selectablechannel 和selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作',charsets:{cjk:!0},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"ES",frontmatter:{title:"ES",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/f4d6a4/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E5%BA%93/ES.html",relativePath:"02.数据库/ES.md",key:"v-4721bed4",path:"/pages/f4d6a4/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"MogoDB",frontmatter:{title:"MogoDB",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/fa91e2/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E5%BA%93/MogoDB.html",relativePath:"02.数据库/MogoDB.md",key:"v-062877d6",path:"/pages/fa91e2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"MySQL",frontmatter:{title:"MySQL",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/7e2298/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html",relativePath:"02.数据库/MySQL.md",key:"v-c44d2880",path:"/pages/7e2298/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"MybastisPlus",frontmatter:{title:"MybastisPlus",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/7e5d5d/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MybastisPlus.html",relativePath:"03.计算机基础/MybastisPlus.md",key:"v-3da84d0d",path:"/pages/7e5d5d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"SpringBoot",frontmatter:{title:"SpringBoot",date:"2022-05-24T15:20:40.000Z",permalink:"/pages/4501c4/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/SpringBoot.html",relativePath:"03.计算机基础/SpringBoot.md",key:"v-4537776d",path:"/pages/4501c4/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/24, 14:05:00",lastUpdatedTimestamp:1653402068e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-536574fe",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/22, 16:04:00",lastUpdatedTimestamp:1650646275e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/web.png",heroText:"Jerry's Binlog",tagline:"Write the Code. Change the World.",actionText:"Immediately into →",actionLink:"/java/",bannerBg:"none",postList:"simple"},regularPath:"/",relativePath:"index.md",key:"v-bf924ecc",path:"/",headersStr:null,content:"Learning is the process, not the result.",normalizedContent:"learning is the process, not the result.",charsets:{},lastUpdated:"2022/05/03, 11:05:00",lastUpdatedTimestamp:1651576601e3}],themeConfig:{nav:[{text:"HomePage",link:"/"},{text:"Java",link:"/java/",items:[{text:"Java虚拟机",link:"/java/jvm/"},{text:"Java并发编程",link:"/java/juc/"}]},{text:"Database",link:"/database/",items:[{text:"MySQL",link:"/database/mysql/"},{text:"MongoDB",link:"/database/mongodb/"}]},{text:"Framework",link:"/framework/",items:[{text:"Mybatis-plus",link:"/framework/mybatis-plus/"},{text:"SpringBoot",link:"/framework/springboot/"}]},{text:"Development",link:"/dev/",items:[{text:"Git",link:"/dev/git/"}]},{text:"Project",link:"/project/",items:[{text:"project-01",link:"/project/campus01/"},{text:"project-02",link:"/project/campus02/"},{text:"project-03",link:"/project/campus03/"}]},{text:"About",link:"/about/"}],sidebarDepth:2,logo:"/img/logo.png",repo:"QianyizzZ/notes",searchMaxSuggestions:10,lastUpdated:"最后更新",docsDir:"docs",editLinks:!0,editLinkText:"在 GitHub 上编辑此页",category:!1,tag:!1,sidebar:{},updateBar:{showToArticle:!0},author:{name:"wxy",href:"https://qianyizzz.github.io/notes/"},footer:{createYear:2022,copyrightInfo:'oddfar | <a href="https://note.oddfar.com/sitemap.xml" target="_blank">sitemap.xml</a> | <a href="https://beian.miit.gov.cn/" target="_blank">冀ICP备20001094号</a>'}}},lc=(e(160),e(216),e(149),e(225)),uc=e(226),pc=(e(398),e(241),e(44));var dc={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var t=n.frontmatter,e=t.pageComponent,r=t.article,i=t.home;return!(e||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,t){var e=n.frontmatter.sticky,r=t.frontmatter.sticky;return e&&r?e==r?Object(pc.a)(n,t):e-r:e&&!r?-1:!e&&r?1:Object(pc.a)(n,t)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,t){return Object(pc.a)(n,t)})),n;var n},$groupPosts:function(){return function(n){for(var t={},e={},r=function(r,i){var a=n[r].frontmatter,o=a.categories,s=a.tags;"array"===Object(pc.n)(o)&&o.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})),"array"===Object(pc.n)(s)&&s.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}))},i=0,a=n.length;i<a;i++)r(i);return{categories:t,tags:e}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var t=[],e=[];for(var r in n.categories)t.push({key:r,length:n.categories[r].length});for(var i in n.tags)e.push({key:i,length:n.tags[i].length});return{categories:t,tags:e}}(this.$groupPosts)}}};Mi.component(lc.default),Mi.component(uc.default);function fc(n){return n.toString().padStart(2,"0")}e(402);Mi.component("Badge",(function(){return Promise.all([e.e(0),e.e(3)]).then(e.bind(null,514))})),Mi.component("CodeBlock",(function(){return Promise.resolve().then(e.bind(null,225))})),Mi.component("CodeGroup",(function(){return Promise.resolve().then(e.bind(null,226))}));e(403),e(404);var hc=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var t=n.Vue,e=(n.options,n.router,n.siteData);e.pages.map((function(n){var t=n.frontmatter,r=t.date,i=t.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(fc(n.getUTCMonth()+1),"-").concat(fc(n.getUTCDate())," ").concat(fc(n.getUTCHours()),":").concat(fc(n.getUTCMinutes()),":").concat(fc(n.getUTCSeconds()))}(r)),i?n.author=i:e.themeConfig.author&&(n.author=e.themeConfig.author)})),t.mixin(dc)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(){"undefined"!=typeof window&&function(n,t,e){function r(n){var e=t.createElement("div");e.className="heart",i.push({el:e,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),t.body.appendChild(e)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var e=t.createElement("style");e.type="text/css";try{e.appendChild(t.createTextNode(n))}catch(t){e.styleSheet.cssText=n}t.getElementsByTagName("head")[0].appendChild(e)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var t="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){var e=!0;n.path&&n.path.forEach((function(n){1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(e=!1)})),e&&(t&&t(),r(n))}}(),function n(){for(var e=0;e<i.length;e++)i[e].alpha<=0?(t.body.removeChild(i[e].el),i.splice(e,1)):(i[e].y--,i[e].scale+=.004,i[e].alpha-=.013,i[e].el.style.cssText="left:"+i[e].x+"px;top:"+i[e].y+"px;opacity:"+i[e].alpha+";transform:scale("+i[e].scale+","+i[e].scale+") rotate(45deg);background:"+i[e].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],mc=[];e(65),e(78);e(133);function vc(n,t){return(vc=Object.setPrototypeOf||function(n,t){return n.__proto__=t,n})(n,t)}e(219),e(220);function gc(n){return(gc=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function bc(n,t){if(t&&("object"===Object(Co.a)(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function yc(n){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var e,r=gc(n);if(t){var i=gc(this).constructor;e=Reflect.construct(r,arguments,i)}else e=r.apply(this,arguments);return bc(this,e)}}var wc=function(n){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&vc(n,t)}(e,n);var t=yc(e);function e(){return us(this,e),t.apply(this,arguments)}return ds(e)}(function(){function n(){us(this,n),this.store=new Mi({data:{state:{}}})}return ds(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,t){Mi.set(this.store.state,n,t)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(wc.prototype,{getPageAsyncComponent:qo,getLayoutAsyncComponent:Vo,getAsyncComponent:Jo,getVueComponent:Wo});var kc={install:function(n){var t=new wc;n.$vuepress=t,n.prototype.$vuepress=t}};function xc(n){n.beforeEach((function(t,e,r){if(_c(n,t.path))r();else if(/(\/|\.html)$/.test(t.path))if(/\/$/.test(t.path)){var i=t.path.replace(/\/$/,"")+".html";_c(n,i)?r(i):r()}else r();else{var a=t.path+"/",o=t.path+".html";_c(n,o)?r(o):_c(n,a)?r(a):r()}}))}function _c(n,t){var e=t.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===e}))}var Sc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var t=this.pageKey||this.$parent.$page.key;return Ho("pageKey",t),Mi.component(t)||Mi.component(t,qo(t)),Mi.component(t)?n(t):n("")}},Tc={functional:!0,props:{slotKey:String,required:!0},render:function(n,t){var e=t.props,r=t.slots;return n("div",{class:["content__".concat(e.slotKey)]},r()[e.slotKey])}},jc={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Cc=(e(405),e(406),Object(ac.a)(jc,(function(){var n=this.$createElement,t=this._self._c||n;return t("span",[t("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[t("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),t("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),t("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Ic(){return(Ic=Object(i.a)(Object(r.a)().mark((function n(t){var e,i,a,o;return Object(r.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:cc.routerBase||cc.base,xc(i=new To({base:e,mode:"history",fallback:!1,routes:sc,scrollBehavior:function(n,t,e){return e||(n.hash?!Mi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(hc.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Mi,options:a,router:i,siteData:cc,isServer:t})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Mi(Object.assign(a,{router:i,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},mc.map((function(t){return n(t)})))])}})),n.abrupt("return",{app:o,router:i});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Mi.config.productionTip=!1,Mi.use(To),Mi.use(kc),Mi.mixin(function(n,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Mi;jo(t),e.$vuepress.$set("siteData",t);var r=n(e.$vuepress.$get("siteData")),i=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((function(n,t){return t.startsWith("$")&&(n[t]=a[t].get),n}),o),{computed:o}}((function(n){return function(){function t(){us(this,t)}return ds(t,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,t,e=this.$site.locales,r=void 0===e?{}:e;for(var i in r)"/"===i?t=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||t||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,t=this.$page.frontmatter.metaTitle;if("string"==typeof t)return t;var e=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return e?r?r+" | "+e:e:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var t=n.filter((function(n){return"description"===n.name}))[0];if(t)return t.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,t){for(var e=0;e<n.length;e++){var r=n[e];if(r.path.toLowerCase()===t.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),t}()}),cc)),Mi.component("Content",Sc),Mi.component("ContentSlotsDistributor",Tc),Mi.component("OutboundLink",Cc),Mi.component("ClientOnly",{functional:!0,render:function(n,t){var e=t.parent,r=t.children;if(e._isMounted)return r;e.$once("hook:mounted",(function(){e.$forceUpdate()}))}}),Mi.component("Layout",Vo("Layout")),Mi.component("NotFound",Vo("NotFound")),Mi.prototype.$withBase=function(n){var t=this.$site.base;return"/"===n.charAt(0)?t+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"295d5b8"},function(n){return Ic.apply(this,arguments)}(!1).then((function(n){var t=n.app;n.router.onReady((function(){t.$mount("#app")}))}))}]);